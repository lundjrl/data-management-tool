// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __reExport = (target, mod, secondTarget) => {
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(target, key) && key !== "default")
      __defProp(target, key, {
        get: () => mod[key],
        enumerable: true
      });
  if (secondTarget) {
    for (let key of __getOwnPropNames(mod))
      if (!__hasOwnProp.call(secondTarget, key) && key !== "default")
        __defProp(secondTarget, key, {
          get: () => mod[key],
          enumerable: true
        });
    return secondTarget;
  }
};
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  var Events = function() {
  };
  var EE = function(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  };
  var addListener = function(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  };
  var clearEvent = function(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  };
  var EventEmitter = function() {
    this._events = new Events;
    this._eventsCount = 0;
  };
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var decodeURIComponent2 = function(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type74 = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type74];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type74];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  };
  var hexCodeToInt = function(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  };
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  module.exports = decodeURIComponent2;
});

// node_modules/fast-querystring/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var parse5 = function(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value11 = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value11 = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value11 = value11.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value11 = fastDecode(value11) || value11;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value11;
          } else {
            if (currentValue.pop) {
              currentValue.push(value11);
            } else {
              result[key] = [currentValue, value11];
            }
          }
        }
        value11 = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  };
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {
  };
  Empty.prototype = Object.create(null);
  module.exports = parse5;
});

// node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  var encodeString = function(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len)
            break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  };
  var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  module.exports = { encodeString };
});

// node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var getAsPrimitive = function(value11) {
    const type74 = typeof value11;
    if (type74 === "string") {
      return encodeString(value11);
    } else if (type74 === "bigint") {
      return value11.toString();
    } else if (type74 === "boolean") {
      return value11 ? "true" : "false";
    } else if (type74 === "number" && Number.isFinite(value11)) {
      return value11 < 1000000000000000000000 ? "" + value11 : encodeString("" + value11);
    }
    return "";
  };
  var stringify = function(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value11 = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value11)) {
        valueLength = value11.length;
        for (let j = 0;j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value11[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value11);
      }
    }
    return result;
  };
  var { encodeString } = require_querystring();
  module.exports = stringify;
});

// node_modules/fast-querystring/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var parse5 = require_parse();
  var stringify = require_stringify();
  var fastQuerystring = {
    parse: parse5,
    stringify
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse5;
  module.exports.stringify = stringify;
});

// node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS((exports, module) => {
  var addMapEntry = function(map3, pair) {
    map3.set(pair[0], pair[1]);
    return map3;
  };
  var addSetEntry = function(set2, value15) {
    set2.add(value15);
    return set2;
  };
  var arrayEach = function(array5, iteratee) {
    var index = -1, length = array5 ? array5.length : 0;
    while (++index < length) {
      if (iteratee(array5[index], index, array5) === false) {
        break;
      }
    }
    return array5;
  };
  var arrayPush = function(array5, values) {
    var index = -1, length = values.length, offset = array5.length;
    while (++index < length) {
      array5[offset + index] = values[index];
    }
    return array5;
  };
  var arrayReduce = function(array5, iteratee, accumulator, initAccum) {
    var index = -1, length = array5 ? array5.length : 0;
    if (initAccum && length) {
      accumulator = array5[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array5[index], index, array5);
    }
    return accumulator;
  };
  var baseTimes = function(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  };
  var getValue = function(object13, key) {
    return object13 == null ? undefined : object13[key];
  };
  var isHostObject = function(value15) {
    var result = false;
    if (value15 != null && typeof value15.toString != "function") {
      try {
        result = !!(value15 + "");
      } catch (e2) {
      }
    }
    return result;
  };
  var mapToArray = function(map3) {
    var index = -1, result = Array(map3.size);
    map3.forEach(function(value15, key) {
      result[++index] = [key, value15];
    });
    return result;
  };
  var overArg = function(func, transform7) {
    return function(arg) {
      return func(transform7(arg));
    };
  };
  var setToArray = function(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value15) {
      result[++index] = value15;
    });
    return result;
  };
  var Hash3 = function(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var hashClear = function() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  };
  var hashDelete = function(key) {
    return this.has(key) && delete this.__data__[key];
  };
  var hashGet = function(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  };
  var hashHas = function(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  };
  var hashSet = function(key, value15) {
    var data = this.__data__;
    data[key] = nativeCreate && value15 === undefined ? HASH_UNDEFINED : value15;
    return this;
  };
  var ListCache = function(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var listCacheClear = function() {
    this.__data__ = [];
  };
  var listCacheDelete = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  };
  var listCacheGet = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  };
  var listCacheHas = function(key) {
    return assocIndexOf(this.__data__, key) > -1;
  };
  var listCacheSet = function(key, value15) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value15]);
    } else {
      data[index][1] = value15;
    }
    return this;
  };
  var MapCache = function(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var mapCacheClear = function() {
    this.__data__ = {
      hash: new Hash3,
      map: new (Map2 || ListCache),
      string: new Hash3
    };
  };
  var mapCacheDelete = function(key) {
    return getMapData(this, key)["delete"](key);
  };
  var mapCacheGet = function(key) {
    return getMapData(this, key).get(key);
  };
  var mapCacheHas = function(key) {
    return getMapData(this, key).has(key);
  };
  var mapCacheSet = function(key, value15) {
    getMapData(this, key).set(key, value15);
    return this;
  };
  var Stack = function(entries) {
    this.__data__ = new ListCache(entries);
  };
  var stackClear = function() {
    this.__data__ = new ListCache;
  };
  var stackDelete = function(key) {
    return this.__data__["delete"](key);
  };
  var stackGet = function(key) {
    return this.__data__.get(key);
  };
  var stackHas = function(key) {
    return this.__data__.has(key);
  };
  var stackSet = function(key, value15) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value15]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value15);
    return this;
  };
  var arrayLikeKeys = function(value15, inherited) {
    var result = isArray(value15) || isArguments(value15) ? baseTimes(value15.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value15) {
      if ((inherited || hasOwnProperty.call(value15, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  };
  var assignValue = function(object13, key, value15) {
    var objValue = object13[key];
    if (!(hasOwnProperty.call(object13, key) && eq(objValue, value15)) || value15 === undefined && !(key in object13)) {
      object13[key] = value15;
    }
  };
  var assocIndexOf = function(array5, key) {
    var length = array5.length;
    while (length--) {
      if (eq(array5[length][0], key)) {
        return length;
      }
    }
    return -1;
  };
  var baseAssign = function(object13, source) {
    return object13 && copyObject(source, keys(source), object13);
  };
  var baseClone = function(value15, isDeep, isFull, customizer, key, object13, stack) {
    var result;
    if (customizer) {
      result = object13 ? customizer(value15, key, object13, stack) : customizer(value15);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject2(value15)) {
      return value15;
    }
    var isArr = isArray(value15);
    if (isArr) {
      result = initCloneArray(value15);
      if (!isDeep) {
        return copyArray(value15, result);
      }
    } else {
      var tag = getTag(value15), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value15)) {
        return cloneBuffer(value15, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object13) {
        if (isHostObject(value15)) {
          return object13 ? value15 : {};
        }
        result = initCloneObject(isFunc ? {} : value15);
        if (!isDeep) {
          return copySymbols(value15, baseAssign(result, value15));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object13 ? value15 : {};
        }
        result = initCloneByTag(value15, tag, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack);
    var stacked = stack.get(value15);
    if (stacked) {
      return stacked;
    }
    stack.set(value15, result);
    if (!isArr) {
      var props = isFull ? getAllKeys(value15) : keys(value15);
    }
    arrayEach(props || value15, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value15[key2];
      }
      assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value15, stack));
    });
    return result;
  };
  var baseCreate = function(proto) {
    return isObject2(proto) ? objectCreate(proto) : {};
  };
  var baseGetAllKeys = function(object13, keysFunc, symbolsFunc) {
    var result = keysFunc(object13);
    return isArray(object13) ? result : arrayPush(result, symbolsFunc(object13));
  };
  var baseGetTag = function(value15) {
    return objectToString.call(value15);
  };
  var baseIsNative = function(value15) {
    if (!isObject2(value15) || isMasked(value15)) {
      return false;
    }
    var pattern3 = isFunction(value15) || isHostObject(value15) ? reIsNative : reIsHostCtor;
    return pattern3.test(toSource(value15));
  };
  var baseKeys = function(object13) {
    if (!isPrototype(object13)) {
      return nativeKeys(object13);
    }
    var result = [];
    for (var key in Object(object13)) {
      if (hasOwnProperty.call(object13, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  };
  var cloneBuffer = function(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  };
  var cloneArrayBuffer = function(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array3(result).set(new Uint8Array3(arrayBuffer));
    return result;
  };
  var cloneDataView = function(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  };
  var cloneMap = function(map3, isDeep, cloneFunc) {
    var array5 = isDeep ? cloneFunc(mapToArray(map3), true) : mapToArray(map3);
    return arrayReduce(array5, addMapEntry, new map3.constructor);
  };
  var cloneRegExp = function(regexp4) {
    var result = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
    result.lastIndex = regexp4.lastIndex;
    return result;
  };
  var cloneSet = function(set2, isDeep, cloneFunc) {
    var array5 = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
    return arrayReduce(array5, addSetEntry, new set2.constructor);
  };
  var cloneSymbol = function(symbol5) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol5)) : {};
  };
  var cloneTypedArray = function(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  };
  var copyArray = function(source, array5) {
    var index = -1, length = source.length;
    array5 || (array5 = Array(length));
    while (++index < length) {
      array5[index] = source[index];
    }
    return array5;
  };
  var copyObject = function(source, props, object13, customizer) {
    object13 || (object13 = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object13[key], source[key], key, object13, source) : undefined;
      assignValue(object13, key, newValue === undefined ? source[key] : newValue);
    }
    return object13;
  };
  var copySymbols = function(source, object13) {
    return copyObject(source, getSymbols(source), object13);
  };
  var getAllKeys = function(object13) {
    return baseGetAllKeys(object13, keys, getSymbols);
  };
  var getMapData = function(map3, key) {
    var data = map3.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  };
  var getNative = function(object13, key) {
    var value15 = getValue(object13, key);
    return baseIsNative(value15) ? value15 : undefined;
  };
  var initCloneArray = function(array5) {
    var length = array5.length, result = array5.constructor(length);
    if (length && typeof array5[0] == "string" && hasOwnProperty.call(array5, "index")) {
      result.index = array5.index;
      result.input = array5.input;
    }
    return result;
  };
  var initCloneObject = function(object13) {
    return typeof object13.constructor == "function" && !isPrototype(object13) ? baseCreate(getPrototype(object13)) : {};
  };
  var initCloneByTag = function(object13, tag, cloneFunc, isDeep) {
    var Ctor = object13.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object13);
      case boolTag:
      case dateTag:
        return new Ctor(+object13);
      case dataViewTag:
        return cloneDataView(object13, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object13, isDeep);
      case mapTag:
        return cloneMap(object13, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object13);
      case regexpTag:
        return cloneRegExp(object13);
      case setTag:
        return cloneSet(object13, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object13);
    }
  };
  var isIndex = function(value15, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value15 == "number" || reIsUint.test(value15)) && (value15 > -1 && value15 % 1 == 0 && value15 < length);
  };
  var isKeyable = function(value15) {
    var type74 = typeof value15;
    return type74 == "string" || type74 == "number" || type74 == "symbol" || type74 == "boolean" ? value15 !== "__proto__" : value15 === null;
  };
  var isMasked = function(func) {
    return !!maskSrcKey && maskSrcKey in func;
  };
  var isPrototype = function(value15) {
    var Ctor = value15 && value15.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value15 === proto;
  };
  var toSource = function(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  };
  var cloneDeep = function(value15) {
    return baseClone(value15, true, true);
  };
  var eq = function(value15, other) {
    return value15 === other || value15 !== value15 && other !== other;
  };
  var isArguments = function(value15) {
    return isArrayLikeObject(value15) && hasOwnProperty.call(value15, "callee") && (!propertyIsEnumerable.call(value15, "callee") || objectToString.call(value15) == argsTag);
  };
  var isArrayLike = function(value15) {
    return value15 != null && isLength(value15.length) && !isFunction(value15);
  };
  var isArrayLikeObject = function(value15) {
    return isObjectLike(value15) && isArrayLike(value15);
  };
  var isFunction = function(value15) {
    var tag = isObject2(value15) ? objectToString.call(value15) : "";
    return tag == funcTag || tag == genTag;
  };
  var isLength = function(value15) {
    return typeof value15 == "number" && value15 > -1 && value15 % 1 == 0 && value15 <= MAX_SAFE_INTEGER;
  };
  var isObject2 = function(value15) {
    var type74 = typeof value15;
    return !!value15 && (type74 == "object" || type74 == "function");
  };
  var isObjectLike = function(value15) {
    return !!value15 && typeof value15 == "object";
  };
  var keys = function(object13) {
    return isArrayLike(object13) ? arrayLikeKeys(object13) : baseKeys(object13);
  };
  var stubArray = function() {
    return [];
  };
  var stubFalse = function() {
    return false;
  };
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var promiseTag = "[object Promise]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var Symbol3 = root.Symbol;
  var Uint8Array3 = root.Uint8Array;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectCreate = Object.create;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined;
  var nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView");
  var Map2 = getNative(root, "Map");
  var Promise3 = getNative(root, "Promise");
  var Set5 = getNative(root, "Set");
  var WeakMap2 = getNative(root, "WeakMap");
  var nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2);
  var mapCtorString = toSource(Map2);
  var promiseCtorString = toSource(Promise3);
  var setCtorString = toSource(Set5);
  var weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol3 ? Symbol3.prototype : undefined;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  Hash3.prototype.clear = hashClear;
  Hash3.prototype["delete"] = hashDelete;
  Hash3.prototype.get = hashGet;
  Hash3.prototype.has = hashHas;
  Hash3.prototype.set = hashSet;
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise3 && getTag(Promise3.resolve()) != promiseTag || Set5 && getTag(new Set5) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
    getTag = function(value15) {
      var result = objectToString.call(value15), Ctor = result == objectTag ? value15.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  var isArray = Array.isArray;
  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = cloneDeep;
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// node_modules/compressible/index.js
var require_compressible = __commonJS((exports, module) => {
  var compressible = function(type74) {
    if (!type74 || typeof type74 !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type74);
    var mime = match && match[1].toLowerCase();
    var data = db[mime];
    if (data && data.compressible !== undefined) {
      return data.compressible;
    }
    return COMPRESSIBLE_TYPE_REGEXP.test(mime) || undefined;
  };
  /*!
   * compressible
   * Copyright(c) 2013 Jonathan Ong
   * Copyright(c) 2014 Jeremiah Senkpiel
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var COMPRESSIBLE_TYPE_REGEXP = /^text\/|\+(?:json|text|xml)$/i;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  module.exports = compressible;
});

// node_modules/@prisma/client/runtime/library.js
var require_library = __commonJS((exports, module) => {
  var io = function(e2) {
    return typeof e2 == "function" ? e2 : (r2) => r2.$extends(e2);
  };
  var oo = function(e2) {
    return e2;
  };
  var so = function(...e2) {
    return (r2) => r2;
  };
  var F = function(e2, r2) {
    let t3 = new RegExp(`\\x1b\\[${r2}m`, "g"), n = `\x1B[${e2}m`, i = `\x1B[${r2}m`;
    return function(o) {
      return !po.enabled || o == null ? o : n + (~("" + o).indexOf(i) ? o.replace(t3, i + n) : o) + i;
    };
  };
  var au = function(e2) {
    let r2 = { color: mo[su++ % mo.length], enabled: $r.enabled(e2), namespace: e2, log: $r.log, extend: () => {
    } }, t3 = (...n) => {
      let { enabled: i, namespace: o, color: s, log: a2 } = r2;
      if (n.length !== 0 && Mr.push([o, ...n]), Mr.length > ou && Mr.shift(), $r.enabled(o) || i) {
        let l = n.map((c) => typeof c == "string" ? c : lu(c)), u = `+${Date.now() - fo}ms`;
        fo = Date.now(), globalThis.DEBUG_COLORS ? a2(St[s](W(o)), ...l, St[s](u)) : a2(o, ...l, u);
      }
    };
    return new Proxy(t3, { get: (n, i) => r2[i], set: (n, i, o) => r2[i] = o });
  };
  var lu = function(e2, r2 = 2) {
    let t3 = new Set;
    return JSON.stringify(e2, (n, i) => {
      if (typeof i == "object" && i !== null) {
        if (t3.has(i))
          return "[Circular *]";
        t3.add(i);
      } else if (typeof i == "bigint")
        return i.toString();
      return i;
    }, r2);
  };
  var go = function(e2 = 7500) {
    let r2 = Mr.map(([t3, ...n]) => `${t3} ${n.map((i) => typeof i == "string" ? i : JSON.stringify(i)).join(" ")}`).join(`
`);
    return r2.length < e2 ? r2 : r2.slice(-e2);
  };
  var ho = function() {
    Mr.length = 0;
  };
  var Fn = function() {
    let e2 = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    if (!(e2 && yo.default.existsSync(e2)) && process.arch === "ia32")
      throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
  };
  var It = function(e2, r2) {
    let t3 = r2 === "url";
    return e2.includes("windows") ? t3 ? "query_engine.dll.node" : `query_engine-${e2}.dll.node` : e2.includes("darwin") ? t3 ? `${At}.dylib.node` : `${At}-${e2}.dylib.node` : t3 ? `${At}.so.node` : `${At}-${e2}.so.node`;
  };
  var fe = function(e2) {
    return Object.assign(e2, { optional: () => cu(e2), and: (r2) => B(e2, r2), or: (r2) => pu(e2, r2), select: (r2) => r2 === undefined ? Eo(e2) : Eo(r2, e2) });
  };
  var cu = function(e2) {
    return fe({ [ke]: () => ({ match: (r2) => {
      let t3 = {}, n = (i, o) => {
        t3[i] = o;
      };
      return r2 === undefined ? (Ve(e2).forEach((i) => n(i, undefined)), { matched: true, selections: t3 }) : { matched: we(e2, r2, n), selections: t3 };
    }, getSelectionKeys: () => Ve(e2), matcherType: "optional" }) });
  };
  var B = function(...e2) {
    return fe({ [ke]: () => ({ match: (r2) => {
      let t3 = {}, n = (i, o) => {
        t3[i] = o;
      };
      return { matched: e2.every((i) => we(i, r2, n)), selections: t3 };
    }, getSelectionKeys: () => qr(e2, Ve), matcherType: "and" }) });
  };
  var pu = function(...e2) {
    return fe({ [ke]: () => ({ match: (r2) => {
      let t3 = {}, n = (i, o) => {
        t3[i] = o;
      };
      return qr(e2, Ve).forEach((i) => n(i, undefined)), { matched: e2.some((i) => we(i, r2, n)), selections: t3 };
    }, getSelectionKeys: () => qr(e2, Ve), matcherType: "or" }) });
  };
  var k = function(e2) {
    return { [ke]: () => ({ match: (r2) => ({ matched: !!e2(r2) }) }) };
  };
  var Eo = function(...e2) {
    let r2 = typeof e2[0] == "string" ? e2[0] : undefined, t3 = e2.length === 2 ? e2[1] : typeof e2[0] == "string" ? undefined : e2[0];
    return fe({ [ke]: () => ({ match: (n) => {
      let i = { [r2 ?? kt]: n };
      return { matched: t3 === undefined || we(t3, n, (o, s) => {
        i[o] = s;
      }), selections: i };
    }, getSelectionKeys: () => [r2 ?? kt].concat(t3 === undefined ? [] : Ve(t3)) }) });
  };
  var Ee = function(e2) {
    return typeof e2 == "number";
  };
  var Xe = function(e2) {
    return typeof e2 == "string";
  };
  var qe = function(e2) {
    return typeof e2 == "bigint";
  };
  var mr = function(e2) {
    return new Bn(e2, qn);
  };
  var Dt = function(e2, ...r2) {
    du.warn() && console.warn(`${mu.warn} ${e2}`, ...r2);
  };
  async function vo() {
    let e2 = Nt.default.platform(), r2 = process.arch;
    if (e2 === "freebsd") {
      let s = await Ot("freebsd-version");
      if (s && s.trim().length > 0) {
        let l = /^(\d+)\.?/.exec(s);
        if (l)
          return { platform: "freebsd", targetDistro: `freebsd${l[1]}`, arch: r2 };
      }
    }
    if (e2 !== "linux")
      return { platform: e2, arch: r2 };
    let t3 = await yu(), n = await Cu(), i = bu({ arch: r2, archFromUname: n, familyDistro: t3.familyDistro }), { libssl: o } = await wu(i);
    return { platform: "linux", libssl: o, arch: r2, archFromUname: n, ...t3 };
  }
  var hu = function(e2) {
    let r2 = /^ID="?([^"\n]*)"?$/im, t3 = /^ID_LIKE="?([^"\n]*)"?$/im, n = r2.exec(e2), i = n && n[1] && n[1].toLowerCase() || "", o = t3.exec(e2), s = o && o[1] && o[1].toLowerCase() || "", a2 = mr({ id: i, idLike: s }).with({ id: "alpine" }, ({ id: l }) => ({ targetDistro: "musl", familyDistro: l, originalDistro: l })).with({ id: "raspbian" }, ({ id: l }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l })).with({ id: "nixos" }, ({ id: l }) => ({ targetDistro: "nixos", originalDistro: l, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).when(({ idLike: l }) => l.includes("debian") || l.includes("ubuntu"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).when(({ idLike: l }) => i === "arch" || l.includes("arch"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l })).when(({ idLike: l }) => l.includes("centos") || l.includes("fedora") || l.includes("rhel") || l.includes("suse"), ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).otherwise(({ id: l }) => ({ targetDistro: undefined, familyDistro: undefined, originalDistro: l }));
    return te(`Found distro info:
${JSON.stringify(a2, null, 2)}`), a2;
  };
  async function yu() {
    let e2 = "/etc/os-release";
    try {
      let r2 = await Vn.default.readFile(e2, { encoding: "utf-8" });
      return hu(r2);
    } catch {
      return { targetDistro: undefined, familyDistro: undefined, originalDistro: undefined };
    }
  }
  var Eu = function(e2) {
    let r2 = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e2);
    if (r2) {
      let t3 = `${r2[1]}.x`;
      return To(t3);
    }
  };
  var bo = function(e2) {
    let r2 = /libssl\.so\.(\d)(\.\d)?/.exec(e2);
    if (r2) {
      let t3 = `${r2[1]}${r2[2] ?? ".0"}.x`;
      return To(t3);
    }
  };
  var To = function(e2) {
    let r2 = (() => {
      if (Ro(e2))
        return e2;
      let t3 = e2.split(".");
      return t3[1] = "0", t3.join(".");
    })();
    if (gu.includes(r2))
      return r2;
  };
  var bu = function(e2) {
    return mr(e2).with({ familyDistro: "musl" }, () => (te('Trying platform-specific paths for "alpine"'), ["/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: r2 }) => (te('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${r2}-linux-gnu`, `/lib/${r2}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (te('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: r2, arch: t3, archFromUname: n }) => (te(`Don't know any platform-specific paths for "${r2}" on ${t3} (${n})`), []));
  };
  async function wu(e2) {
    let r2 = 'grep -v "libssl.so.0"', t3 = await wo(e2);
    if (t3) {
      te(`Found libssl.so file using platform-specific paths: ${t3}`);
      let o = bo(t3);
      if (te(`The parsed libssl version is: ${o}`), o)
        return { libssl: o, strategy: "libssl-specific-path" };
    }
    te('Falling back to "ldconfig" and other generic paths');
    let n = await Ot(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${r2}`);
    if (n || (n = await wo(["/lib64", "/usr/lib64", "/lib"])), n) {
      te(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);
      let o = bo(n);
      if (te(`The parsed libssl version is: ${o}`), o)
        return { libssl: o, strategy: "ldconfig" };
    }
    let i = await Ot("openssl version -v");
    if (i) {
      te(`Found openssl binary with version: ${i}`);
      let o = Eu(i);
      if (te(`The parsed openssl version is: ${o}`), o)
        return { libssl: o, strategy: "openssl-binary" };
    }
    return te("Couldn't find any version of libssl or OpenSSL in the system"), {};
  }
  async function wo(e2) {
    for (let r2 of e2) {
      let t3 = await xu(r2);
      if (t3)
        return t3;
    }
  }
  async function xu(e2) {
    try {
      return (await Vn.default.readdir(e2)).find((t3) => t3.startsWith("libssl.so.") && !t3.startsWith("libssl.so.0"));
    } catch (r2) {
      if (r2.code === "ENOENT")
        return;
      throw r2;
    }
  }
  async function rr() {
    let { binaryTarget: e2 } = await Co();
    return e2;
  }
  var Pu = function(e2) {
    return e2.binaryTarget !== undefined;
  };
  async function jn() {
    let { memoized: e2, ...r2 } = await Co();
    return r2;
  }
  async function Co() {
    if (Pu(Lt))
      return Promise.resolve({ ...Lt, memoized: true });
    let e2 = await vo(), r2 = vu(e2);
    return Lt = { ...e2, binaryTarget: r2 }, { ...Lt, memoized: false };
  }
  var vu = function(e2) {
    let { platform: r2, arch: t3, archFromUname: n, libssl: i, targetDistro: o, familyDistro: s, originalDistro: a2 } = e2;
    r2 === "linux" && !["x64", "arm64"].includes(t3) && Dt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures. If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);
    let l = "1.1.x";
    if (r2 === "linux" && i === undefined) {
      let c = mr({ familyDistro: s }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
      Dt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".
${c}`);
    }
    let u = "debian";
    if (r2 === "linux" && o === undefined && te(`Distro is "${a2}". Falling back to Prisma engines built for "${u}".`), r2 === "darwin" && t3 === "arm64")
      return "darwin-arm64";
    if (r2 === "darwin")
      return "darwin";
    if (r2 === "win32")
      return "windows";
    if (r2 === "freebsd")
      return o;
    if (r2 === "openbsd")
      return "openbsd";
    if (r2 === "netbsd")
      return "netbsd";
    if (r2 === "linux" && o === "nixos")
      return "linux-nixos";
    if (r2 === "linux" && t3 === "arm64")
      return `${o === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i || l}`;
    if (r2 === "linux" && t3 === "arm")
      return `linux-arm-openssl-${i || l}`;
    if (r2 === "linux" && o === "musl") {
      let c = "linux-musl";
      return !i || Ro(i) ? c : `${c}-openssl-${i}`;
    }
    return r2 === "linux" && o && i ? `${o}-openssl-${i}` : (r2 !== "linux" && Dt(`Prisma detected unknown OS "${r2}" and may not work as expected. Defaulting to "linux".`), i ? `${u}-openssl-${i}` : o ? `${o}-openssl-${l}` : `${u}-openssl-${l}`);
  };
  async function Tu(e2) {
    try {
      return await e2();
    } catch {
      return;
    }
  }
  var Ot = function(e2) {
    return Tu(async () => {
      let r2 = await fu(e2);
      return te(`Command "${e2}" successfully returned "${r2.stdout}"`), r2.stdout;
    });
  };
  async function Cu() {
    return typeof Nt.default.machine == "function" ? Nt.default.machine() : (await Ot("uname -m"))?.trim();
  }
  var Ro = function(e2) {
    return e2.startsWith("1.");
  };
  var Kn = function(e2) {
    return (0, $o.default)(e2, e2, { fallback: ee });
  };
  var jo = function(e2) {
    let r2 = e2.ignoreProcessEnv ? {} : process.env, t3 = (n) => n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o, s) {
      let a2 = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);
      if (!a2)
        return o;
      let l = a2[1], u, c;
      if (l === "\\")
        c = a2[0], u = c.replace("\\$", "$");
      else {
        let p = a2[2];
        c = a2[0].substring(l.length), u = Object.hasOwnProperty.call(r2, p) ? r2[p] : e2.parsed[p] || "", u = t3(u);
      }
      return o.replace(c, u);
    }, n) ?? n;
    for (let n in e2.parsed) {
      let i = Object.hasOwnProperty.call(r2, n) ? r2[n] : e2.parsed[n];
      e2.parsed[n] = t3(i);
    }
    for (let n in e2.parsed)
      r2[n] = e2.parsed[n];
    return e2;
  };
  var jr = function({ rootEnvPath: e2, schemaEnvPath: r2 }, t3 = { conflictCheck: "none" }) {
    let n = Uo(e2);
    t3.conflictCheck !== "none" && qu(n, r2, t3.conflictCheck);
    let i = null;
    return Qo(n?.path, r2) || (i = Uo(r2)), !n && !i && Yn("No Environment variables loaded"), i?.dotenvResult.error ? console.error(ce(W("Schema Env Error: ")) + i.dotenvResult.error) : { message: [n?.message, i?.message].filter(Boolean).join(`
`), parsed: { ...n?.dotenvResult?.parsed, ...i?.dotenvResult?.parsed } };
  };
  var qu = function(e2, r2, t3) {
    let n = e2?.dotenvResult.parsed, i = !Qo(e2?.path, r2);
    if (n && r2 && i && qt.default.existsSync(r2)) {
      let o = Zn.default.parse(qt.default.readFileSync(r2)), s = [];
      for (let a2 in o)
        n[a2] === o[a2] && s.push(a2);
      if (s.length > 0) {
        let a2 = gr.default.relative(process.cwd(), e2.path), l = gr.default.relative(process.cwd(), r2);
        if (t3 === "error") {
          let u = `There is a conflict between env var${s.length > 1 ? "s" : ""} in ${ee(a2)} and ${ee(l)}
Conflicting env vars:
${s.map((c) => `  ${W(c)}`).join(`
`)}

We suggest to move the contents of ${ee(l)} to ${ee(a2)} to consolidate your env vars.
`;
          throw new Error(u);
        } else if (t3 === "warn") {
          let u = `Conflict for env var${s.length > 1 ? "s" : ""} ${s.map((c) => W(c)).join(", ")} in ${ee(a2)} and ${ee(l)}
Env vars from ${ee(l)} overwrite the ones from ${ee(a2)}
      `;
          console.warn(`${de("warn(prisma)")} ${u}`);
        }
      }
    }
  };
  var Uo = function(e2) {
    if (Bu(e2)) {
      Yn(`Environment variables loaded from ${e2}`);
      let r2 = Zn.default.config({ path: e2, debug: process.env.DOTENV_CONFIG_DEBUG ? true : undefined });
      return { dotenvResult: jo(r2), message: Ie(`Environment variables loaded from ${gr.default.relative(process.cwd(), e2)}`), path: e2 };
    } else
      Yn(`Environment variables not found at ${e2}`);
    return null;
  };
  var Qo = function(e2, r2) {
    return e2 && r2 && gr.default.resolve(e2) === gr.default.resolve(r2);
  };
  var Bu = function(e2) {
    return !!(e2 && qt.default.existsSync(e2));
  };
  var Ur = function(e2) {
    let r2 = Vu();
    return r2 || (e2?.config.engineType === "library" ? "library" : e2?.config.engineType === "binary" ? "binary" : Go);
  };
  var Vu = function() {
    let e2 = process.env.PRISMA_CLIENT_ENGINE_TYPE;
    return e2 === "library" ? "library" : e2 === "binary" ? "binary" : undefined;
  };
  var zo = function() {
    return M.default.join(__dirname, "../");
  };
  var ti = function(e2) {
    if (process.platform === "win32")
      return;
    let r2 = ri.default.statSync(e2), t3 = r2.mode | 64 | 8 | 1;
    if (r2.mode === t3) {
      Yo(`Execution permissions of ${e2} are fine`);
      return;
    }
    let n = t3.toString(8).slice(-3);
    Yo(`Have to call chmodPlusX on ${e2}`), ri.default.chmodSync(e2, n);
  };
  var ni = function(e2) {
    let r2 = e2.e, t3 = (a2) => `Prisma cannot find the required \`${a2}\` system library in your system`, n = r2.message.includes("cannot open shared object file"), i = `Please refer to the documentation about Prisma's system requirements: ${Kn("https://pris.ly/d/system-requirements")}`, o = `Unable to require(\`${Ie(e2.id)}\`).`, s = mr({ message: r2.message, code: r2.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a2 }) => n && a2.includes("libz"), () => `${t3("libz")}. Please install it and try again.`).when(({ message: a2 }) => n && a2.includes("libgcc_s"), () => `${t3("libgcc_s")}. Please install it and try again.`).when(({ message: a2 }) => n && a2.includes("libssl"), () => {
      let a2 = e2.platformInfo.libssl ? `openssl-${e2.platformInfo.libssl}` : "openssl";
      return `${t3("libssl")}. Please install ${a2} and try again.`;
    }).when(({ message: a2 }) => a2.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({ message: a2 }) => e2.platformInfo.platform === "linux" && a2.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e2.platformInfo.originalDistro} on (${e2.platformInfo.archFromUname}) which uses the \`${e2.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i}`);
    return `${o}
${s}

Details: ${r2.message}`;
  };
  var ii = function(e2) {
    return Qr.default.sep === Qr.default.posix.sep ? e2 : e2.split(Qr.default.sep).join(Qr.default.posix.sep);
  };
  var ai = function(e2) {
    return String(new si(e2));
  };
  var Ju = function(e2) {
    let r2;
    if (e2.length > 0) {
      let t3 = e2.find((n) => n.fromEnvVar !== null);
      t3 ? r2 = `env("${t3.fromEnvVar}")` : r2 = e2.map((n) => n.native ? "native" : n.value);
    } else
      r2 = undefined;
    return r2;
  };
  var Hu = function(e2) {
    let r2 = Object.keys(e2).reduce((t3, n) => Math.max(t3, n.length), 0);
    return Object.entries(e2).map(([t3, n]) => `${t3.padEnd(r2)} = ${Wu(n)}`).join(`
`);
  };
  var Wu = function(e2) {
    return JSON.parse(JSON.stringify(e2, (r2, t3) => Array.isArray(t3) ? `[${t3.map((n) => JSON.stringify(n)).join(", ")}]` : JSON.stringify(t3)));
  };
  var Ku = function(...e2) {
    console.log(...e2);
  };
  var li = function(e2, ...r2) {
    es.warn() && console.warn(`${Gr.warn} ${e2}`, ...r2);
  };
  var zu = function(e2, ...r2) {
    console.info(`${Gr.info} ${e2}`, ...r2);
  };
  var Yu = function(e2, ...r2) {
    console.error(`${Gr.error} ${e2}`, ...r2);
  };
  var Zu = function(e2, ...r2) {
    console.log(`${Gr.query} ${e2}`, ...r2);
  };
  var Vt = function(e2, r2) {
    if (!e2)
      throw new Error(`${r2}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`);
  };
  var tr = function(e2, r2) {
    throw new Error(r2);
  };
  var ci = function(e2, r2) {
    return Object.prototype.hasOwnProperty.call(e2, r2);
  };
  var hr = function(e2, r2) {
    let t3 = {};
    for (let n of Object.keys(e2))
      t3[n] = r2(e2[n], n);
    return t3;
  };
  var mi = function(e2, r2) {
    if (e2.length === 0)
      return;
    let t3 = e2[0];
    for (let n = 1;n < e2.length; n++)
      r2(t3, e2[n]) < 0 && (t3 = e2[n]);
    return t3;
  };
  var w = function(e2, r2) {
    Object.defineProperty(e2, "name", { value: r2, configurable: true });
  };
  var Wr = function(e2) {
    let r2;
    return { get() {
      return r2 || (r2 = { value: e2() }), r2.value;
    } };
  };
  var ss = function(e2, r2) {
    let t3 = Wr(() => ec(r2));
    Object.defineProperty(e2, "dmmf", { get: () => t3.get() });
  };
  var ec = function(e2) {
    return { datamodel: { models: di(e2.models), enums: di(e2.enums), types: di(e2.types) } };
  };
  var di = function(e2) {
    return Object.entries(e2).map(([r2, t3]) => ({ name: r2, ...t3 }));
  };
  var gi = function(e2, r2) {
    Object.defineProperty(e2, "name", { value: r2, configurable: true });
  };
  var Xr = function(e2) {
    return { ok: false, error: e2, map() {
      return Xr(e2);
    }, flatMap() {
      return Xr(e2);
    } };
  };
  var nr = function(e2, r2) {
    return async (...t3) => {
      try {
        return await r2(...t3);
      } catch (n) {
        let i = e2.registerNewError(n);
        return Xr({ kind: "GenericJs", id: i });
      }
    };
  };
  var tc = function(e2, r2) {
    return (...t3) => {
      try {
        return r2(...t3);
      } catch (n) {
        let i = e2.registerNewError(n);
        return Xr({ kind: "GenericJs", id: i });
      }
    };
  };
  var as = function(e2, r2 = ",", t3 = "", n = "") {
    if (e2.length === 0)
      throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
    return new oe([t3, ...Array(e2.length - 1).fill(r2), n], e2);
  };
  var Ei = function(e2) {
    return new oe([e2], []);
  };
  var bi = function(e2, ...r2) {
    return new oe(e2, r2);
  };
  var et = function(e2) {
    return { getKeys() {
      return Object.keys(e2);
    }, getPropertyValue(r2) {
      return e2[r2];
    } };
  };
  var ne = function(e2, r2) {
    return { getKeys() {
      return [e2];
    }, getPropertyValue() {
      return r2();
    } };
  };
  var ir = function(e2) {
    let r2 = new xe;
    return { getKeys() {
      return e2.getKeys();
    }, getPropertyValue(t3) {
      return r2.getOrCreate(t3, () => e2.getPropertyValue(t3));
    }, getPropertyDescriptor(t3) {
      return e2.getPropertyDescriptor?.(t3);
    } };
  };
  var Ht = function(e2) {
    let r2 = new Set(e2);
    return { getOwnPropertyDescriptor: () => Jt, has: (t3, n) => r2.has(n), set: (t3, n, i) => r2.add(n) && Reflect.set(t3, n, i), ownKeys: () => [...r2] };
  };
  var Pe = function(e2, r2) {
    let t3 = nc(r2), n = new Set, i = new Proxy(e2, { get(o, s) {
      if (n.has(s))
        return o[s];
      let a2 = t3.get(s);
      return a2 ? a2.getPropertyValue(s) : o[s];
    }, has(o, s) {
      if (n.has(s))
        return true;
      let a2 = t3.get(s);
      return a2 ? a2.has?.(s) ?? true : Reflect.has(o, s);
    }, ownKeys(o) {
      let s = cs(Reflect.ownKeys(o), t3), a2 = cs(Array.from(t3.keys()), t3);
      return [...new Set([...s, ...a2, ...n])];
    }, set(o, s, a2) {
      return t3.get(s)?.getPropertyDescriptor?.(s)?.writable === false ? false : (n.add(s), Reflect.set(o, s, a2));
    }, getOwnPropertyDescriptor(o, s) {
      let a2 = Reflect.getOwnPropertyDescriptor(o, s);
      if (a2 && !a2.configurable)
        return a2;
      let l = t3.get(s);
      return l ? l.getPropertyDescriptor ? { ...Jt, ...l?.getPropertyDescriptor(s) } : Jt : a2;
    }, defineProperty(o, s, a2) {
      return n.add(s), Reflect.defineProperty(o, s, a2);
    } });
    return i[us] = function() {
      let o = { ...this };
      return delete o[us], o;
    }, i;
  };
  var nc = function(e2) {
    let r2 = new Map;
    for (let t3 of e2) {
      let n = t3.getKeys();
      for (let i of n)
        r2.set(i, t3);
    }
    return r2;
  };
  var cs = function(e2, r2) {
    return e2.filter((t3) => r2.get(t3)?.has?.(t3) ?? true);
  };
  var rt = function(e2) {
    return { getKeys() {
      return e2;
    }, has() {
      return false;
    }, getPropertyValue() {
    } };
  };
  var Er = function(e2, r2) {
    return { batch: e2, transaction: r2?.kind === "batch" ? { isolationLevel: r2.options.isolationLevel } : undefined };
  };
  var ps = function(e2) {
    return e2.substring(0, 1).toLowerCase() + e2.substring(1);
  };
  var wr = function(e2) {
    return e2 instanceof Date || Object.prototype.toString.call(e2) === "[object Date]";
  };
  var Wt = function(e2) {
    return e2.toString() !== "Invalid Date";
  };
  var z2 = function(e2) {
    var r2, t3, n, i = e2.length - 1, o = "", s = e2[0];
    if (i > 0) {
      for (o += s, r2 = 1;r2 < i; r2++)
        n = e2[r2] + "", t3 = b - n.length, t3 && (o += Ue(t3)), o += n;
      s = e2[r2], n = s + "", t3 = b - n.length, t3 && (o += Ue(t3));
    } else if (s === 0)
      return "0";
    for (;s % 10 === 0; )
      s /= 10;
    return o + s;
  };
  var se = function(e2, r2, t3) {
    if (e2 !== ~~e2 || e2 < r2 || e2 > t3)
      throw Error(Ge + e2);
  };
  var tt = function(e2, r2, t3, n) {
    var i, o, s, a2;
    for (o = e2[0];o >= 10; o /= 10)
      --r2;
    return --r2 < 0 ? (r2 += b, i = 0) : (i = Math.ceil((r2 + 1) / b), r2 %= b), o = Q(10, b - r2), a2 = e2[i] % o | 0, n == null ? r2 < 3 ? (r2 == 0 ? a2 = a2 / 100 | 0 : r2 == 1 && (a2 = a2 / 10 | 0), s = t3 < 4 && a2 == 99999 || t3 > 3 && a2 == 49999 || a2 == 50000 || a2 == 0) : s = (t3 < 4 && a2 + 1 == o || t3 > 3 && a2 + 1 == o / 2) && (e2[i + 1] / o / 100 | 0) == Q(10, r2 - 2) - 1 || (a2 == o / 2 || a2 == 0) && (e2[i + 1] / o / 100 | 0) == 0 : r2 < 4 ? (r2 == 0 ? a2 = a2 / 1000 | 0 : r2 == 1 ? a2 = a2 / 100 | 0 : r2 == 2 && (a2 = a2 / 10 | 0), s = (n || t3 < 4) && a2 == 9999 || !n && t3 > 3 && a2 == 4999) : s = ((n || t3 < 4) && a2 + 1 == o || !n && t3 > 3 && a2 + 1 == o / 2) && (e2[i + 1] / o / 1000 | 0) == Q(10, r2 - 3) - 1, s;
  };
  var Kt = function(e2, r2, t3) {
    for (var n, i = [0], o, s = 0, a2 = e2.length;s < a2; ) {
      for (o = i.length;o--; )
        i[o] *= r2;
      for (i[0] += wi.indexOf(e2.charAt(s++)), n = 0;n < i.length; n++)
        i[n] > t3 - 1 && (i[n + 1] === undefined && (i[n + 1] = 0), i[n + 1] += i[n] / t3 | 0, i[n] %= t3);
    }
    return i.reverse();
  };
  var uc = function(e2, r2) {
    var t3, n, i;
    if (r2.isZero())
      return r2;
    n = r2.d.length, n < 32 ? (t3 = Math.ceil(n / 3), i = (1 / rn(4, t3)).toString()) : (t3 = 16, i = "2.3283064365386962890625e-10"), e2.precision += t3, r2 = Pr(e2, 1, r2.times(i), new e2(1));
    for (var o = t3;o--; ) {
      var s = r2.times(r2);
      r2 = s.times(s).minus(s).times(8).plus(1);
    }
    return e2.precision -= t3, r2;
  };
  var y = function(e2, r2, t3, n) {
    var i, o, s, a2, l, u, c, p, m, f = e2.constructor;
    e:
      if (r2 != null) {
        if (p = e2.d, !p)
          return e2;
        for (i = 1, a2 = p[0];a2 >= 10; a2 /= 10)
          i++;
        if (o = r2 - i, o < 0)
          o += b, s = r2, c = p[m = 0], l = c / Q(10, i - s - 1) % 10 | 0;
        else if (m = Math.ceil((o + 1) / b), a2 = p.length, m >= a2)
          if (n) {
            for (;a2++ <= m; )
              p.push(0);
            c = l = 0, i = 1, o %= b, s = o - b + 1;
          } else
            break e;
        else {
          for (c = a2 = p[m], i = 1;a2 >= 10; a2 /= 10)
            i++;
          o %= b, s = o - b + i, l = s < 0 ? 0 : c / Q(10, i - s - 1) % 10 | 0;
        }
        if (n = n || r2 < 0 || p[m + 1] !== undefined || (s < 0 ? c : c % Q(10, i - s - 1)), u = t3 < 4 ? (l || n) && (t3 == 0 || t3 == (e2.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (t3 == 4 || n || t3 == 6 && (o > 0 ? s > 0 ? c / Q(10, i - s) : 0 : p[m - 1]) % 10 & 1 || t3 == (e2.s < 0 ? 8 : 7)), r2 < 1 || !p[0])
          return p.length = 0, u ? (r2 -= e2.e + 1, p[0] = Q(10, (b - r2 % b) % b), e2.e = -r2 || 0) : p[0] = e2.e = 0, e2;
        if (o == 0 ? (p.length = m, a2 = 1, m--) : (p.length = m + 1, a2 = Q(10, b - o), p[m] = s > 0 ? (c / Q(10, i - s) % Q(10, s) | 0) * a2 : 0), u)
          for (;; )
            if (m == 0) {
              for (o = 1, s = p[0];s >= 10; s /= 10)
                o++;
              for (s = p[0] += a2, a2 = 1;s >= 10; s /= 10)
                a2++;
              o != a2 && (e2.e++, p[0] == he && (p[0] = 1));
              break;
            } else {
              if (p[m] += a2, p[m] != he)
                break;
              p[m--] = 0, a2 = 1;
            }
        for (o = p.length;p[--o] === 0; )
          p.pop();
      }
    return x && (e2.e > f.maxE ? (e2.d = null, e2.e = NaN) : e2.e < f.minE && (e2.e = 0, e2.d = [0])), e2;
  };
  var ve = function(e2, r2, t3) {
    if (!e2.isFinite())
      return vs(e2);
    var n, i = e2.e, o = z2(e2.d), s = o.length;
    return r2 ? (t3 && (n = t3 - s) > 0 ? o = o.charAt(0) + "." + o.slice(1) + Ue(n) : s > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (e2.e < 0 ? "e" : "e+") + e2.e) : i < 0 ? (o = "0." + Ue(-i - 1) + o, t3 && (n = t3 - s) > 0 && (o += Ue(n))) : i >= s ? (o += Ue(i + 1 - s), t3 && (n = t3 - i - 1) > 0 && (o = o + "." + Ue(n))) : ((n = i + 1) < s && (o = o.slice(0, n) + "." + o.slice(n)), t3 && (n = t3 - s) > 0 && (i + 1 === s && (o += "."), o += Ue(n))), o;
  };
  var en = function(e2, r2) {
    var t3 = e2[0];
    for (r2 *= b;t3 >= 10; t3 /= 10)
      r2++;
    return r2;
  };
  var Zt = function(e2, r2, t3) {
    if (r2 > lc)
      throw x = true, t3 && (e2.precision = t3), Error(hs);
    return y(new e2(zt), r2, 1, true);
  };
  var ge = function(e2, r2, t3) {
    if (r2 > Pi)
      throw Error(hs);
    return y(new e2(Yt), r2, t3, true);
  };
  var ws = function(e2) {
    var r2 = e2.length - 1, t3 = r2 * b + 1;
    if (r2 = e2[r2], r2) {
      for (;r2 % 10 == 0; r2 /= 10)
        t3--;
      for (r2 = e2[0];r2 >= 10; r2 /= 10)
        t3++;
    }
    return t3;
  };
  var Ue = function(e2) {
    for (var r2 = "";e2--; )
      r2 += "0";
    return r2;
  };
  var xs = function(e2, r2, t3, n) {
    var i, o = new e2(1), s = Math.ceil(n / b + 4);
    for (x = false;; ) {
      if (t3 % 2 && (o = o.times(r2), ds(o.d, s) && (i = true)), t3 = re(t3 / 2), t3 === 0) {
        t3 = o.d.length - 1, i && o.d[t3] === 0 && ++o.d[t3];
        break;
      }
      r2 = r2.times(r2), ds(r2.d, s);
    }
    return x = true, o;
  };
  var ms = function(e2) {
    return e2.d[e2.d.length - 1] & 1;
  };
  var Ps = function(e2, r2, t3) {
    for (var n, i = new e2(r2[0]), o = 0;++o < r2.length; )
      if (n = new e2(r2[o]), n.s)
        i[t3](n) && (i = n);
      else {
        i = n;
        break;
      }
    return i;
  };
  var vi = function(e2, r2) {
    var t3, n, i, o, s, a2, l, u = 0, c = 0, p = 0, m = e2.constructor, f = m.rounding, g = m.precision;
    if (!e2.d || !e2.d[0] || e2.e > 17)
      return new m(e2.d ? e2.d[0] ? e2.s < 0 ? 0 : 1 / 0 : 1 : e2.s ? e2.s < 0 ? 0 : e2 : NaN);
    for (r2 == null ? (x = false, l = g) : l = r2, a2 = new m(0.03125);e2.e > -2; )
      e2 = e2.times(a2), p += 5;
    for (n = Math.log(Q(2, p)) / Math.LN10 * 2 + 5 | 0, l += n, t3 = o = s = new m(1), m.precision = l;; ) {
      if (o = y(o.times(e2), l, 1), t3 = t3.times(++c), a2 = s.plus(O(o, t3, l, 1)), z2(a2.d).slice(0, l) === z2(s.d).slice(0, l)) {
        for (i = p;i--; )
          s = y(s.times(s), l, 1);
        if (r2 == null)
          if (u < 3 && tt(s.d, l - n, f, u))
            m.precision = l += 10, t3 = o = a2 = new m(1), c = 0, u++;
          else
            return y(s, m.precision = g, f, x = true);
        else
          return m.precision = g, s;
      }
      s = a2;
    }
  };
  var Qe = function(e2, r2) {
    var t3, n, i, o, s, a2, l, u, c, p, m, f = 1, g = 10, h = e2, A = h.d, T = h.constructor, C = T.rounding, E = T.precision;
    if (h.s < 0 || !A || !A[0] || !h.e && A[0] == 1 && A.length == 1)
      return new T(A && !A[0] ? -1 / 0 : h.s != 1 ? NaN : A ? 0 : h);
    if (r2 == null ? (x = false, c = E) : c = r2, T.precision = c += g, t3 = z2(A), n = t3.charAt(0), Math.abs(o = h.e) < 1500000000000000) {
      for (;n < 7 && n != 1 || n == 1 && t3.charAt(1) > 3; )
        h = h.times(e2), t3 = z2(h.d), n = t3.charAt(0), f++;
      o = h.e, n > 1 ? (h = new T("0." + t3), o++) : h = new T(n + "." + t3.slice(1));
    } else
      return u = Zt(T, c + 2, E).times(o + ""), h = Qe(new T(n + "." + t3.slice(1)), c - g).plus(u), T.precision = E, r2 == null ? y(h, E, C, x = true) : h;
    for (p = h, l = s = h = O(h.minus(1), h.plus(1), c, 1), m = y(h.times(h), c, 1), i = 3;; ) {
      if (s = y(s.times(m), c, 1), u = l.plus(O(s, new T(i), c, 1)), z2(u.d).slice(0, c) === z2(l.d).slice(0, c))
        if (l = l.times(2), o !== 0 && (l = l.plus(Zt(T, c + 2, E).times(o + ""))), l = O(l, new T(f), c, 1), r2 == null)
          if (tt(l.d, c - g, C, a2))
            T.precision = c += g, u = s = h = O(p.minus(1), p.plus(1), c, 1), m = y(h.times(h), c, 1), i = a2 = 1;
          else
            return y(l, T.precision = E, C, x = true);
        else
          return T.precision = E, l;
      l = u, i += 2;
    }
  };
  var vs = function(e2) {
    return String(e2.s * e2.s / 0);
  };
  var Ti = function(e2, r2) {
    var t3, n, i;
    for ((t3 = r2.indexOf(".")) > -1 && (r2 = r2.replace(".", "")), (n = r2.search(/e/i)) > 0 ? (t3 < 0 && (t3 = n), t3 += +r2.slice(n + 1), r2 = r2.substring(0, n)) : t3 < 0 && (t3 = r2.length), n = 0;r2.charCodeAt(n) === 48; n++)
      ;
    for (i = r2.length;r2.charCodeAt(i - 1) === 48; --i)
      ;
    if (r2 = r2.slice(n, i), r2) {
      if (i -= n, e2.e = t3 = t3 - n - 1, e2.d = [], n = (t3 + 1) % b, t3 < 0 && (n += b), n < i) {
        for (n && e2.d.push(+r2.slice(0, n)), i -= b;n < i; )
          e2.d.push(+r2.slice(n, n += b));
        r2 = r2.slice(n), n = b - r2.length;
      } else
        n -= i;
      for (;n--; )
        r2 += "0";
      e2.d.push(+r2), x && (e2.e > e2.constructor.maxE ? (e2.d = null, e2.e = NaN) : e2.e < e2.constructor.minE && (e2.e = 0, e2.d = [0]));
    } else
      e2.e = 0, e2.d = [0];
    return e2;
  };
  var cc = function(e2, r2) {
    var t3, n, i, o, s, a2, l, u, c;
    if (r2.indexOf("_") > -1) {
      if (r2 = r2.replace(/(\d)_(?=\d)/g, "$1"), bs.test(r2))
        return Ti(e2, r2);
    } else if (r2 === "Infinity" || r2 === "NaN")
      return +r2 || (e2.s = NaN), e2.e = NaN, e2.d = null, e2;
    if (oc.test(r2))
      t3 = 16, r2 = r2.toLowerCase();
    else if (ic.test(r2))
      t3 = 2;
    else if (sc.test(r2))
      t3 = 8;
    else
      throw Error(Ge + r2);
    for (o = r2.search(/p/i), o > 0 ? (l = +r2.slice(o + 1), r2 = r2.substring(2, o)) : r2 = r2.slice(2), o = r2.indexOf("."), s = o >= 0, n = e2.constructor, s && (r2 = r2.replace(".", ""), a2 = r2.length, o = a2 - o, i = xs(n, new n(t3), o, o * 2)), u = Kt(r2, t3, he), c = u.length - 1, o = c;u[o] === 0; --o)
      u.pop();
    return o < 0 ? new n(e2.s * 0) : (e2.e = en(u, c), e2.d = u, x = false, s && (e2 = O(e2, i, a2 * 4)), l && (e2 = e2.times(Math.abs(l) < 54 ? Q(2, l) : or.pow(2, l))), x = true, e2);
  };
  var pc = function(e2, r2) {
    var t3, n = r2.d.length;
    if (n < 3)
      return r2.isZero() ? r2 : Pr(e2, 2, r2, r2);
    t3 = 1.4 * Math.sqrt(n), t3 = t3 > 16 ? 16 : t3 | 0, r2 = r2.times(1 / rn(5, t3)), r2 = Pr(e2, 2, r2, r2);
    for (var i, o = new e2(5), s = new e2(16), a2 = new e2(20);t3--; )
      i = r2.times(r2), r2 = r2.times(o.plus(i.times(s.times(i).minus(a2))));
    return r2;
  };
  var Pr = function(e2, r2, t3, n, i) {
    var o, s, a2, l, u = 1, c = e2.precision, p = Math.ceil(c / b);
    for (x = false, l = t3.times(t3), a2 = new e2(n);; ) {
      if (s = O(a2.times(l), new e2(r2++ * r2++), c, 1), a2 = i ? n.plus(s) : n.minus(s), n = O(s.times(l), new e2(r2++ * r2++), c, 1), s = a2.plus(n), s.d[p] !== undefined) {
        for (o = p;s.d[o] === a2.d[o] && o--; )
          ;
        if (o == -1)
          break;
      }
      o = a2, a2 = n, n = s, s = o, u++;
    }
    return x = true, s.d.length = p + 1, s;
  };
  var rn = function(e2, r2) {
    for (var t3 = e2;--r2; )
      t3 *= e2;
    return t3;
  };
  var Ts = function(e2, r2) {
    var t3, n = r2.s < 0, i = ge(e2, e2.precision, 1), o = i.times(0.5);
    if (r2 = r2.abs(), r2.lte(o))
      return Oe = n ? 4 : 1, r2;
    if (t3 = r2.divToInt(i), t3.isZero())
      Oe = n ? 3 : 2;
    else {
      if (r2 = r2.minus(t3.times(i)), r2.lte(o))
        return Oe = ms(t3) ? n ? 2 : 3 : n ? 4 : 1, r2;
      Oe = ms(t3) ? n ? 1 : 4 : n ? 3 : 2;
    }
    return r2.minus(i).abs();
  };
  var Ci = function(e2, r2, t3, n) {
    var i, o, s, a2, l, u, c, p, m, f = e2.constructor, g = t3 !== undefined;
    if (g ? (se(t3, 1, Je), n === undefined ? n = f.rounding : se(n, 0, 8)) : (t3 = f.precision, n = f.rounding), !e2.isFinite())
      c = vs(e2);
    else {
      for (c = ve(e2), s = c.indexOf("."), g ? (i = 2, r2 == 16 ? t3 = t3 * 4 - 3 : r2 == 8 && (t3 = t3 * 3 - 2)) : i = r2, s >= 0 && (c = c.replace(".", ""), m = new f(1), m.e = c.length - s, m.d = Kt(ve(m), 10, i), m.e = m.d.length), p = Kt(c, 10, i), o = l = p.length;p[--l] == 0; )
        p.pop();
      if (!p[0])
        c = g ? "0p+0" : "0";
      else {
        if (s < 0 ? o-- : (e2 = new f(e2), e2.d = p, e2.e = o, e2 = O(e2, m, t3, n, 0, i), p = e2.d, o = e2.e, u = gs), s = p[t3], a2 = i / 2, u = u || p[t3 + 1] !== undefined, u = n < 4 ? (s !== undefined || u) && (n === 0 || n === (e2.s < 0 ? 3 : 2)) : s > a2 || s === a2 && (n === 4 || u || n === 6 && p[t3 - 1] & 1 || n === (e2.s < 0 ? 8 : 7)), p.length = t3, u)
          for (;++p[--t3] > i - 1; )
            p[t3] = 0, t3 || (++o, p.unshift(1));
        for (l = p.length;!p[l - 1]; --l)
          ;
        for (s = 0, c = "";s < l; s++)
          c += wi.charAt(p[s]);
        if (g) {
          if (l > 1)
            if (r2 == 16 || r2 == 8) {
              for (s = r2 == 16 ? 4 : 3, --l;l % s; l++)
                c += "0";
              for (p = Kt(c, i, r2), l = p.length;!p[l - 1]; --l)
                ;
              for (s = 1, c = "1.";s < l; s++)
                c += wi.charAt(p[s]);
            } else
              c = c.charAt(0) + "." + c.slice(1);
          c = c + (o < 0 ? "p" : "p+") + o;
        } else if (o < 0) {
          for (;++o; )
            c = "0" + c;
          c = "0." + c;
        } else if (++o > l)
          for (o -= l;o--; )
            c += "0";
        else
          o < l && (c = c.slice(0, o) + "." + c.slice(o));
      }
      c = (r2 == 16 ? "0x" : r2 == 2 ? "0b" : r2 == 8 ? "0o" : "") + c;
    }
    return e2.s < 0 ? "-" + c : c;
  };
  var ds = function(e2, r2) {
    if (e2.length > r2)
      return e2.length = r2, true;
  };
  var mc = function(e2) {
    return new this(e2).abs();
  };
  var dc = function(e2) {
    return new this(e2).acos();
  };
  var fc = function(e2) {
    return new this(e2).acosh();
  };
  var gc = function(e2, r2) {
    return new this(e2).plus(r2);
  };
  var hc = function(e2) {
    return new this(e2).asin();
  };
  var yc = function(e2) {
    return new this(e2).asinh();
  };
  var Ec = function(e2) {
    return new this(e2).atan();
  };
  var bc = function(e2) {
    return new this(e2).atanh();
  };
  var wc = function(e2, r2) {
    e2 = new this(e2), r2 = new this(r2);
    var t3, n = this.precision, i = this.rounding, o = n + 4;
    return !e2.s || !r2.s ? t3 = new this(NaN) : !e2.d && !r2.d ? (t3 = ge(this, o, 1).times(r2.s > 0 ? 0.25 : 0.75), t3.s = e2.s) : !r2.d || e2.isZero() ? (t3 = r2.s < 0 ? ge(this, n, i) : new this(0), t3.s = e2.s) : !e2.d || r2.isZero() ? (t3 = ge(this, o, 1).times(0.5), t3.s = e2.s) : r2.s < 0 ? (this.precision = o, this.rounding = 1, t3 = this.atan(O(e2, r2, o, 1)), r2 = ge(this, o, 1), this.precision = n, this.rounding = i, t3 = e2.s < 0 ? t3.minus(r2) : t3.plus(r2)) : t3 = this.atan(O(e2, r2, o, 1)), t3;
  };
  var xc = function(e2) {
    return new this(e2).cbrt();
  };
  var Pc = function(e2) {
    return y(e2 = new this(e2), e2.e + 1, 2);
  };
  var vc = function(e2, r2, t3) {
    return new this(e2).clamp(r2, t3);
  };
  var Tc = function(e2) {
    if (!e2 || typeof e2 != "object")
      throw Error(Xt + "Object expected");
    var r2, t3, n, i = e2.defaults === true, o = ["precision", 1, Je, "rounding", 0, 8, "toExpNeg", -xr, 0, "toExpPos", 0, xr, "maxE", 0, xr, "minE", -xr, 0, "modulo", 0, 9];
    for (r2 = 0;r2 < o.length; r2 += 3)
      if (t3 = o[r2], i && (this[t3] = xi[t3]), (n = e2[t3]) !== undefined)
        if (re(n) === n && n >= o[r2 + 1] && n <= o[r2 + 2])
          this[t3] = n;
        else
          throw Error(Ge + t3 + ": " + n);
    if (t3 = "crypto", i && (this[t3] = xi[t3]), (n = e2[t3]) !== undefined)
      if (n === true || n === false || n === 0 || n === 1)
        if (n)
          if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
            this[t3] = true;
          else
            throw Error(ys);
        else
          this[t3] = false;
      else
        throw Error(Ge + t3 + ": " + n);
    return this;
  };
  var Cc = function(e2) {
    return new this(e2).cos();
  };
  var Rc = function(e2) {
    return new this(e2).cosh();
  };
  var Cs = function(e2) {
    var r2, t3, n;
    function i(o) {
      var s, a2, l, u = this;
      if (!(u instanceof i))
        return new i(o);
      if (u.constructor = i, fs(o)) {
        u.s = o.s, x ? !o.d || o.e > i.maxE ? (u.e = NaN, u.d = null) : o.e < i.minE ? (u.e = 0, u.d = [0]) : (u.e = o.e, u.d = o.d.slice()) : (u.e = o.e, u.d = o.d ? o.d.slice() : o.d);
        return;
      }
      if (l = typeof o, l === "number") {
        if (o === 0) {
          u.s = 1 / o < 0 ? -1 : 1, u.e = 0, u.d = [0];
          return;
        }
        if (o < 0 ? (o = -o, u.s = -1) : u.s = 1, o === ~~o && o < 1e7) {
          for (s = 0, a2 = o;a2 >= 10; a2 /= 10)
            s++;
          x ? s > i.maxE ? (u.e = NaN, u.d = null) : s < i.minE ? (u.e = 0, u.d = [0]) : (u.e = s, u.d = [o]) : (u.e = s, u.d = [o]);
          return;
        } else if (o * 0 !== 0) {
          o || (u.s = NaN), u.e = NaN, u.d = null;
          return;
        }
        return Ti(u, o.toString());
      } else if (l !== "string")
        throw Error(Ge + o);
      return (a2 = o.charCodeAt(0)) === 45 ? (o = o.slice(1), u.s = -1) : (a2 === 43 && (o = o.slice(1)), u.s = 1), bs.test(o) ? Ti(u, o) : cc(u, o);
    }
    if (i.prototype = d, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = Tc, i.clone = Cs, i.isDecimal = fs, i.abs = mc, i.acos = dc, i.acosh = fc, i.add = gc, i.asin = hc, i.asinh = yc, i.atan = Ec, i.atanh = bc, i.atan2 = wc, i.cbrt = xc, i.ceil = Pc, i.clamp = vc, i.cos = Cc, i.cosh = Rc, i.div = Sc, i.exp = Ac, i.floor = Ic, i.hypot = _c, i.ln = kc, i.log = Dc, i.log10 = Nc, i.log2 = Lc, i.max = Oc, i.min = Fc, i.mod = Mc, i.mul = $c, i.pow = qc, i.random = Bc, i.round = Vc, i.sign = jc, i.sin = Uc, i.sinh = Qc, i.sqrt = Gc, i.sub = Jc, i.sum = Hc, i.tan = Wc, i.tanh = Kc, i.trunc = zc, e2 === undefined && (e2 = {}), e2 && e2.defaults !== true)
      for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], r2 = 0;r2 < n.length; )
        e2.hasOwnProperty(t3 = n[r2++]) || (e2[t3] = this[t3]);
    return i.config(e2), i;
  };
  var Sc = function(e2, r2) {
    return new this(e2).div(r2);
  };
  var Ac = function(e2) {
    return new this(e2).exp();
  };
  var Ic = function(e2) {
    return y(e2 = new this(e2), e2.e + 1, 3);
  };
  var _c = function() {
    var e2, r2, t3 = new this(0);
    for (x = false, e2 = 0;e2 < arguments.length; )
      if (r2 = new this(arguments[e2++]), r2.d)
        t3.d && (t3 = t3.plus(r2.times(r2)));
      else {
        if (r2.s)
          return x = true, new this(1 / 0);
        t3 = r2;
      }
    return x = true, t3.sqrt();
  };
  var fs = function(e2) {
    return e2 instanceof or || e2 && e2.toStringTag === Es || false;
  };
  var kc = function(e2) {
    return new this(e2).ln();
  };
  var Dc = function(e2, r2) {
    return new this(e2).log(r2);
  };
  var Lc = function(e2) {
    return new this(e2).log(2);
  };
  var Nc = function(e2) {
    return new this(e2).log(10);
  };
  var Oc = function() {
    return Ps(this, arguments, "lt");
  };
  var Fc = function() {
    return Ps(this, arguments, "gt");
  };
  var Mc = function(e2, r2) {
    return new this(e2).mod(r2);
  };
  var $c = function(e2, r2) {
    return new this(e2).mul(r2);
  };
  var qc = function(e2, r2) {
    return new this(e2).pow(r2);
  };
  var Bc = function(e2) {
    var r2, t3, n, i, o = 0, s = new this(1), a2 = [];
    if (e2 === undefined ? e2 = this.precision : se(e2, 1, Je), n = Math.ceil(e2 / b), this.crypto)
      if (crypto.getRandomValues)
        for (r2 = crypto.getRandomValues(new Uint32Array(n));o < n; )
          i = r2[o], i >= 4290000000 ? r2[o] = crypto.getRandomValues(new Uint32Array(1))[0] : a2[o++] = i % 1e7;
      else if (crypto.randomBytes) {
        for (r2 = crypto.randomBytes(n *= 4);o < n; )
          i = r2[o] + (r2[o + 1] << 8) + (r2[o + 2] << 16) + ((r2[o + 3] & 127) << 24), i >= 2140000000 ? crypto.randomBytes(4).copy(r2, o) : (a2.push(i % 1e7), o += 4);
        o = n / 4;
      } else
        throw Error(ys);
    else
      for (;o < n; )
        a2[o++] = Math.random() * 1e7 | 0;
    for (n = a2[--o], e2 %= b, n && e2 && (i = Q(10, b - e2), a2[o] = (n / i | 0) * i);a2[o] === 0; o--)
      a2.pop();
    if (o < 0)
      t3 = 0, a2 = [0];
    else {
      for (t3 = -1;a2[0] === 0; t3 -= b)
        a2.shift();
      for (n = 1, i = a2[0];i >= 10; i /= 10)
        n++;
      n < b && (t3 -= b - n);
    }
    return s.e = t3, s.d = a2, s;
  };
  var Vc = function(e2) {
    return y(e2 = new this(e2), e2.e + 1, this.rounding);
  };
  var jc = function(e2) {
    return e2 = new this(e2), e2.d ? e2.d[0] ? e2.s : 0 * e2.s : e2.s || NaN;
  };
  var Uc = function(e2) {
    return new this(e2).sin();
  };
  var Qc = function(e2) {
    return new this(e2).sinh();
  };
  var Gc = function(e2) {
    return new this(e2).sqrt();
  };
  var Jc = function(e2, r2) {
    return new this(e2).sub(r2);
  };
  var Hc = function() {
    var e2 = 0, r2 = arguments, t3 = new this(r2[e2]);
    for (x = false;t3.s && ++e2 < r2.length; )
      t3 = t3.plus(r2[e2]);
    return x = true, y(t3, this.precision, this.rounding);
  };
  var Wc = function(e2) {
    return new this(e2).tan();
  };
  var Kc = function(e2) {
    return new this(e2).tanh();
  };
  var zc = function(e2) {
    return y(e2 = new this(e2), e2.e + 1, 1);
  };
  var vr = function(e2) {
    return or.isDecimal(e2) ? true : e2 !== null && typeof e2 == "object" && typeof e2.s == "number" && typeof e2.e == "number" && typeof e2.toFixed == "function" && Array.isArray(e2.d);
  };
  var Tr = function(e2) {
    return e2 instanceof nt;
  };
  var an = function(e2) {
    return new Ri(As(e2));
  };
  var As = function(e2) {
    let r2 = new J;
    for (let [t3, n] of Object.entries(e2)) {
      let i = new sn(t3, Is(n));
      r2.addField(i);
    }
    return r2;
  };
  var Is = function(e2) {
    if (typeof e2 == "string")
      return new H(JSON.stringify(e2));
    if (typeof e2 == "number" || typeof e2 == "boolean")
      return new H(String(e2));
    if (typeof e2 == "bigint")
      return new H(`${e2}n`);
    if (e2 === null)
      return new H("null");
    if (e2 === undefined)
      return new H("undefined");
    if (vr(e2))
      return new H(`new Prisma.Decimal("${e2.toFixed()}")`);
    if (e2 instanceof Uint8Array)
      return Buffer.isBuffer(e2) ? new H(`Buffer.alloc(${e2.byteLength})`) : new H(`new Uint8Array(${e2.byteLength})`);
    if (e2 instanceof Date) {
      let r2 = Wt(e2) ? e2.toISOString() : "Invalid Date";
      return new H(`new Date("${r2}")`);
    }
    return e2 instanceof Ne ? new H(`Prisma.${e2._getName()}`) : Tr(e2) ? new H(`prisma.${ps(e2.modelName)}.\$fields.${e2.name}`) : Array.isArray(e2) ? Zc(e2) : typeof e2 == "object" ? As(e2) : new H(Object.prototype.toString.call(e2));
  };
  var Zc = function(e2) {
    let r2 = new Rr;
    for (let t3 of e2)
      r2.addItem(Is(t3));
    return r2;
  };
  var _s = function(e2) {
    if (e2 === undefined)
      return "";
    let r2 = an(e2);
    return new br(0, { colors: on }).write(r2).toString();
  };
  var sr = function({ error: e2, user_facing_error: r2 }, t3, n) {
    return r2.error_code ? new V(ep(r2, n), { code: r2.error_code, clientVersion: t3, meta: r2.meta, batchRequestIdx: r2.batch_request_idx }) : new j(e2, { clientVersion: t3, batchRequestIdx: r2.batch_request_idx });
  };
  var ep = function(e2, r2) {
    let t3 = e2.message;
    return (r2 === "postgresql" || r2 === "postgres" || r2 === "mysql") && e2.error_code === Xc && (t3 += `
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`), t3;
  };
  var ks = function(e2) {
    var r2 = e2.split(`
`);
    return r2.reduce(function(t3, n) {
      var i = np(n) || op(n) || lp(n) || mp(n) || cp(n);
      return i && t3.push(i), t3;
    }, []);
  };
  var np = function(e2) {
    var r2 = rp.exec(e2);
    if (!r2)
      return null;
    var t3 = r2[2] && r2[2].indexOf("native") === 0, n = r2[2] && r2[2].indexOf("eval") === 0, i = tp.exec(r2[2]);
    return n && i != null && (r2[2] = i[1], r2[3] = i[2], r2[4] = i[3]), { file: t3 ? null : r2[2], methodName: r2[1] || it, arguments: t3 ? [r2[2]] : [], lineNumber: r2[3] ? +r2[3] : null, column: r2[4] ? +r2[4] : null };
  };
  var op = function(e2) {
    var r2 = ip.exec(e2);
    return r2 ? { file: r2[2], methodName: r2[1] || it, arguments: [], lineNumber: +r2[3], column: r2[4] ? +r2[4] : null } : null;
  };
  var lp = function(e2) {
    var r2 = sp.exec(e2);
    if (!r2)
      return null;
    var t3 = r2[3] && r2[3].indexOf(" > eval") > -1, n = ap.exec(r2[3]);
    return t3 && n != null && (r2[3] = n[1], r2[4] = n[2], r2[5] = null), { file: r2[3], methodName: r2[1] || it, arguments: r2[2] ? r2[2].split(",") : [], lineNumber: r2[4] ? +r2[4] : null, column: r2[5] ? +r2[5] : null };
  };
  var cp = function(e2) {
    var r2 = up.exec(e2);
    return r2 ? { file: r2[3], methodName: r2[1] || it, arguments: [], lineNumber: +r2[4], column: r2[5] ? +r2[5] : null } : null;
  };
  var mp = function(e2) {
    var r2 = pp.exec(e2);
    return r2 ? { file: r2[2], methodName: r2[1] || it, arguments: [], lineNumber: +r2[3], column: r2[4] ? +r2[4] : null } : null;
  };
  var We = function(e2) {
    return e2 === "minimal" ? typeof $EnabledCallSite == "function" && e2 !== "minimal" ? new $EnabledCallSite : new Si : new Ai;
  };
  var Sr = function(e2 = {}) {
    let r2 = fp(e2);
    return Object.entries(r2).reduce((n, [i, o]) => (Ds[i] !== undefined ? n.select[i] = { select: o } : n[i] = o, n), { select: {} });
  };
  var fp = function(e2 = {}) {
    return typeof e2._count == "boolean" ? { ...e2, _count: { _all: e2._count } } : e2;
  };
  var ln = function(e2 = {}) {
    return (r2) => (typeof e2._count == "boolean" && (r2._count = r2._count._all), r2);
  };
  var Ls = function(e2, r2) {
    let t3 = ln(e2);
    return r2({ action: "aggregate", unpacker: t3, argsMapper: Sr })(e2);
  };
  var gp = function(e2 = {}) {
    let { select: r2, ...t3 } = e2;
    return typeof r2 == "object" ? Sr({ ...t3, _count: r2 }) : Sr({ ...t3, _count: { _all: true } });
  };
  var hp = function(e2 = {}) {
    return typeof e2.select == "object" ? (r2) => ln(e2)(r2)._count : (r2) => ln(e2)(r2)._count._all;
  };
  var Ns = function(e2, r2) {
    return r2({ action: "count", unpacker: hp(e2), argsMapper: gp })(e2);
  };
  var yp = function(e2 = {}) {
    let r2 = Sr(e2);
    if (Array.isArray(r2.by))
      for (let t3 of r2.by)
        typeof t3 == "string" && (r2.select[t3] = true);
    else
      typeof r2.by == "string" && (r2.select[r2.by] = true);
    return r2;
  };
  var Ep = function(e2 = {}) {
    return (r2) => (typeof e2?._count == "boolean" && r2.forEach((t3) => {
      t3._count = t3._count._all;
    }), r2);
  };
  var Os = function(e2, r2) {
    return r2({ action: "groupBy", unpacker: Ep(e2), argsMapper: yp })(e2);
  };
  var Fs = function(e2, r2, t3) {
    if (r2 === "aggregate")
      return (n) => Ls(n, t3);
    if (r2 === "count")
      return (n) => Ns(n, t3);
    if (r2 === "groupBy")
      return (n) => Os(n, t3);
  };
  var Ms = function(e2, r2) {
    let t3 = r2.fields.filter((i) => !i.relationName), n = pi(t3, (i) => i.name);
    return new Proxy({}, { get(i, o) {
      if (o in i || typeof o == "symbol")
        return i[o];
      let s = n[o];
      if (s)
        return new nt(e2, o, s.type, s.isList, s.kind === "enum");
    }, ...Ht(Object.keys(n)) });
  };
  var bp = function(e2, r2) {
    return e2 === undefined || r2 === undefined ? [] : [...r2, "select", e2];
  };
  var wp = function(e2, r2, t3) {
    return r2 === undefined ? e2 ?? {} : qs(r2, t3, e2 || true);
  };
  var _i = function(e2, r2, t3, n, i, o) {
    let a2 = e2._runtimeDataModel.models[r2].fields.reduce((l, u) => ({ ...l, [u.name]: u }), {});
    return (l) => {
      let u = We(e2._errorFormat), c = bp(n, i), p = wp(l, o, c), m = t3({ dataPath: c, callsite: u })(p), f = xp(e2, r2);
      return new Proxy(m, { get(g, h) {
        if (!f.includes(h))
          return g[h];
        let T = [a2[h].type, t3, h], C = [c, p];
        return _i(e2, ...T, ...C);
      }, ...Ht([...f, ...Object.getOwnPropertyNames(m)]) });
    };
  };
  var xp = function(e2, r2) {
    return e2._runtimeDataModel.models[r2].fields.filter((t3) => t3.kind === "object").map((t3) => t3.name);
  };
  var ye = function(e2, r2, t3, n, i) {
    this.type = e2, this.content = r2, this.alias = t3, this.length = (n || "").length | 0, this.greedy = !!i;
  };
  var Tp = function(e2) {
    return Bs[e2] || Pp;
  };
  var Vs = function(e2) {
    return Cp(e2, P.languages.javascript);
  };
  var Cp = function(e2, r2) {
    return P.tokenize(e2, r2).map((n) => ye.stringify(n)).join("");
  };
  var Us = function(e2) {
    return (0, js.default)(e2);
  };
  var Ap = function({ message: e2, originalMethod: r2, isPanic: t3, callArguments: n }) {
    return { functionName: `prisma.${r2}()`, message: e2, isPanic: t3 ?? false, callArguments: n };
  };
  var Ip = function({ callsite: e2, message: r2, originalMethod: t3, isPanic: n, callArguments: i }, o) {
    let s = Ap({ message: r2, originalMethod: t3, isPanic: n, callArguments: i });
    if (!e2 || typeof window < "u" || false)
      return s;
    let a2 = e2.getLocation();
    if (!a2 || !a2.lineNumber || !a2.columnNumber)
      return s;
    let l = Math.max(1, a2.lineNumber - 3), u = cn.read(a2.fileName)?.slice(l, a2.lineNumber), c = u?.lineAt(a2.lineNumber);
    if (u && c) {
      let p = kp(c), m = _p(c);
      if (!m)
        return s;
      s.functionName = `${m.code})`, s.location = a2, n || (u = u.mapLineAt(a2.lineNumber, (g) => g.slice(0, m.openingBraceIndex))), u = o.highlightSource(u);
      let f = String(u.lastLineNumber).length;
      if (s.contextLines = u.mapLines((g, h) => o.gray(String(h).padStart(f)) + " " + g).mapLines((g) => o.dim(g)).prependSymbolAt(a2.lineNumber, o.bold(o.red("\u2192"))), i) {
        let g = p + f + 1;
        g += 2, s.callArguments = (0, Gs.default)(i, g).slice(g);
      }
    }
    return s;
  };
  var _p = function(e2) {
    let r2 = Object.keys(De.ModelAction).join("|"), n = new RegExp(String.raw`\.(${r2})\(`).exec(e2);
    if (n) {
      let i = n.index + n[0].length, o = e2.lastIndexOf(" ", n.index) + 1;
      return { code: e2.slice(o, i), openingBraceIndex: i };
    }
    return null;
  };
  var kp = function(e2) {
    let r2 = 0;
    for (let t3 = 0;t3 < e2.length; t3++) {
      if (e2.charAt(t3) !== " ")
        return r2;
      r2++;
    }
    return r2;
  };
  var Dp = function({ functionName: e2, location: r2, message: t3, isPanic: n, contextLines: i, callArguments: o }, s) {
    let a2 = [""], l = r2 ? " in" : ":";
    if (n ? (a2.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), a2.push(s.red(`It occurred in the ${s.bold(`\`${e2}\``)} invocation${l}`))) : a2.push(s.red(`Invalid ${s.bold(`\`${e2}\``)} invocation${l}`)), r2 && a2.push(s.underline(Lp(r2))), i) {
      a2.push("");
      let u = [i.toString()];
      o && (u.push(o), u.push(s.dim(")"))), a2.push(u.join("")), o && a2.push("");
    } else
      a2.push(""), o && a2.push(o), a2.push("");
    return a2.push(t3), a2.join(`
`);
  };
  var Lp = function(e2) {
    let r2 = [e2.fileName];
    return e2.lineNumber && r2.push(String(e2.lineNumber)), e2.columnNumber && r2.push(String(e2.columnNumber)), r2.join(":");
  };
  var Ar = function(e2) {
    let r2 = e2.showColors ? Rp : Sp, t3;
    return t3 = Ip(e2, r2), Dp(t3, r2);
  };
  var Js = function(e2, r2, t3, n) {
    return e2 === De.ModelAction.findFirstOrThrow || e2 === De.ModelAction.findUniqueOrThrow ? Np(r2, t3, n) : n;
  };
  var Np = function(e2, r2, t3) {
    return async (n) => {
      if ("rejectOnNotFound" in n.args) {
        let o = Ar({ originalMethod: n.clientMethod, callsite: n.callsite, message: "'rejectOnNotFound' option is not supported" });
        throw new K(o, { clientVersion: r2 });
      }
      return await t3(n).catch((o) => {
        throw o instanceof V && o.code === "P2025" ? new Le(`No ${e2} found`, r2) : o;
      });
    };
  };
  var Re = function(e2) {
    return e2.replace(/^./, (r2) => r2.toLowerCase());
  };
  var ki = function(e2, r2) {
    let t3 = e2._extensions.getAllModelExtensions(r2) ?? {}, n = [Mp(e2, r2), qp(e2, r2), et(t3), ne("name", () => r2), ne("$name", () => r2), ne("$parent", () => e2._appliedParent)];
    return Pe({}, n);
  };
  var Mp = function(e2, r2) {
    let t3 = Re(r2), n = Object.keys(De.ModelAction).concat("count");
    return { getKeys() {
      return n;
    }, getPropertyValue(i) {
      let o = i, s = (l) => e2._request(l);
      s = Js(o, r2, e2._clientVersion, s);
      let a2 = (l) => (u) => {
        let c = We(e2._errorFormat);
        return e2._createPrismaPromise((p) => {
          let m = { args: u, dataPath: [], action: o, model: r2, clientMethod: `${t3}.${i}`, jsModelName: t3, transaction: p, callsite: c };
          return s({ ...m, ...l });
        });
      };
      return Op.includes(o) ? _i(e2, r2, a2) : $p(i) ? Fs(e2, i, a2) : a2({});
    } };
  };
  var $p = function(e2) {
    return Fp.includes(e2);
  };
  var qp = function(e2, r2) {
    return ir(ne("fields", () => {
      let t3 = e2._runtimeDataModel.models[r2];
      return Ms(r2, t3);
    }));
  };
  var Hs = function(e2) {
    return e2.replace(/^./, (r2) => r2.toUpperCase());
  };
  var ot = function(e2) {
    let r2 = [Bp(e2), ne(Di, () => e2), ne("$parent", () => e2._appliedParent)], t3 = e2._extensions.getAllClientExtensions();
    return t3 && r2.push(et(t3)), Pe(e2, r2);
  };
  var Bp = function(e2) {
    let r2 = Object.keys(e2._runtimeDataModel.models), t3 = r2.map(Re), n = [...new Set(r2.concat(t3))];
    return ir({ getKeys() {
      return n;
    }, getPropertyValue(i) {
      let o = Hs(i);
      if (e2._runtimeDataModel.models[o] !== undefined)
        return ki(e2, o);
      if (e2._runtimeDataModel.models[i] !== undefined)
        return ki(e2, i);
    }, getPropertyDescriptor(i) {
      if (!t3.includes(i))
        return { enumerable: false };
    } });
  };
  var Ws = function(e2) {
    return e2[Di] ? e2[Di] : e2;
  };
  var Ks = function(e2) {
    if (typeof e2 == "function")
      return e2(this);
    if (e2.client?.__AccelerateEngine) {
      let t3 = e2.client.__AccelerateEngine;
      this._originalClient._engine = new t3(this._originalClient._accelerateEngineConfig);
    }
    let r2 = Object.create(this._originalClient, { _extensions: { value: this._extensions.append(e2) }, _appliedParent: { value: this, configurable: true }, $use: { value: undefined }, $on: { value: undefined } });
    return ot(r2);
  };
  var zs = function({ result: e2, modelName: r2, select: t3, extensions: n }) {
    let i = n.getAllComputedFields(r2);
    if (!i)
      return e2;
    let o = [], s = [];
    for (let a2 of Object.values(i)) {
      if (t3) {
        if (!t3[a2.name])
          continue;
        let l = a2.needs.filter((u) => !t3[u]);
        l.length > 0 && s.push(rt(l));
      }
      Vp(e2, a2.needs) && o.push(jp(a2, Pe(e2, o)));
    }
    return o.length > 0 || s.length > 0 ? Pe(e2, [...o, ...s]) : e2;
  };
  var Vp = function(e2, r2) {
    return r2.every((t3) => ci(e2, t3));
  };
  var jp = function(e2, r2) {
    return ir(ne(e2.name, () => e2.compute(r2)));
  };
  var pn = function({ visitor: e2, result: r2, args: t3, runtimeDataModel: n, modelName: i }) {
    if (Array.isArray(r2)) {
      for (let s = 0;s < r2.length; s++)
        r2[s] = pn({ result: r2[s], args: t3, modelName: i, runtimeDataModel: n, visitor: e2 });
      return r2;
    }
    let o = e2(r2, i, t3) ?? r2;
    return t3.include && Ys({ includeOrSelect: t3.include, result: o, parentModelName: i, runtimeDataModel: n, visitor: e2 }), t3.select && Ys({ includeOrSelect: t3.select, result: o, parentModelName: i, runtimeDataModel: n, visitor: e2 }), o;
  };
  var Ys = function({ includeOrSelect: e2, result: r2, parentModelName: t3, runtimeDataModel: n, visitor: i }) {
    for (let [o, s] of Object.entries(e2)) {
      if (!s || r2[o] == null)
        continue;
      let l = n.models[t3].fields.find((c) => c.name === o);
      if (!l || l.kind !== "object" || !l.relationName)
        continue;
      let u = typeof s == "object" ? s : {};
      r2[o] = pn({ visitor: i, result: r2[o], args: u, modelName: l.type, runtimeDataModel: n });
    }
  };
  var Zs = function({ result: e2, modelName: r2, args: t3, extensions: n, runtimeDataModel: i }) {
    return n.isEmpty() || e2 == null || typeof e2 != "object" || !i.models[r2] ? e2 : pn({ result: e2, args: t3 ?? {}, modelName: r2, runtimeDataModel: i, visitor: (s, a2, l) => zs({ result: s, modelName: Re(a2), select: l.select, extensions: n }) });
  };
  var Xs = function(e2) {
    if (e2 instanceof oe)
      return Up(e2);
    if (Array.isArray(e2)) {
      let t3 = [e2[0]];
      for (let n = 1;n < e2.length; n++)
        t3[n] = st(e2[n]);
      return t3;
    }
    let r2 = {};
    for (let t3 in e2)
      r2[t3] = st(e2[t3]);
    return r2;
  };
  var Up = function(e2) {
    return new oe(e2.strings, e2.values);
  };
  var st = function(e2) {
    if (typeof e2 != "object" || e2 == null || e2 instanceof Ne || Tr(e2))
      return e2;
    if (vr(e2))
      return new Te(e2.toFixed());
    if (wr(e2))
      return new Date(+e2);
    if (ArrayBuffer.isView(e2))
      return e2.slice(0);
    if (Array.isArray(e2)) {
      let r2 = e2.length, t3;
      for (t3 = Array(r2);r2--; )
        t3[r2] = st(e2[r2]);
      return t3;
    }
    if (typeof e2 == "object") {
      let r2 = {};
      for (let t3 in e2)
        t3 === "__proto__" ? Object.defineProperty(r2, t3, { value: st(e2[t3]), configurable: true, enumerable: true, writable: true }) : r2[t3] = st(e2[t3]);
      return r2;
    }
    tr(e2, "Unknown value");
  };
  var ra = function(e2, r2, t3, n = 0) {
    return e2._createPrismaPromise((i) => {
      let o = r2.customDataProxyFetch;
      return "transaction" in r2 && i !== undefined && (r2.transaction?.kind === "batch" && r2.transaction.lock.then(), r2.transaction = i), n === t3.length ? e2._executeRequest(r2) : t3[n]({ model: r2.model, operation: r2.model ? r2.action : r2.clientMethod, args: Xs(r2.args ?? {}), __internalParams: r2, query: (s, a2 = r2) => {
        let l = a2.customDataProxyFetch;
        return a2.customDataProxyFetch = oa(o, l), a2.args = s, ra(e2, a2, t3, n + 1);
      } });
    });
  };
  var ta = function(e2, r2) {
    let { jsModelName: t3, action: n, clientMethod: i } = r2, o = t3 ? n : i;
    if (e2._extensions.isEmpty())
      return e2._executeRequest(r2);
    let s = e2._extensions.getAllQueryCallbacks(t3 ?? "$none", o);
    return ra(e2, r2, s);
  };
  var na = function(e2) {
    return (r2) => {
      let t3 = { requests: r2 }, n = r2[0].extensions.getAllBatchQueryCallbacks();
      return n.length ? ia(t3, n, 0, e2) : e2(t3);
    };
  };
  var ia = function(e2, r2, t3, n) {
    if (t3 === r2.length)
      return n(e2);
    let i = e2.customDataProxyFetch, o = e2.requests[0].transaction;
    return r2[t3]({ args: { queries: e2.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: o ? { isolationLevel: o.kind === "batch" ? o.isolationLevel : undefined } : undefined }, __internalParams: e2, query(s, a2 = e2) {
      let l = a2.customDataProxyFetch;
      return a2.customDataProxyFetch = oa(i, l), ia(a2, r2, t3 + 1, n);
    } });
  };
  var oa = function(e2 = ea, r2 = ea) {
    return (t3) => e2(r2(t3));
  };
  var aa = function(e2, r2, t3) {
    let n = Re(t3);
    return !r2.result || !(r2.result.$allModels || r2.result[n]) ? e2 : Qp({ ...e2, ...sa(r2.name, e2, r2.result.$allModels), ...sa(r2.name, e2, r2.result[n]) });
  };
  var Qp = function(e2) {
    let r2 = new xe, t3 = (n, i) => r2.getOrCreate(n, () => i.has(n) ? [n] : (i.add(n), e2[n] ? e2[n].needs.flatMap((o) => t3(o, i)) : [n]));
    return hr(e2, (n) => ({ ...n, needs: t3(n.name, new Set) }));
  };
  var sa = function(e2, r2, t3) {
    return t3 ? hr(t3, ({ needs: n, compute: i }, o) => ({ name: o, needs: n ? Object.keys(n).filter((s) => n[s]) : [], compute: Gp(r2, o, i) })) : {};
  };
  var Gp = function(e2, r2, t3) {
    let n = e2?.[r2]?.compute;
    return n ? (i) => t3({ ...i, [r2]: n(i) }) : t3;
  };
  var la = function(e2, r2) {
    if (!r2)
      return e2;
    let t3 = { ...e2 };
    for (let n of Object.values(r2))
      if (e2[n.name])
        for (let i of n.needs)
          t3[i] = true;
    return t3;
  };
  var pa = function({ postinstall: e2, ciName: r2, clientVersion: t3 }) {
    if (ua("checkPlatformCaching:postinstall", e2), ua("checkPlatformCaching:ciName", r2), e2 === true && r2 && r2 in ca) {
      let n = `Prisma has detected that this project was built on ${r2}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ca[r2]}-build`;
      throw console.error(n), new R(n, t3);
    }
  };
  var ma = function(e2, r2) {
    return e2 ? e2.datasources ? e2.datasources : e2.datasourceUrl ? { [r2[0]]: { url: e2.datasourceUrl } } : {} : {};
  };
  var da = function() {
    return typeof Netlify == "object" ? "netlify" : typeof EdgeRuntime == "string" ? "edge-light" : globalThis.navigator?.userAgent === Jp ? "workerd" : globalThis.Deno ? "deno" : globalThis.__lagon__ ? "lagon" : globalThis.process?.release?.name === Hp ? "node" : globalThis.Bun ? "bun" : globalThis.fastly ? "fastly" : "unknown";
  };
  var fn = function() {
    let e2 = da();
    return { id: e2, prettyName: Wp[e2] || e2, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(e2) };
  };
  var gn = function(e2) {
    let { runtimeBinaryTarget: r2 } = e2;
    return `Add "${r2}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Kp(e2)}`;
  };
  var Kp = function(e2) {
    let { generator: r2, generatorBinaryTargets: t3, runtimeBinaryTarget: n } = e2, i = { fromEnvVar: null, value: n }, o = [...t3, i];
    return ai({ ...r2, binaryTargets: o });
  };
  var Ke = function(e2) {
    let { runtimeBinaryTarget: r2 } = e2;
    return `Prisma Client could not locate the Query Engine for runtime "${r2}".`;
  };
  var ze = function(e2) {
    let { searchedLocations: r2 } = e2;
    return `The following locations have been searched:
${[...new Set(r2)].map((i) => `  ${i}`).join(`
`)}`;
  };
  var fa = function(e2) {
    let { runtimeBinaryTarget: r2 } = e2;
    return `${Ke(e2)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${r2}".
${gn(e2)}

${ze(e2)}`;
  };
  var hn = function(e2) {
    return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e2}`;
  };
  var yn = function(e2) {
    let { errorStack: r2 } = e2;
    return r2?.match(/\/\.next|\/next@|\/next\//) ? `

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.` : "";
  };
  var ga = function(e2) {
    let { queryEngineName: r2 } = e2;
    return `${Ke(e2)}${yn(e2)}

This is likely caused by a bundler that has not copied "${r2}" next to the resulting bundle.
Ensure that "${r2}" has been copied next to the bundle or in "${e2.expectedLocation}".

${hn("engine-not-found-bundler-investigation")}

${ze(e2)}`;
  };
  var ha = function(e2) {
    let { runtimeBinaryTarget: r2, generatorBinaryTargets: t3 } = e2, n = t3.find((i) => i.native);
    return `${Ke(e2)}

This happened because Prisma Client was generated for "${n?.value ?? "unknown"}", but the actual deployment required "${r2}".
${gn(e2)}

${ze(e2)}`;
  };
  var ya = function(e2) {
    let { queryEngineName: r2 } = e2;
    return `${Ke(e2)}${yn(e2)}

This is likely caused by tooling that has not copied "${r2}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${r2}" has been copied to "${e2.expectedLocation}".

${hn("engine-not-found-tooling-investigation")}

${ze(e2)}`;
  };
  async function ba(e2, r2) {
    let t3 = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e2] ?? r2.prismaPath;
    if (t3 !== undefined)
      return t3;
    let { enginePath: n, searchedLocations: i } = await Zp(e2, r2);
    if (zp("enginePath", n), n !== undefined && e2 === "binary" && ti(n), n !== undefined)
      return r2.prismaPath = n;
    let o = await rr(), s = r2.generator?.binaryTargets ?? [], a2 = s.some((m) => m.native), l = !s.some((m) => m.value === o), u = __filename.match(Yp()) === null, c = { searchedLocations: i, generatorBinaryTargets: s, generator: r2.generator, runtimeBinaryTarget: o, queryEngineName: wa(e2, o), expectedLocation: at.default.relative(process.cwd(), r2.dirname), errorStack: new Error().stack }, p;
    throw a2 && l ? p = ha(c) : l ? p = fa(c) : u ? p = ga(c) : p = ya(c), new R(p, r2.clientVersion);
  }
  async function Zp(engineType, config) {
    let binaryTarget = await rr(), searchedLocations = [], dirname = eval("__dirname"), searchLocations = [config.dirname, at.default.resolve(dirname, ".."), config.generator?.output?.value ?? dirname, at.default.resolve(dirname, "../../../.prisma/client"), "/tmp/prisma-engines", config.cwd];
    __filename.includes("resolveEnginePath") && searchLocations.push(zo());
    for (let e2 of searchLocations) {
      let r2 = wa(engineType, binaryTarget), t3 = at.default.join(e2, r2);
      if (searchedLocations.push(e2), Ea.default.existsSync(t3))
        return { enginePath: t3, searchedLocations };
    }
    return { enginePath: undefined, searchedLocations };
  }
  function wa(e2, r2) {
    return e2 === "library" ? It(r2, "fs") : `query-engine-${r2}${r2 === "windows" ? ".exe" : ""}`;
  }
  function xa(e2) {
    return e2 ? e2.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (r2) => `${r2[0]}5`) : "";
  }
  function Pa(e2) {
    return e2.split(`
`).map((r2) => r2.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
  }
  function Ta({ title: e2, user: r2 = "prisma", repo: t3 = "prisma", template: n = "bug_report.yml", body: i }) {
    return (0, va.default)({ user: r2, repo: t3, template: n, title: e2, body: i });
  }
  function Ca({ version: e2, binaryTarget: r2, title: t3, description: n, engineVersion: i, database: o, query: s }) {
    let a2 = go(6000 - (s?.length ?? 0)), l = Pa((0, Li.default)(a2)), u = n ? `# Description
\`\`\`
${n}
\`\`\`` : "", c = (0, Li.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${r2?.padEnd(19)}|
| Prisma Client   | ${e2?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s ? xa(s) : ""}
\`\`\`
`), p = Ta({ title: t3, body: c });
    return `${t3}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${ee(p)}

If you want the Prisma team to look into it, please open the link above \uD83D\uDE4F
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  }
  function Ir({ inlineDatasources: e2, overrideDatasources: r2, env: t3, clientVersion: n }) {
    let i, o = Object.keys(e2)[0], s = e2[o]?.url, a2 = r2[o]?.url;
    if (o === undefined ? i = undefined : a2 ? i = a2 : s?.value ? i = s.value : s?.fromEnvVar && (i = t3[s.fromEnvVar]), s?.fromEnvVar !== undefined && i === undefined)
      throw new R(`error: Environment variable not found: ${s.fromEnvVar}.`, n);
    if (i === undefined)
      throw new R("error: Missing URL environment variable, value, or override.", n);
    return i;
  }
  function S(e2, r2) {
    return { ...e2, isRetryable: r2 };
  }
  async function rm(e2) {
    let r2;
    try {
      r2 = await e2.text();
    } catch {
      return { type: "EmptyError" };
    }
    try {
      let t3 = JSON.parse(r2);
      if (typeof t3 == "string")
        switch (t3) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: t3 };
          default:
            return { type: "UnknownTextError", body: t3 };
        }
      if (typeof t3 == "object" && t3 !== null) {
        if ("is_panic" in t3 && "message" in t3 && "error_code" in t3)
          return { type: "QueryEngineError", body: t3 };
        if ("EngineNotStarted" in t3 || "InteractiveTransactionMisrouted" in t3 || "InvalidRequestError" in t3) {
          let n = Object.values(t3)[0].reason;
          return typeof n == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n) ? { type: "UnknownJsonError", body: t3 } : { type: "DataProxyError", body: t3 };
        }
      }
      return { type: "UnknownJsonError", body: t3 };
    } catch {
      return r2 === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: r2 };
    }
  }
  async function Et(e2, r2) {
    if (e2.ok)
      return;
    let t3 = { clientVersion: r2, response: e2 }, n = await rm(e2);
    if (n.type === "QueryEngineError")
      throw new V(n.body.message, { code: n.body.error_code, clientVersion: r2 });
    if (n.type === "DataProxyError") {
      if (n.body === "InternalDataProxyError")
        throw new kr(t3, "Internal Data Proxy error");
      if ("EngineNotStarted" in n.body) {
        if (n.body.EngineNotStarted.reason === "SchemaMissing")
          return new ur(t3);
        if (n.body.EngineNotStarted.reason === "EngineVersionNotSupported")
          throw new pt(t3);
        if ("EngineStartupError" in n.body.EngineNotStarted.reason) {
          let { msg: i, logs: o } = n.body.EngineNotStarted.reason.EngineStartupError;
          throw new ct(t3, i, o);
        }
        if ("KnownEngineStartupError" in n.body.EngineNotStarted.reason) {
          let { msg: i, error_code: o } = n.body.EngineNotStarted.reason.KnownEngineStartupError;
          throw new R(i, r2, o);
        }
        if ("HealthcheckTimeout" in n.body.EngineNotStarted.reason) {
          let { logs: i } = n.body.EngineNotStarted.reason.HealthcheckTimeout;
          throw new ut(t3, i);
        }
      }
      if ("InteractiveTransactionMisrouted" in n.body) {
        let i = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
        throw new dt(t3, i[n.body.InteractiveTransactionMisrouted.reason]);
      }
      if ("InvalidRequestError" in n.body)
        throw new ft(t3, n.body.InvalidRequestError.reason);
    }
    if (e2.status === 401 || e2.status === 403)
      throw new ht(t3, Dr($i, n));
    if (e2.status === 404)
      return new gt(t3, Dr(Fi, n));
    if (e2.status === 429)
      throw new yt(t3, Dr(qi, n));
    if (e2.status === 504)
      throw new mt(t3, Dr(Oi, n));
    if (e2.status >= 500)
      throw new kr(t3, Dr(Mi, n));
    if (e2.status >= 400)
      throw new lt(t3, Dr(Ni, n));
  }
  function Dr(e2, r2) {
    return r2.type === "EmptyError" ? e2 : `${e2}: ${JSON.stringify(r2)}`;
  }
  function Ra(e2) {
    let r2 = Math.pow(2, e2) * 50, t3 = Math.ceil(Math.random() * r2) - Math.ceil(r2 / 2), n = r2 + t3;
    return new Promise((i) => setTimeout(() => i(n), n));
  }
  function Sa(e2) {
    let r2 = new TextEncoder().encode(e2), t3 = "", n = r2.byteLength, i = n % 3, o = n - i, s, a2, l, u, c;
    for (let p = 0;p < o; p = p + 3)
      c = r2[p] << 16 | r2[p + 1] << 8 | r2[p + 2], s = (c & 16515072) >> 18, a2 = (c & 258048) >> 12, l = (c & 4032) >> 6, u = c & 63, t3 += Fe[s] + Fe[a2] + Fe[l] + Fe[u];
    return i == 1 ? (c = r2[o], s = (c & 252) >> 2, a2 = (c & 3) << 4, t3 += Fe[s] + Fe[a2] + "==") : i == 2 && (c = r2[o] << 8 | r2[o + 1], s = (c & 64512) >> 10, a2 = (c & 1008) >> 4, l = (c & 15) << 2, t3 += Fe[s] + Fe[a2] + Fe[l] + "="), t3;
  }
  function Aa(e2) {
    if (!!e2.generator?.previewFeatures.some((t3) => t3.toLowerCase().includes("metrics")))
      throw new R("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e2.clientVersion);
  }
  function tm(e2) {
    return e2[0] * 1000 + e2[1] / 1e6;
  }
  function Ia(e2) {
    return new Date(tm(e2));
  }
  async function cr(e2, r2, t3 = (n) => n) {
    let n = r2.clientVersion;
    try {
      return typeof fetch == "function" ? await t3(fetch)(e2, r2) : await t3(Bi)(e2, r2);
    } catch (i) {
      let o = i.message ?? "Unknown error";
      throw new bt(o, { clientVersion: n });
    }
  }
  function im(e2) {
    return { ...e2.headers, "Content-Type": "application/json" };
  }
  function om(e2) {
    return { method: e2.method, headers: im(e2) };
  }
  function sm(e2, r2) {
    return { text: () => Promise.resolve(Buffer.concat(e2).toString()), json: () => Promise.resolve().then(() => JSON.parse(Buffer.concat(e2).toString())), ok: r2.statusCode >= 200 && r2.statusCode <= 299, status: r2.statusCode, url: r2.url, headers: new Vi(r2.headers) };
  }
  async function Bi(e2, r2 = {}) {
    let t3 = am("https"), n = om(r2), i = [], { origin: o } = new URL(e2);
    return new Promise((s, a2) => {
      let l = t3.request(e2, n, (u) => {
        let { statusCode: c, headers: { location: p } } = u;
        c >= 301 && c <= 399 && p && (p.startsWith("http") === false ? s(Bi(`${o}${p}`, r2)) : s(Bi(p, r2))), u.on("data", (m) => i.push(m)), u.on("end", () => s(sm(i, u))), u.on("error", a2);
      });
      l.on("error", a2), l.end(r2.body ?? "");
    });
  }
  async function um(e2, r2) {
    let t3 = _a["@prisma/engines-version"], n = r2.clientVersion ?? "unknown";
    if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
      return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
    if (e2.includes("accelerate") && n !== "0.0.0" && n !== "in-memory")
      return n;
    let [i, o] = n?.split("-") ?? [];
    if (o === undefined && lm.test(i))
      return i;
    if (o !== undefined || n === "0.0.0" || n === "in-memory") {
      if (e2.startsWith("localhost") || e2.startsWith("127.0.0.1"))
        return "0.0.0";
      let [s] = t3.split("-") ?? [], [a2, l, u] = s.split("."), c = cm(`<=${a2}.${l}.${u}`), p = await cr(c, { clientVersion: n });
      if (!p.ok)
        throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text() || "<empty body>"}`);
      let m = await p.text();
      ka("length of body fetched from unpkg.com", m.length);
      let f;
      try {
        f = JSON.parse(m);
      } catch (g) {
        throw console.error("JSON.parse error: body fetched from unpkg.com: ", m), g;
      }
      return f.version;
    }
    throw new lr("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n });
  }
  async function Da(e2, r2) {
    let t3 = await um(e2, r2);
    return ka("version", t3), t3;
  }
  function cm(e2) {
    return encodeURI(`https://unpkg.com/prisma@${e2}/package.json`);
  }
  function Na(e2) {
    if (e2?.kind === "itx")
      return e2.options.id;
  }
  function pm() {
    let e2 = globalThis;
    return e2[Qi] === undefined && (e2[Qi] = {}), e2[Qi];
  }
  function mm(e2) {
    let r2 = pm();
    if (r2[e2] !== undefined)
      return r2[e2];
    let t3 = Oa.default.toNamespacedPath(e2), n = { exports: {} }, i = 0;
    return process.platform !== "win32" && (i = Gi.default.constants.dlopen.RTLD_LAZY | Gi.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n, t3, i), r2[e2] = n.exports, n.exports;
  }
  function fm(e2) {
    return e2.item_type === "query" && "query" in e2;
  }
  function gm(e2) {
    return "level" in e2 ? e2.level === "error" && e2.message === "PANIC" : false;
  }
  function hm(e2) {
    return typeof e2 == "object" && e2 !== null && e2.error_code !== undefined;
  }
  function Hi(e2, r2) {
    return Ca({ binaryTarget: e2.binaryTarget, title: r2, version: e2.config.clientVersion, engineVersion: e2.versionInfo?.commit, database: e2.config.activeProvider, query: e2.lastQuery });
  }
  function Ba({ copyEngine: e2 = true }, r2) {
    let t3;
    try {
      t3 = Ir({ inlineDatasources: r2.inlineDatasources, overrideDatasources: r2.overrideDatasources, env: { ...r2.env, ...process.env }, clientVersion: r2.clientVersion });
    } catch {
    }
    e2 && t3?.startsWith("prisma://") && Hr("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
    let n = Ur(r2.generator), i = !!(t3?.startsWith("prisma://") || !e2), o = !!r2.adapter, s = n === "library", a2 = n === "binary";
    if (i && o || o && false) {
      let l;
      throw e2 ? t3?.startsWith("prisma://") ? l = ["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.", "Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."] : l = ["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."] : l = ["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.", "Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."], new K(l.join(`
`), { clientVersion: r2.clientVersion });
    }
    if (i)
      return new wt(r2);
    if (s)
      return new xt(r2);
    throw new K("Invalid client engine type, please use `library` or `binary`", { clientVersion: r2.clientVersion });
  }
  function bn({ generator: e2 }) {
    return e2?.previewFeatures ?? [];
  }
  function Qa(e2, r2) {
    let t3 = Ga(e2), n = ym(t3), i = bm(n);
    i ? wn(i, r2) : r2.addErrorMessage(() => "Unknown error");
  }
  function Ga(e2) {
    return e2.errors.flatMap((r2) => r2.kind === "Union" ? Ga(r2) : [r2]);
  }
  function ym(e2) {
    let r2 = new Map, t3 = [];
    for (let n of e2) {
      if (n.kind !== "InvalidArgumentType") {
        t3.push(n);
        continue;
      }
      let i = `${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`, o = r2.get(i);
      o ? r2.set(i, { ...n, argument: { ...n.argument, typeNames: Em(o.argument.typeNames, n.argument.typeNames) } }) : r2.set(i, n);
    }
    return t3.push(...r2.values()), t3;
  }
  function Em(e2, r2) {
    return [...new Set(e2.concat(r2))];
  }
  function bm(e2) {
    return mi(e2, (r2, t3) => {
      let n = ja(r2), i = ja(t3);
      return n !== i ? n - i : Ua(r2) - Ua(t3);
    });
  }
  function ja(e2) {
    let r2 = 0;
    return Array.isArray(e2.selectionPath) && (r2 += e2.selectionPath.length), Array.isArray(e2.argumentPath) && (r2 += e2.argumentPath.length), r2;
  }
  function Ua(e2) {
    switch (e2.kind) {
      case "InvalidArgumentValue":
      case "ValueTooLarge":
        return 20;
      case "InvalidArgumentType":
        return 10;
      case "RequiredArgumentMissing":
        return -10;
      default:
        return 0;
    }
  }
  function wn(e2, r2) {
    switch (e2.kind) {
      case "IncludeAndSelect":
        wm(e2, r2);
        break;
      case "IncludeOnScalar":
        xm(e2, r2);
        break;
      case "EmptySelection":
        Pm(e2, r2);
        break;
      case "UnknownSelectionField":
        vm(e2, r2);
        break;
      case "UnknownArgument":
        Tm(e2, r2);
        break;
      case "UnknownInputField":
        Cm(e2, r2);
        break;
      case "RequiredArgumentMissing":
        Rm(e2, r2);
        break;
      case "InvalidArgumentType":
        Sm(e2, r2);
        break;
      case "InvalidArgumentValue":
        Am(e2, r2);
        break;
      case "ValueTooLarge":
        Im(e2, r2);
        break;
      case "SomeFieldsMissing":
        _m(e2, r2);
        break;
      case "TooManyFieldsGiven":
        km(e2, r2);
        break;
      case "Union":
        Qa(e2, r2);
        break;
      default:
        throw new Error("not implemented: " + e2.kind);
    }
  }
  function wm(e2, r2) {
    let t3 = r2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    t3 && t3 instanceof J && (t3.getField("include")?.markAsError(), t3.getField("select")?.markAsError()), r2.addErrorMessage((n) => `Please ${n.bold("either")} use ${n.green("`include`")} or ${n.green("`select`")}, but ${n.red("not both")} at the same time.`);
  }
  function xm(e2, r2) {
    let [t3, n] = Pn(e2.selectionPath), i = e2.outputType, o = r2.arguments.getDeepSelectionParent(t3)?.value;
    if (o && (o.getField(n)?.markAsError(), i))
      for (let s of i.fields)
        s.isRelation && o.addSuggestion(new Me(s.name, "true"));
    r2.addErrorMessage((s) => {
      let a2 = `Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;
      return i ? a2 += ` on model ${s.bold(i.name)}. ${Pt(s)}` : a2 += ".", a2 += `
Note that ${s.bold("include")} statements only accept relation fields.`, a2;
    });
  }
  function Pm(e2, r2) {
    let t3 = e2.outputType, n = r2.arguments.getDeepSelectionParent(e2.selectionPath)?.value, i = n?.isEmpty() ?? false;
    n && (n.removeAllFields(), Ka(n, t3)), r2.addErrorMessage((o) => i ? `The ${o.red("`select`")} statement for type ${o.bold(t3.name)} must not be empty. ${Pt(o)}` : `The ${o.red("`select`")} statement for type ${o.bold(t3.name)} needs ${o.bold("at least one truthy value")}.`);
  }
  function vm(e2, r2) {
    let [t3, n] = Pn(e2.selectionPath), i = r2.arguments.getDeepSelectionParent(t3);
    i && (i.value.getField(n)?.markAsError(), Ka(i.value, e2.outputType)), r2.addErrorMessage((o) => {
      let s = [`Unknown field ${o.red(`\`${n}\``)}`];
      return i && s.push(`for ${o.bold(i.kind)} statement`), s.push(`on model ${o.bold(`\`${e2.outputType.name}\``)}.`), s.push(Pt(o)), s.join(" ");
    });
  }
  function Tm(e2, r2) {
    let t3 = e2.argumentPath[0], n = r2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    n instanceof J && (n.getField(t3)?.markAsError(), Dm(n, e2.arguments)), r2.addErrorMessage((i) => Ha(i, t3, e2.arguments.map((o) => o.name)));
  }
  function Cm(e2, r2) {
    let [t3, n] = Pn(e2.argumentPath), i = r2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    if (i instanceof J) {
      i.getDeepField(e2.argumentPath)?.markAsError();
      let o = i.getDeepFieldValue(t3);
      o instanceof J && za(o, e2.inputType);
    }
    r2.addErrorMessage((o) => Ha(o, n, e2.inputType.fields.map((s) => s.name)));
  }
  function Ha(e2, r2, t3) {
    let n = [`Unknown argument \`${e2.red(r2)}\`.`], i = Nm(r2, t3);
    return i && n.push(`Did you mean \`${e2.green(i)}\`?`), t3.length > 0 && n.push(Pt(e2)), n.join(" ");
  }
  function Rm(e2, r2) {
    let t3;
    r2.addErrorMessage((l) => t3?.value instanceof H && t3.value.text === "null" ? `Argument \`${l.green(o)}\` must not be ${l.red("null")}.` : `Argument \`${l.green(o)}\` is missing.`);
    let n = r2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    if (!(n instanceof J))
      return;
    let [i, o] = Pn(e2.argumentPath), s = new xn, a2 = n.getDeepFieldValue(i);
    if (a2 instanceof J)
      if (t3 = a2.getField(o), t3 && a2.removeField(o), e2.inputTypes.length === 1 && e2.inputTypes[0].kind === "object") {
        for (let l of e2.inputTypes[0].fields)
          s.addField(l.name, l.typeNames.join(" | "));
        a2.addSuggestion(new Me(o, s).makeRequired());
      } else {
        let l = e2.inputTypes.map(Wa).join(" | ");
        a2.addSuggestion(new Me(o, l).makeRequired());
      }
  }
  function Wa(e2) {
    return e2.kind === "list" ? `${Wa(e2.elementType)}[]` : e2.name;
  }
  function Sm(e2, r2) {
    let t3 = e2.argument.name, n = r2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    n instanceof J && n.getDeepFieldValue(e2.argumentPath)?.markAsError(), r2.addErrorMessage((i) => {
      let o = vn("or", e2.argument.typeNames.map((s) => i.green(s)));
      return `Argument \`${i.bold(t3)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e2.inferredType)}.`;
    });
  }
  function Am(e2, r2) {
    let t3 = e2.argument.name, n = r2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    n instanceof J && n.getDeepFieldValue(e2.argumentPath)?.markAsError(), r2.addErrorMessage((i) => {
      let o = [`Invalid value for argument \`${i.bold(t3)}\``];
      if (e2.underlyingError && o.push(`: ${e2.underlyingError}`), o.push("."), e2.argument.typeNames.length > 0) {
        let s = vn("or", e2.argument.typeNames.map((a2) => i.green(a2)));
        o.push(` Expected ${s}.`);
      }
      return o.join("");
    });
  }
  function Im(e2, r2) {
    let t3 = e2.argument.name, n = r2.arguments.getDeepSubSelectionValue(e2.selectionPath), i;
    if (n instanceof J) {
      let s = n.getDeepField(e2.argumentPath)?.value;
      s?.markAsError(), s instanceof H && (i = s.text);
    }
    r2.addErrorMessage((o) => {
      let s = ["Unable to fit value"];
      return i && s.push(o.red(i)), s.push(`into a 64-bit signed integer for field \`${o.bold(t3)}\``), s.join(" ");
    });
  }
  function _m(e2, r2) {
    let t3 = e2.argumentPath[e2.argumentPath.length - 1], n = r2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    if (n instanceof J) {
      let i = n.getDeepFieldValue(e2.argumentPath);
      i instanceof J && za(i, e2.inputType);
    }
    r2.addErrorMessage((i) => {
      let o = [`Argument \`${i.bold(t3)}\` of type ${i.bold(e2.inputType.name)} needs`];
      return e2.constraints.minFieldCount === 1 ? e2.constraints.requiredFields ? o.push(`${i.green("at least one of")} ${vn("or", e2.constraints.requiredFields.map((s) => `\`${i.bold(s)}\``))} arguments.`) : o.push(`${i.green("at least one")} argument.`) : o.push(`${i.green(`at least ${e2.constraints.minFieldCount}`)} arguments.`), o.push(Pt(i)), o.join(" ");
    });
  }
  function km(e2, r2) {
    let t3 = e2.argumentPath[e2.argumentPath.length - 1], n = r2.arguments.getDeepSubSelectionValue(e2.selectionPath), i = [];
    if (n instanceof J) {
      let o = n.getDeepFieldValue(e2.argumentPath);
      o instanceof J && (o.markAsError(), i = Object.keys(o.getFields()));
    }
    r2.addErrorMessage((o) => {
      let s = [`Argument \`${o.bold(t3)}\` of type ${o.bold(e2.inputType.name)} needs`];
      return e2.constraints.minFieldCount === 1 && e2.constraints.maxFieldCount == 1 ? s.push(`${o.green("exactly one")} argument,`) : e2.constraints.maxFieldCount == 1 ? s.push(`${o.green("at most one")} argument,`) : s.push(`${o.green(`at most ${e2.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${vn("and", i.map((a2) => o.red(a2)))}. Please choose`), e2.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${e2.constraints.maxFieldCount}.`), s.join(" ");
    });
  }
  function Ka(e2, r2) {
    for (let t3 of r2.fields)
      e2.hasField(t3.name) || e2.addSuggestion(new Me(t3.name, "true"));
  }
  function Dm(e2, r2) {
    for (let t3 of r2)
      e2.hasField(t3.name) || e2.addSuggestion(new Me(t3.name, t3.typeNames.join(" | ")));
  }
  function za(e2, r2) {
    if (r2.kind === "object")
      for (let t3 of r2.fields)
        e2.hasField(t3.name) || e2.addSuggestion(new Me(t3.name, t3.typeNames.join(" | ")));
  }
  function Pn(e2) {
    let r2 = [...e2], t3 = r2.pop();
    if (!t3)
      throw new Error("unexpected empty path");
    return [r2, t3];
  }
  function Pt({ green: e2, enabled: r2 }) {
    return "Available options are " + (r2 ? `listed in ${e2("green")}` : "marked with ?") + ".";
  }
  function vn(e2, r2) {
    if (r2.length === 1)
      return r2[0];
    let t3 = [...r2], n = t3.pop();
    return `${t3.join(", ")} ${e2} ${n}`;
  }
  function Nm(e2, r2) {
    let t3 = 1 / 0, n;
    for (let i of r2) {
      let o = (0, Ja.default)(e2, i);
      o > Lm || o < t3 && (t3 = o, n = i);
    }
    return n;
  }
  function Tn({ args: e2, errors: r2, errorFormat: t3, callsite: n, originalMethod: i, clientVersion: o }) {
    let s = an(e2);
    for (let p of r2)
      wn(p, s);
    let a2 = t3 === "pretty" ? Rs : on, l = s.renderAllMessages(a2), u = new br(0, { colors: a2 }).write(s).toString(), c = Ar({ message: l, callsite: n, originalMethod: i, showColors: t3 === "pretty", callArguments: u });
    throw new K(c, { clientVersion: o });
  }
  function Ya({ modelName: e2, action: r2, args: t3, runtimeDataModel: n, extensions: i, callsite: o, clientMethod: s, errorFormat: a2, clientVersion: l }) {
    let u = new Ki({ runtimeDataModel: n, modelName: e2, action: r2, rootArgs: t3, callsite: o, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: a2, clientVersion: l });
    return { modelName: e2, action: Om[r2], query: zi(t3, u) };
  }
  function zi({ select: e2, include: r2, ...t3 } = {}, n) {
    return { arguments: Xa(t3, n), selection: Fm(e2, r2, n) };
  }
  function Fm(e2, r2, t3) {
    return e2 && r2 && t3.throwValidationError({ kind: "IncludeAndSelect", selectionPath: t3.getSelectionPath() }), e2 ? qm(e2, t3) : Mm(t3, r2);
  }
  function Mm(e2, r2) {
    let t3 = {};
    return e2.model && !e2.isRawAction() && (t3.$composites = true, t3.$scalars = true), r2 && $m(t3, r2, e2), t3;
  }
  function $m(e2, r2, t3) {
    for (let [n, i] of Object.entries(r2)) {
      let o = t3.findField(n);
      o && o?.kind !== "object" && t3.throwValidationError({ kind: "IncludeOnScalar", selectionPath: t3.getSelectionPath().concat(n), outputType: t3.getOutputTypeDescription() }), i === true ? e2[n] = true : typeof i == "object" && (e2[n] = zi(i, t3.nestSelection(n)));
    }
  }
  function qm(e2, r2) {
    let t3 = {}, n = r2.getComputedFields(), i = la(e2, n);
    for (let [o, s] of Object.entries(i)) {
      let a2 = r2.findField(o);
      n?.[o] && !a2 || (s === true ? t3[o] = true : typeof s == "object" && (t3[o] = zi(s, r2.nestSelection(o))));
    }
    return t3;
  }
  function Za(e2, r2) {
    if (e2 === null)
      return null;
    if (typeof e2 == "string" || typeof e2 == "number" || typeof e2 == "boolean")
      return e2;
    if (typeof e2 == "bigint")
      return { $type: "BigInt", value: String(e2) };
    if (wr(e2)) {
      if (Wt(e2))
        return { $type: "DateTime", value: e2.toISOString() };
      r2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: r2.getSelectionPath(), argumentPath: r2.getArgumentPath(), argument: { name: r2.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
    }
    if (Tr(e2))
      return { $type: "FieldRef", value: { _ref: e2.name, _container: e2.modelName } };
    if (Array.isArray(e2))
      return Bm(e2, r2);
    if (ArrayBuffer.isView(e2))
      return { $type: "Bytes", value: Buffer.from(e2).toString("base64") };
    if (Vm(e2))
      return e2.values;
    if (vr(e2))
      return { $type: "Decimal", value: e2.toFixed() };
    if (e2 instanceof Ne) {
      if (e2 !== Gt.instances[e2._getName()])
        throw new Error("Invalid ObjectEnumValue");
      return { $type: "Enum", value: e2._getName() };
    }
    if (jm(e2))
      return e2.toJSON();
    if (typeof e2 == "object")
      return Xa(e2, r2);
    r2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: r2.getSelectionPath(), argumentPath: r2.getArgumentPath(), argument: { name: r2.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e2)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
  }
  function Xa(e2, r2) {
    if (e2.$type)
      return { $type: "Raw", value: e2 };
    let t3 = {};
    for (let n in e2) {
      let i = e2[n];
      i !== undefined && (t3[n] = Za(i, r2.nestArgument(n)));
    }
    return t3;
  }
  function Bm(e2, r2) {
    let t3 = [];
    for (let n = 0;n < e2.length; n++) {
      let i = r2.nestArgument(String(n)), o = e2[n];
      o === undefined && r2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${r2.getArgumentName()}[${n}]`, typeNames: [] }, underlyingError: "Can not use `undefined` value within array. Use `null` or filter out `undefined` values" }), t3.push(Za(o, i));
    }
    return t3;
  }
  function Vm(e2) {
    return typeof e2 == "object" && e2 !== null && e2.__prismaRawParameters__ === true;
  }
  function jm(e2) {
    return typeof e2 == "object" && e2 !== null && typeof e2.toJSON == "function";
  }
  function vt(e2) {
    try {
      return tl(e2, "fast");
    } catch {
      return tl(e2, "slow");
    }
  }
  function tl(e2, r2) {
    return JSON.stringify(e2.map((t3) => Um(t3, r2)));
  }
  function Um(e2, r2) {
    return typeof e2 == "bigint" ? { prisma__type: "bigint", prisma__value: e2.toString() } : wr(e2) ? { prisma__type: "date", prisma__value: e2.toJSON() } : Te.isDecimal(e2) ? { prisma__type: "decimal", prisma__value: e2.toJSON() } : Buffer.isBuffer(e2) ? { prisma__type: "bytes", prisma__value: e2.toString("base64") } : Qm(e2) || ArrayBuffer.isView(e2) ? { prisma__type: "bytes", prisma__value: Buffer.from(e2).toString("base64") } : typeof e2 == "object" && r2 === "slow" ? il(e2) : e2;
  }
  function Qm(e2) {
    return e2 instanceof ArrayBuffer || e2 instanceof SharedArrayBuffer ? true : typeof e2 == "object" && e2 !== null ? e2[Symbol.toStringTag] === "ArrayBuffer" || e2[Symbol.toStringTag] === "SharedArrayBuffer" : false;
  }
  function il(e2) {
    if (typeof e2 != "object" || e2 === null)
      return e2;
    if (typeof e2.toJSON == "function")
      return e2.toJSON();
    if (Array.isArray(e2))
      return e2.map(nl);
    let r2 = {};
    for (let t3 of Object.keys(e2))
      r2[t3] = nl(e2[t3]);
    return r2;
  }
  function nl(e2) {
    return typeof e2 == "bigint" ? e2.toString() : il(e2);
  }
  function Yi(e2, r2, t3, n) {
    if (!(e2 !== "postgresql" && e2 !== "cockroachdb") && t3.length > 0 && Gm.exec(r2))
      throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  }
  function Xi(e2) {
    return function(t3) {
      let n, i = (o = e2) => {
        try {
          return o === undefined || o?.kind === "itx" ? n ?? (n = ll(t3(o))) : ll(t3(o));
        } catch (s) {
          return Promise.reject(s);
        }
      };
      return { then(o, s) {
        return i().then(o, s);
      }, catch(o) {
        return i().catch(o);
      }, finally(o) {
        return i().finally(o);
      }, requestTransaction(o) {
        let s = i(o);
        return s.requestTransaction ? s.requestTransaction(o) : s;
      }, [Symbol.toStringTag]: "PrismaPromise" };
    };
  }
  function ll(e2) {
    return typeof e2.then == "function" ? e2 : Promise.resolve(e2);
  }
  function cl(e2) {
    return e2.includes("tracing") ? new eo : ul;
  }
  function pl(e2, r2 = () => {
  }) {
    let t3, n = new Promise((i) => t3 = i);
    return { then(i) {
      return --e2 === 0 && t3(r2()), i?.(n);
    } };
  }
  function dl(e2) {
    return typeof e2 == "string" ? e2 : e2.reduce((r2, t3) => {
      let n = typeof t3 == "string" ? t3 : t3.level;
      return n === "query" ? r2 : r2 && (t3 === "info" || r2 === "info") ? "info" : n;
    }, undefined);
  }
  function Rn(e2) {
    return typeof e2.batchRequestIdx == "number";
  }
  function Sn(e2) {
    return e2 === null ? e2 : Array.isArray(e2) ? e2.map(Sn) : typeof e2 == "object" ? Hm(e2) ? Wm(e2) : hr(e2, Sn) : e2;
  }
  function Hm(e2) {
    return e2 !== null && typeof e2 == "object" && typeof e2.$type == "string";
  }
  function Wm({ $type: e2, value: r2 }) {
    switch (e2) {
      case "BigInt":
        return BigInt(r2);
      case "Bytes":
        return Buffer.from(r2, "base64");
      case "DateTime":
        return new Date(r2);
      case "Decimal":
        return new Te(r2);
      case "Json":
        return JSON.parse(r2);
      default:
        tr(r2, "Unknown tagged value");
    }
  }
  function fl(e2) {
    if (e2.action !== "findUnique" && e2.action !== "findUniqueOrThrow")
      return;
    let r2 = [];
    return e2.modelName && r2.push(e2.modelName), e2.query.arguments && r2.push(ro(e2.query.arguments)), r2.push(ro(e2.query.selection)), r2.join("");
  }
  function ro(e2) {
    return `(${Object.keys(e2).sort().map((t3) => {
      let n = e2[t3];
      return typeof n == "object" && n !== null ? `(${t3} ${ro(n)})` : t3;
    }).join(" ")})`;
  }
  function to(e2) {
    return Km[e2];
  }
  function Ym(e2) {
    if (e2) {
      if (e2.kind === "batch")
        return { kind: "batch", options: { isolationLevel: e2.isolationLevel } };
      if (e2.kind === "itx")
        return { kind: "itx", options: hl(e2) };
      tr(e2, "Unknown transaction kind");
    }
  }
  function hl(e2) {
    return { id: e2.id, payload: e2.payload };
  }
  function Zm(e2, r2) {
    return Rn(e2) && r2?.kind === "batch" && e2.batchRequestIdx !== r2.index;
  }
  function Xm(e2) {
    return e2.code === "P2009" || e2.code === "P2012";
  }
  function yl(e2) {
    if (e2.kind === "Union")
      return { kind: "Union", errors: e2.errors.map(yl) };
    if (Array.isArray(e2.selectionPath)) {
      let [, ...r2] = e2.selectionPath;
      return { ...e2, selectionPath: r2 };
    }
    return e2;
  }
  function wl(e2) {
    return e2.map((r2) => {
      let t3 = {};
      for (let n of Object.keys(r2))
        t3[n] = xl(r2[n]);
      return t3;
    });
  }
  function xl({ prisma__type: e2, prisma__value: r2 }) {
    switch (e2) {
      case "bigint":
        return BigInt(r2);
      case "bytes":
        return Buffer.from(r2, "base64");
      case "decimal":
        return new Te(r2);
      case "datetime":
      case "date":
        return new Date(r2);
      case "time":
        return new Date(`1970-01-01T${r2}Z`);
      case "array":
        return r2.map(xl);
      default:
        return r2;
    }
  }
  function Rl(e2, r2) {
    for (let [t3, n] of Object.entries(e2)) {
      if (!Pl.includes(t3)) {
        let i = Lr(t3, Pl);
        throw new q(`Unknown property ${t3} provided to PrismaClient constructor.${i}`);
      }
      rd[t3](n, r2);
    }
    if (e2.datasourceUrl && e2.datasources)
      throw new q('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
  }
  function Lr(e2, r2) {
    if (r2.length === 0 || typeof e2 != "string")
      return "";
    let t3 = td(e2, r2);
    return t3 ? ` Did you mean "${t3}"?` : "";
  }
  function td(e2, r2) {
    if (r2.length === 0)
      return null;
    let t3 = r2.map((i) => ({ value: i, distance: (0, Cl.default)(e2, i) }));
    t3.sort((i, o) => i.distance < o.distance ? -1 : 1);
    let n = t3[0];
    return n.distance < 3 ? n.value : null;
  }
  function Sl(e2) {
    return e2.length === 0 ? Promise.resolve([]) : new Promise((r2, t3) => {
      let n = new Array(e2.length), i = null, o = false, s = 0, a2 = () => {
        o || (s++, s === e2.length && (o = true, i ? t3(i) : r2(n)));
      }, l = (u) => {
        o || (o = true, t3(u));
      };
      for (let u = 0;u < e2.length; u++)
        e2[u].then((c) => {
          n[u] = c, a2();
        }, (c) => {
          if (!Rn(c)) {
            l(c);
            return;
          }
          c.batchRequestIdx === u ? l(c) : (i || (i = c), a2());
        });
    });
  }
  function Ll(e2) {

    class r2 {
      constructor(n) {
        this._originalClient = this;
        this._middlewares = new Cn;
        this._createPrismaPromise = Xi();
        this.$extends = Ks;
        e2 = n?.__internal?.configOverride?.(e2) ?? e2, pa(e2), n && Rl(n, e2);
        let i = n?.adapter ? yi(n.adapter) : undefined, o = new kl.EventEmitter().on("error", () => {
        });
        this._extensions = dn.empty(), this._previewFeatures = bn(e2), this._clientVersion = e2.clientVersion ?? bl, this._activeProvider = e2.activeProvider, this._tracingHelper = cl(this._previewFeatures);
        let s = { rootEnvPath: e2.relativeEnvPaths.rootEnvPath && Tt.default.resolve(e2.dirname, e2.relativeEnvPaths.rootEnvPath), schemaEnvPath: e2.relativeEnvPaths.schemaEnvPath && Tt.default.resolve(e2.dirname, e2.relativeEnvPaths.schemaEnvPath) }, a2 = !i && jr(s, { conflictCheck: "none" }) || e2.injectableEdgeEnv?.();
        try {
          let l = n ?? {}, u = l.__internal ?? {}, c = u.debug === true;
          c && N.enable("prisma:client");
          let p = Tt.default.resolve(e2.dirname, e2.relativePath);
          Dl.default.existsSync(p) || (p = e2.dirname), Ye("dirname", e2.dirname), Ye("relativePath", e2.relativePath), Ye("cwd", p);
          let m = u.engine || {};
          if (l.errorFormat ? this._errorFormat = l.errorFormat : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e2.runtimeDataModel, this._engineConfig = { cwd: p, dirname: e2.dirname, enableDebugLogs: c, allowTriggerPanic: m.allowTriggerPanic, datamodelPath: Tt.default.join(e2.dirname, e2.filename ?? "schema.prisma"), prismaPath: m.binaryPath ?? undefined, engineEndpoint: m.endpoint, generator: e2.generator, showColors: this._errorFormat === "pretty", logLevel: l.log && dl(l.log), logQueries: l.log && !!(typeof l.log == "string" ? l.log === "query" : l.log.find((f) => typeof f == "string" ? f === "query" : f.level === "query")), env: a2?.parsed ?? {}, flags: [], engineWasm: e2.engineWasm, clientVersion: e2.clientVersion, engineVersion: e2.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e2.activeProvider, inlineSchema: e2.inlineSchema, overrideDatasources: ma(l, e2.datasourceNames), inlineDatasources: e2.inlineDatasources, inlineSchemaHash: e2.inlineSchemaHash, tracingHelper: this._tracingHelper, transactionOptions: { maxWait: l.transactionOptions?.maxWait ?? 2000, timeout: l.transactionOptions?.timeout ?? 5000, isolationLevel: l.transactionOptions?.isolationLevel }, logEmitter: o, isBundled: e2.isBundled, adapter: i }, this._accelerateEngineConfig = { ...this._engineConfig, accelerateUtils: { resolveDatasourceUrl: Ir, getBatchRequestPayload: Er, prismaGraphQLToJSError: sr, PrismaClientUnknownRequestError: j, PrismaClientInitializationError: R, PrismaClientKnownRequestError: V, debug: N("prisma:client:accelerateEngine"), engineVersion: Il.version, clientVersion: e2.clientVersion } }, Ye("clientVersion", e2.clientVersion), this._engine = Ba(e2, this._engineConfig), this._requestHandler = new In(this, o), l.log)
            for (let f of l.log) {
              let g = typeof f == "string" ? f : f.emit === "stdout" ? f.level : null;
              g && this.$on(g, (h) => {
                Jr.log(`${Jr.tags[g] ?? ""}`, h.message || h.query);
              });
            }
          this._metrics = new yr(this._engine);
        } catch (l) {
          throw l.clientVersion = this._clientVersion, l;
        }
        return this._appliedParent = ot(this);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClient";
      }
      $use(n) {
        this._middlewares.use(n);
      }
      $on(n, i) {
        n === "beforeExit" ? this._engine.onBeforeExit(i) : n && this._engineConfig.logEmitter.on(n, i);
      }
      $connect() {
        try {
          return this._engine.start();
        } catch (n) {
          throw n.clientVersion = this._clientVersion, n;
        }
      }
      async $disconnect() {
        try {
          await this._engine.stop();
        } catch (n) {
          throw n.clientVersion = this._clientVersion, n;
        } finally {
          ho();
        }
      }
      $executeRawInternal(n, i, o, s) {
        let a2 = this._activeProvider;
        return this._request({ action: "executeRaw", args: o, transaction: n, clientMethod: i, argsMapper: Zi({ clientMethod: i, activeProvider: a2 }), callsite: We(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
      }
      $executeRaw(n, ...i) {
        return this._createPrismaPromise((o) => {
          if (n.raw !== undefined || n.sql !== undefined) {
            let [s, a2] = Al(n, i);
            return Yi(this._activeProvider, s.text, s.values, Array.isArray(n) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o, "$executeRaw", s, a2);
          }
          throw new K("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
        });
      }
      $executeRawUnsafe(n, ...i) {
        return this._createPrismaPromise((o) => (Yi(this._activeProvider, n, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o, "$executeRawUnsafe", [n, ...i])));
      }
      $runCommandRaw(n) {
        if (e2.activeProvider !== "mongodb")
          throw new K(`The ${e2.activeProvider} provider does not support \$runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
        return this._createPrismaPromise((i) => this._request({ args: n, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: el, callsite: We(this._errorFormat), transaction: i }));
      }
      async $queryRawInternal(n, i, o, s) {
        let a2 = this._activeProvider;
        return this._request({ action: "queryRaw", args: o, transaction: n, clientMethod: i, argsMapper: Zi({ clientMethod: i, activeProvider: a2 }), callsite: We(this._errorFormat), dataPath: [], middlewareArgsMapper: s }).then(wl);
      }
      $queryRaw(n, ...i) {
        return this._createPrismaPromise((o) => {
          if (n.raw !== undefined || n.sql !== undefined)
            return this.$queryRawInternal(o, "$queryRaw", ...Al(n, i));
          throw new K("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
        });
      }
      $queryRawUnsafe(n, ...i) {
        return this._createPrismaPromise((o) => this.$queryRawInternal(o, "$queryRawUnsafe", [n, ...i]));
      }
      _transactionWithArray({ promises: n, options: i }) {
        let o = od.nextId(), s = pl(n.length), a2 = n.map((l, u) => {
          if (l?.[Symbol.toStringTag] !== "PrismaPromise")
            throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
          let c = i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel, p = { kind: "batch", id: o, index: u, isolationLevel: c, lock: s };
          return l.requestTransaction?.(p) ?? l;
        });
        return Sl(a2);
      }
      async _transactionWithCallback({ callback: n, options: i }) {
        let o = { traceparent: this._tracingHelper.getTraceParent() }, s = { maxWait: i?.maxWait ?? this._engineConfig.transactionOptions.maxWait, timeout: i?.timeout ?? this._engineConfig.transactionOptions.timeout, isolationLevel: i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel }, a2 = await this._engine.transaction("start", o, s), l;
        try {
          let u = { kind: "itx", ...a2 };
          l = await n(this._createItxClient(u)), await this._engine.transaction("commit", o, a2);
        } catch (u) {
          throw await this._engine.transaction("rollback", o, a2).catch(() => {
          }), u;
        }
        return l;
      }
      _createItxClient(n) {
        return ot(Pe(Ws(this), [ne("_appliedParent", () => this._appliedParent._createItxClient(n)), ne("_createPrismaPromise", () => Xi(n)), ne(id, () => n.id), rt(ml)]));
      }
      $transaction(n, i) {
        let o;
        typeof n == "function" ? this._engineConfig.adapter?.adapterName === "@prisma/adapter-d1" ? o = () => {
          throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.");
        } : o = () => this._transactionWithCallback({ callback: n, options: i }) : o = () => this._transactionWithArray({ promises: n, options: i });
        let s = { name: "transaction", attributes: { method: "$transaction" } };
        return this._tracingHelper.runInChildSpan(s, o);
      }
      _request(n) {
        n.otelParentCtx = this._tracingHelper.getActiveContext();
        let i = n.middlewareArgsMapper ?? nd, o = { args: i.requestArgsToMiddlewareArgs(n.args), dataPath: n.dataPath, runInTransaction: !!n.transaction, action: n.action, model: n.model }, s = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o.action, model: o.model, name: o.model ? `${o.model}.${o.action}` : o.action } } }, a2 = -1, l = async (u) => {
          let c = this._middlewares.get(++a2);
          if (c)
            return this._tracingHelper.runInChildSpan(s.middleware, (A) => c(u, (T) => (A?.end(), l(T))));
          let { runInTransaction: p, args: m, ...f } = u, g = { ...n, ...f };
          m && (g.args = i.middlewareArgsToRequestArgs(m)), n.transaction !== undefined && p === false && delete g.transaction;
          let h = await ta(this, g);
          return g.model ? Zs({ result: h, modelName: g.model, args: g.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel }) : h;
        };
        return this._tracingHelper.runInChildSpan(s.operation, () => new _l.AsyncResource("prisma-client-request").runInAsyncScope(() => l(o)));
      }
      async _executeRequest({ args: n, clientMethod: i, dataPath: o, callsite: s, action: a2, model: l, argsMapper: u, transaction: c, unpacker: p, otelParentCtx: m, customDataProxyFetch: f }) {
        try {
          n = u ? u(n) : n;
          let g = { name: "serialize" }, h = this._tracingHelper.runInChildSpan(g, () => Ya({ modelName: l, runtimeDataModel: this._runtimeDataModel, action: a2, args: n, clientMethod: i, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion }));
          return N.enabled("prisma:client") && (Ye("Prisma Client call:"), Ye(`prisma.${i}(${_s(n)})`), Ye("Generated request:"), Ye(JSON.stringify(h, null, 2) + `
`)), c?.kind === "batch" && await c.lock, this._requestHandler.request({ protocolQuery: h, modelName: l, action: a2, clientMethod: i, dataPath: o, callsite: s, args: n, extensions: this._extensions, transaction: c, unpacker: p, otelParentCtx: m, otelChildCtx: this._tracingHelper.getActiveContext(), customDataProxyFetch: f });
        } catch (g) {
          throw g.clientVersion = this._clientVersion, g;
        }
      }
      get $metrics() {
        if (!this._hasPreviewFlag("metrics"))
          throw new K("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
        return this._metrics;
      }
      _hasPreviewFlag(n) {
        return !!this._engineConfig.previewFeatures?.includes(n);
      }
    }
    return r2;
  }
  function Al(e2, r2) {
    return sd(e2) ? [new oe(e2, r2), sl] : [e2, al];
  }
  function sd(e2) {
    return Array.isArray(e2) && Array.isArray(e2.raw);
  }
  function Nl(e2) {
    return new Proxy(e2, { get(r2, t3) {
      if (t3 in r2)
        return r2[t3];
      if (!ad.has(t3))
        throw new TypeError(`Invalid enum value: ${String(t3)}`);
    } });
  }
  function Ol(e2) {
    jr(e2, { conflictCheck: "warn" });
  }
  var __dirname = "/home/jam/Projects/Web/Personal/data-management-tool/api/node_modules/@prisma/client/runtime", __filename = "/home/jam/Projects/Web/Personal/data-management-tool/api/node_modules/@prisma/client/runtime/library.js";
  var Fl = Object.create;
  var Rt = Object.defineProperty;
  var Ml = Object.getOwnPropertyDescriptor;
  var $l = Object.getOwnPropertyNames;
  var ql = Object.getPrototypeOf;
  var Bl = Object.prototype.hasOwnProperty;
  var X = (e2, r2) => () => (r2 || e2((r2 = { exports: {} }).exports, r2), r2.exports);
  var Or2 = (e2, r2) => {
    for (var t3 in r2)
      Rt(e2, t3, { get: r2[t3], enumerable: true });
  };
  var no = (e2, r2, t3, n) => {
    if (r2 && typeof r2 == "object" || typeof r2 == "function")
      for (let i of $l(r2))
        !Bl.call(e2, i) && i !== t3 && Rt(e2, i, { get: () => r2[i], enumerable: !(n = Ml(r2, i)) || n.enumerable });
    return e2;
  };
  var _ = (e2, r2, t3) => (t3 = e2 != null ? Fl(ql(e2)) : {}, no(r2 || !e2 || !e2.__esModule ? Rt(t3, "default", { value: e2, enumerable: true }) : t3, e2));
  var Vl = (e2) => no(Rt({}, "__esModule", { value: true }), e2);
  var Ao = X((Od, Un) => {
    var v = Un.exports;
    Un.exports.default = v;
    var D = "\x1B[", Br = "\x1B]", dr = "\x07", Ft = ";", So = false;
    v.cursorTo = (e2, r2) => {
      if (typeof e2 != "number")
        throw new TypeError("The `x` argument is required");
      return typeof r2 != "number" ? D + (e2 + 1) + "G" : D + (r2 + 1) + ";" + (e2 + 1) + "H";
    };
    v.cursorMove = (e2, r2) => {
      if (typeof e2 != "number")
        throw new TypeError("The `x` argument is required");
      let t3 = "";
      return e2 < 0 ? t3 += D + -e2 + "D" : e2 > 0 && (t3 += D + e2 + "C"), r2 < 0 ? t3 += D + -r2 + "A" : r2 > 0 && (t3 += D + r2 + "B"), t3;
    };
    v.cursorUp = (e2 = 1) => D + e2 + "A";
    v.cursorDown = (e2 = 1) => D + e2 + "B";
    v.cursorForward = (e2 = 1) => D + e2 + "C";
    v.cursorBackward = (e2 = 1) => D + e2 + "D";
    v.cursorLeft = D + "G";
    v.cursorSavePosition = So ? "\x1B7" : D + "s";
    v.cursorRestorePosition = So ? "\x1B8" : D + "u";
    v.cursorGetPosition = D + "6n";
    v.cursorNextLine = D + "E";
    v.cursorPrevLine = D + "F";
    v.cursorHide = D + "?25l";
    v.cursorShow = D + "?25h";
    v.eraseLines = (e2) => {
      let r2 = "";
      for (let t3 = 0;t3 < e2; t3++)
        r2 += v.eraseLine + (t3 < e2 - 1 ? v.cursorUp() : "");
      return e2 && (r2 += v.cursorLeft), r2;
    };
    v.eraseEndLine = D + "K";
    v.eraseStartLine = D + "1K";
    v.eraseLine = D + "2K";
    v.eraseDown = D + "J";
    v.eraseUp = D + "1J";
    v.eraseScreen = D + "2J";
    v.scrollUp = D + "S";
    v.scrollDown = D + "T";
    v.clearScreen = "\x1Bc";
    v.clearTerminal = process.platform === "win32" ? `${v.eraseScreen}${D}0f` : `${v.eraseScreen}${D}3J${D}H`;
    v.beep = dr;
    v.link = (e2, r2) => [Br, "8", Ft, Ft, r2, dr, e2, Br, "8", Ft, Ft, dr].join("");
    v.image = (e2, r2 = {}) => {
      let t3 = `${Br}1337;File=inline=1`;
      return r2.width && (t3 += `;width=${r2.width}`), r2.height && (t3 += `;height=${r2.height}`), r2.preserveAspectRatio === false && (t3 += ";preserveAspectRatio=0"), t3 + ":" + e2.toString("base64") + dr;
    };
    v.iTerm = { setCwd: (e2 = process.cwd()) => `${Br}50;CurrentDir=${e2}${dr}`, annotation: (e2, r2 = {}) => {
      let t3 = `${Br}1337;`, n = typeof r2.x < "u", i = typeof r2.y < "u";
      if ((n || i) && !(n && i && typeof r2.length < "u"))
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      return e2 = e2.replace(/\|/g, ""), t3 += r2.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", r2.length > 0 ? t3 += (n ? [e2, r2.length, r2.x, r2.y] : [r2.length, e2]).join("|") : t3 += e2, t3 + dr;
    } };
  });
  var Qn = X((Fd, Io) => {
    Io.exports = (e2, r2 = process.argv) => {
      let t3 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", n = r2.indexOf(t3 + e2), i = r2.indexOf("--");
      return n !== -1 && (i === -1 || n < i);
    };
  });
  var Do = X((Md, ko) => {
    var Ru = import.meta.require("os"), _o = import.meta.require("tty"), pe = Qn(), { env: G } = process, je;
    pe("no-color") || pe("no-colors") || pe("color=false") || pe("color=never") ? je = 0 : (pe("color") || pe("colors") || pe("color=true") || pe("color=always")) && (je = 1);
    "FORCE_COLOR" in G && (G.FORCE_COLOR === "true" ? je = 1 : G.FORCE_COLOR === "false" ? je = 0 : je = G.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(G.FORCE_COLOR, 10), 3));
    function Gn(e2) {
      return e2 === 0 ? false : { level: e2, hasBasic: true, has256: e2 >= 2, has16m: e2 >= 3 };
    }
    function Jn(e2, r2) {
      if (je === 0)
        return 0;
      if (pe("color=16m") || pe("color=full") || pe("color=truecolor"))
        return 3;
      if (pe("color=256"))
        return 2;
      if (e2 && !r2 && je === undefined)
        return 0;
      let t3 = je || 0;
      if (G.TERM === "dumb")
        return t3;
      if (process.platform === "win32") {
        let n = Ru.release().split(".");
        return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in G)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n) => (n in G)) || G.CI_NAME === "codeship" ? 1 : t3;
      if ("TEAMCITY_VERSION" in G)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(G.TEAMCITY_VERSION) ? 1 : 0;
      if (G.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in G) {
        let n = parseInt((G.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (G.TERM_PROGRAM) {
          case "iTerm.app":
            return n >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(G.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(G.TERM) || ("COLORTERM" in G) ? 1 : t3;
    }
    function Su(e2) {
      let r2 = Jn(e2, e2 && e2.isTTY);
      return Gn(r2);
    }
    ko.exports = { supportsColor: Su, stdout: Gn(Jn(true, _o.isatty(1))), stderr: Gn(Jn(true, _o.isatty(2))) };
  });
  var Oo = X(($d, No) => {
    var Au = Do(), fr = Qn();
    function Lo(e2) {
      if (/^\d{3,4}$/.test(e2)) {
        let t3 = /(\d{1,2})(\d{2})/.exec(e2);
        return { major: 0, minor: parseInt(t3[1], 10), patch: parseInt(t3[2], 10) };
      }
      let r2 = (e2 || "").split(".").map((t3) => parseInt(t3, 10));
      return { major: r2[0], minor: r2[1], patch: r2[2] };
    }
    function Hn(e2) {
      let { env: r2 } = process;
      if ("FORCE_HYPERLINK" in r2)
        return !(r2.FORCE_HYPERLINK.length > 0 && parseInt(r2.FORCE_HYPERLINK, 10) === 0);
      if (fr("no-hyperlink") || fr("no-hyperlinks") || fr("hyperlink=false") || fr("hyperlink=never"))
        return false;
      if (fr("hyperlink=true") || fr("hyperlink=always") || "NETLIFY" in r2)
        return true;
      if (!Au.supportsColor(e2) || e2 && !e2.isTTY || process.platform === "win32" || "CI" in r2 || "TEAMCITY_VERSION" in r2)
        return false;
      if ("TERM_PROGRAM" in r2) {
        let t3 = Lo(r2.TERM_PROGRAM_VERSION);
        switch (r2.TERM_PROGRAM) {
          case "iTerm.app":
            return t3.major === 3 ? t3.minor >= 1 : t3.major > 3;
          case "WezTerm":
            return t3.major >= 20200620;
          case "vscode":
            return t3.major > 1 || t3.major === 1 && t3.minor >= 72;
        }
      }
      if ("VTE_VERSION" in r2) {
        if (r2.VTE_VERSION === "0.50.0")
          return false;
        let t3 = Lo(r2.VTE_VERSION);
        return t3.major > 0 || t3.minor >= 50;
      }
      return false;
    }
    No.exports = { supportsHyperlink: Hn, stdout: Hn(process.stdout), stderr: Hn(process.stderr) };
  });
  var Mo = X((qd, Vr) => {
    var Iu = Ao(), Wn = Oo(), Fo = (e2, r2, { target: t3 = "stdout", ...n } = {}) => Wn[t3] ? Iu.link(e2, r2) : n.fallback === false ? e2 : typeof n.fallback == "function" ? n.fallback(e2, r2) : `${e2} (\u200B${r2}\u200B)`;
    Vr.exports = (e2, r2, t3 = {}) => Fo(e2, r2, t3);
    Vr.exports.stderr = (e2, r2, t3 = {}) => Fo(e2, r2, { target: "stderr", ...t3 });
    Vr.exports.isSupported = Wn.stdout;
    Vr.exports.stderr.isSupported = Wn.stderr;
  });
  var qo = X((Kd, _u) => {
    _u.exports = { name: "dotenv", version: "16.0.3", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { require: "./lib/main.js", types: "./lib/main.d.ts", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", "lint-readme": "standard-markdown", pretest: "npm run lint && npm run dts-check", test: "tap tests/*.js --100 -Rspec", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^17.0.9", decache: "^4.6.1", dtslint: "^3.7.0", sinon: "^12.0.1", standard: "^16.0.4", "standard-markdown": "^7.1.0", "standard-version": "^9.3.2", tap: "^15.1.6", tar: "^6.1.11", typescript: "^4.5.4" }, engines: { node: ">=12" } };
  });
  var Vo = X((zd, $t) => {
    var ku = import.meta.require("fs"), Bo = import.meta.require("path"), Du = import.meta.require("os"), Lu = qo(), Nu = Lu.version, Ou = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function Fu(e2) {
      let r2 = {}, t3 = e2.toString();
      t3 = t3.replace(/\r\n?/mg, `
`);
      let n;
      for (;(n = Ou.exec(t3)) != null; ) {
        let i = n[1], o = n[2] || "";
        o = o.trim();
        let s = o[0];
        o = o.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (o = o.replace(/\\n/g, `
`), o = o.replace(/\\r/g, "\r")), r2[i] = o;
      }
      return r2;
    }
    function zn(e2) {
      console.log(`[dotenv@${Nu}][DEBUG] ${e2}`);
    }
    function Mu(e2) {
      return e2[0] === "~" ? Bo.join(Du.homedir(), e2.slice(1)) : e2;
    }
    function $u(e2) {
      let r2 = Bo.resolve(process.cwd(), ".env"), t3 = "utf8", n = !!(e2 && e2.debug), i = !!(e2 && e2.override);
      e2 && (e2.path != null && (r2 = Mu(e2.path)), e2.encoding != null && (t3 = e2.encoding));
      try {
        let o = Mt.parse(ku.readFileSync(r2, { encoding: t3 }));
        return Object.keys(o).forEach(function(s) {
          Object.prototype.hasOwnProperty.call(process.env, s) ? (i === true && (process.env[s] = o[s]), n && zn(i === true ? `"${s}" is already defined in \`process.env\` and WAS overwritten` : `"${s}" is already defined in \`process.env\` and was NOT overwritten`)) : process.env[s] = o[s];
        }), { parsed: o };
      } catch (o) {
        return n && zn(`Failed to load ${r2} ${o.message}`), { error: o };
      }
    }
    var Mt = { config: $u, parse: Fu };
    $t.exports.config = Mt.config;
    $t.exports.parse = Mt.parse;
    $t.exports = Mt;
  });
  var Ho = X((nf, Jo) => {
    Jo.exports = (e2) => {
      let r2 = e2.match(/^[ \t]*(?=\S)/gm);
      return r2 ? r2.reduce((t3, n) => Math.min(t3, n.length), 1 / 0) : 0;
    };
  });
  var Ko = X((of, Wo) => {
    var ju = Ho();
    Wo.exports = (e2) => {
      let r2 = ju(e2);
      if (r2 === 0)
        return e2;
      let t3 = new RegExp(`^[ \\t]{${r2}}`, "gm");
      return e2.replace(t3, "");
    };
  });
  var Xn = X((sf, Uu) => {
    Uu.exports = { name: "@prisma/engines-version", version: "5.12.0-21.473ed3124229e22d881cb7addf559799debae1ab", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "473ed3124229e22d881cb7addf559799debae1ab" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.26", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
  });
  var ei = X((Bt) => {
    Object.defineProperty(Bt, "__esModule", { value: true });
    Bt.enginesVersion = undefined;
    Bt.enginesVersion = Xn().prisma.enginesVersion;
  });
  var oi = X((_f, Zo) => {
    Zo.exports = (e2, r2 = 1, t3) => {
      if (t3 = { indent: " ", includeEmptyLines: false, ...t3 }, typeof e2 != "string")
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e2}\``);
      if (typeof r2 != "number")
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof r2}\``);
      if (typeof t3.indent != "string")
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof t3.indent}\``);
      if (r2 === 0)
        return e2;
      let n = t3.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return e2.replace(n, t3.indent.repeat(r2));
    };
  });
  var ts = X((Lf, rs) => {
    rs.exports = ({ onlyFirst: e2 = false } = {}) => {
      let r2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(r2, e2 ? undefined : "g");
    };
  });
  var ui = X((Nf, ns) => {
    var Xu = ts();
    ns.exports = (e2) => typeof e2 == "string" ? e2.replace(Xu(), "") : e2;
  });
  var is = X((Mf, jt) => {
    jt.exports = (e2 = {}) => {
      let r2;
      if (e2.repoUrl)
        r2 = e2.repoUrl;
      else if (e2.user && e2.repo)
        r2 = `https://github.com/${e2.user}/${e2.repo}`;
      else
        throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
      let t3 = new URL(`${r2}/issues/new`), n = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
      for (let i of n) {
        let o = e2[i];
        if (o !== undefined) {
          if (i === "labels" || i === "projects") {
            if (!Array.isArray(o))
              throw new TypeError(`The \`${i}\` option should be an array`);
            o = o.join(",");
          }
          t3.searchParams.set(i, o);
        }
      }
      return t3.toString();
    };
    jt.exports.default = jt.exports;
  });
  var Wi = X((C0, Va) => {
    Va.exports = function() {
      function e2(r2, t3, n, i, o) {
        return r2 < t3 || n < t3 ? r2 > n ? n + 1 : r2 + 1 : i === o ? t3 : t3 + 1;
      }
      return function(r2, t3) {
        if (r2 === t3)
          return 0;
        if (r2.length > t3.length) {
          var n = r2;
          r2 = t3, t3 = n;
        }
        for (var i = r2.length, o = t3.length;i > 0 && r2.charCodeAt(i - 1) === t3.charCodeAt(o - 1); )
          i--, o--;
        for (var s = 0;s < i && r2.charCodeAt(s) === t3.charCodeAt(s); )
          s++;
        if (i -= s, o -= s, i === 0 || o < 3)
          return o;
        var a2 = 0, l, u, c, p, m, f, g, h, A, T, C, E, I = [];
        for (l = 0;l < i; l++)
          I.push(l + 1), I.push(r2.charCodeAt(s + l));
        for (var me = I.length - 1;a2 < o - 3; )
          for (A = t3.charCodeAt(s + (u = a2)), T = t3.charCodeAt(s + (c = a2 + 1)), C = t3.charCodeAt(s + (p = a2 + 2)), E = t3.charCodeAt(s + (m = a2 + 3)), f = a2 += 4, l = 0;l < me; l += 2)
            g = I[l], h = I[l + 1], u = e2(g, u, c, A, h), c = e2(u, c, p, T, h), p = e2(c, p, m, C, h), f = e2(p, m, f, E, h), I[l] = f, m = p, p = c, c = u, u = g;
        for (;a2 < o; )
          for (A = t3.charCodeAt(s + (u = a2)), f = ++a2, l = 0;l < me; l += 2)
            g = I[l], I[l] = f = e2(g, u, f, A, I[l + 1]), u = g;
        return f;
      };
    }();
  });
  var ld = {};
  Or2(ld, { Debug: () => On, Decimal: () => Te, Extensions: () => kn, MetricsClient: () => yr, NotFoundError: () => Le, PrismaClientInitializationError: () => R, PrismaClientKnownRequestError: () => V, PrismaClientRustPanicError: () => ue, PrismaClientUnknownRequestError: () => j, PrismaClientValidationError: () => K, Public: () => Dn, Sql: () => oe, defineDmmfProperty: () => ss, empty: () => ls, getPrismaClient: () => Ll, getRuntime: () => fn, join: () => as, makeStrictEnum: () => Nl, objectEnumValues: () => Gt, raw: () => Ei, sqltag: () => bi, warnEnvConflicts: () => Ol, warnOnce: () => Hr });
  module.exports = Vl(ld);
  var kn = {};
  Or2(kn, { defineExtension: () => io, getExtensionContext: () => oo });
  var Dn = {};
  Or2(Dn, { validator: () => so });
  var St = {};
  Or2(St, { $: () => po, bgBlack: () => Yl, bgBlue: () => ru, bgCyan: () => nu, bgGreen: () => Xl, bgMagenta: () => tu, bgRed: () => Zl, bgWhite: () => iu, bgYellow: () => eu, black: () => Hl, blue: () => Ze, bold: () => W, cyan: () => _e, dim: () => Ie, gray: () => Fr, green: () => $e, grey: () => zl, hidden: () => Gl, inverse: () => Ql, italic: () => Ul, magenta: () => Wl, red: () => ce, reset: () => jl, strikethrough: () => Jl, underline: () => ee, white: () => Kl, yellow: () => de });
  var Ln;
  var ao;
  var lo;
  var uo;
  var co = true;
  typeof process < "u" && ({ FORCE_COLOR: Ln, NODE_DISABLE_COLORS: ao, NO_COLOR: lo, TERM: uo } = process.env || {}, co = process.stdout && process.stdout.isTTY);
  var po = { enabled: !ao && lo == null && uo !== "dumb" && (Ln != null && Ln !== "0" || co) };
  var jl = F(0, 0);
  var W = F(1, 22);
  var Ie = F(2, 22);
  var Ul = F(3, 23);
  var ee = F(4, 24);
  var Ql = F(7, 27);
  var Gl = F(8, 28);
  var Jl = F(9, 29);
  var Hl = F(30, 39);
  var ce = F(31, 39);
  var $e = F(32, 39);
  var de = F(33, 39);
  var Ze = F(34, 39);
  var Wl = F(35, 39);
  var _e = F(36, 39);
  var Kl = F(37, 39);
  var Fr = F(90, 39);
  var zl = F(90, 39);
  var Yl = F(40, 49);
  var Zl = F(41, 49);
  var Xl = F(42, 49);
  var eu = F(43, 49);
  var ru = F(44, 49);
  var tu = F(45, 49);
  var nu = F(46, 49);
  var iu = F(47, 49);
  var ou = 100;
  var mo = ["green", "yellow", "blue", "magenta", "cyan", "red"];
  var Mr = [];
  var fo = Date.now();
  var su = 0;
  var Nn = typeof process < "u" ? process.env : {};
  globalThis.DEBUG ?? (globalThis.DEBUG = Nn.DEBUG ?? "");
  globalThis.DEBUG_COLORS ?? (globalThis.DEBUG_COLORS = Nn.DEBUG_COLORS ? Nn.DEBUG_COLORS === "true" : true);
  var $r = { enable(e2) {
    typeof e2 == "string" && (globalThis.DEBUG = e2);
  }, disable() {
    let e2 = globalThis.DEBUG;
    return globalThis.DEBUG = "", e2;
  }, enabled(e2) {
    let r2 = globalThis.DEBUG.split(",").map((i) => i.replace(/[.+?^${}()|[\]\\]/g, "\\$&")), t3 = r2.some((i) => i === "" || i[0] === "-" ? false : e2.match(RegExp(i.split("*").join(".*") + "$"))), n = r2.some((i) => i === "" || i[0] !== "-" ? false : e2.match(RegExp(i.slice(1).split("*").join(".*") + "$")));
    return t3 && !n;
  }, log: (...e2) => {
    let [r2, t3, ...n] = e2, i;
    typeof import.meta.require == "function" && typeof process < "u" && typeof process.stderr < "u" && typeof process.stderr.write == "function" ? i = (...o) => {
      let s = import.meta.require("util");
      process.stderr.write(s.format(...o) + `
`);
    } : i = console.warn ?? console.log, i(`${r2} ${t3}`, ...n);
  }, formatters: {} };
  var On = new Proxy(au, { get: (e2, r2) => $r[r2], set: (e2, r2, t3) => $r[r2] = t3 });
  var N = On;
  var yo = _(import.meta.require("fs"));
  var Mn = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "freebsd14", "freebsd15", "openbsd", "netbsd", "arm"];
  var At = "libquery_engine";
  var xo = _(import.meta.require("child_process"));
  var Vn = _(import.meta.require("fs/promises"));
  var Nt = _(import.meta.require("os"));
  var ke = Symbol.for("@ts-pattern/matcher");
  var uu = Symbol.for("@ts-pattern/isVariadic");
  var kt = "@ts-pattern/anonymous-select-key";
  var $n = (e2) => !!(e2 && typeof e2 == "object");
  var _t = (e2) => e2 && !!e2[ke];
  var we = (e2, r2, t3) => {
    if (_t(e2)) {
      let n = e2[ke](), { matched: i, selections: o } = n.match(r2);
      return i && o && Object.keys(o).forEach((s) => t3(s, o[s])), i;
    }
    if ($n(e2)) {
      if (!$n(r2))
        return false;
      if (Array.isArray(e2)) {
        if (!Array.isArray(r2))
          return false;
        let n = [], i = [], o = [];
        for (let s of e2.keys()) {
          let a2 = e2[s];
          _t(a2) && a2[uu] ? o.push(a2) : o.length ? i.push(a2) : n.push(a2);
        }
        if (o.length) {
          if (o.length > 1)
            throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
          if (r2.length < n.length + i.length)
            return false;
          let s = r2.slice(0, n.length), a2 = i.length === 0 ? [] : r2.slice(-i.length), l = r2.slice(n.length, i.length === 0 ? 1 / 0 : -i.length);
          return n.every((u, c) => we(u, s[c], t3)) && i.every((u, c) => we(u, a2[c], t3)) && (o.length === 0 || we(o[0], l, t3));
        }
        return e2.length === r2.length && e2.every((s, a2) => we(s, r2[a2], t3));
      }
      return Object.keys(e2).every((n) => {
        let i = e2[n];
        return ((n in r2) || _t(o = i) && o[ke]().matcherType === "optional") && we(i, r2[n], t3);
        var o;
      });
    }
    return Object.is(r2, e2);
  };
  var Ve = (e2) => {
    var r2, t3, n;
    return $n(e2) ? _t(e2) ? (r2 = (t3 = (n = e2[ke]()).getSelectionKeys) == null ? undefined : t3.call(n)) != null ? r2 : [] : Array.isArray(e2) ? qr(e2, Ve) : qr(Object.values(e2), Ve) : [];
  };
  var qr = (e2, r2) => e2.reduce((t3, n) => t3.concat(r2(n)), []);
  var xd = fe(k(function(e2) {
    return true;
  }));
  var er = (e2) => Object.assign(fe(e2), { startsWith: (r2) => {
    return er(B(e2, (t3 = r2, k((n) => Xe(n) && n.startsWith(t3)))));
    var t3;
  }, endsWith: (r2) => {
    return er(B(e2, (t3 = r2, k((n) => Xe(n) && n.endsWith(t3)))));
    var t3;
  }, minLength: (r2) => er(B(e2, ((t3) => k((n) => Xe(n) && n.length >= t3))(r2))), maxLength: (r2) => er(B(e2, ((t3) => k((n) => Xe(n) && n.length <= t3))(r2))), includes: (r2) => {
    return er(B(e2, (t3 = r2, k((n) => Xe(n) && n.includes(t3)))));
    var t3;
  }, regex: (r2) => {
    return er(B(e2, (t3 = r2, k((n) => Xe(n) && !!n.match(t3)))));
    var t3;
  } });
  var Pd = er(k(Xe));
  var be = (e2) => Object.assign(fe(e2), { between: (r2, t3) => be(B(e2, ((n, i) => k((o) => Ee(o) && n <= o && i >= o))(r2, t3))), lt: (r2) => be(B(e2, ((t3) => k((n) => Ee(n) && n < t3))(r2))), gt: (r2) => be(B(e2, ((t3) => k((n) => Ee(n) && n > t3))(r2))), lte: (r2) => be(B(e2, ((t3) => k((n) => Ee(n) && n <= t3))(r2))), gte: (r2) => be(B(e2, ((t3) => k((n) => Ee(n) && n >= t3))(r2))), int: () => be(B(e2, k((r2) => Ee(r2) && Number.isInteger(r2)))), finite: () => be(B(e2, k((r2) => Ee(r2) && Number.isFinite(r2)))), positive: () => be(B(e2, k((r2) => Ee(r2) && r2 > 0))), negative: () => be(B(e2, k((r2) => Ee(r2) && r2 < 0))) });
  var vd = be(k(Ee));
  var Be = (e2) => Object.assign(fe(e2), { between: (r2, t3) => Be(B(e2, ((n, i) => k((o) => qe(o) && n <= o && i >= o))(r2, t3))), lt: (r2) => Be(B(e2, ((t3) => k((n) => qe(n) && n < t3))(r2))), gt: (r2) => Be(B(e2, ((t3) => k((n) => qe(n) && n > t3))(r2))), lte: (r2) => Be(B(e2, ((t3) => k((n) => qe(n) && n <= t3))(r2))), gte: (r2) => Be(B(e2, ((t3) => k((n) => qe(n) && n >= t3))(r2))), positive: () => Be(B(e2, k((r2) => qe(r2) && r2 > 0))), negative: () => Be(B(e2, k((r2) => qe(r2) && r2 < 0))) });
  var Td = Be(k(qe));
  var Cd = fe(k(function(e2) {
    return typeof e2 == "boolean";
  }));
  var Rd = fe(k(function(e2) {
    return typeof e2 == "symbol";
  }));
  var Sd = fe(k(function(e2) {
    return e2 == null;
  }));
  var qn = { matched: false, value: undefined };
  var Bn = class e2 {
    constructor(r2, t3) {
      this.input = undefined, this.state = undefined, this.input = r2, this.state = t3;
    }
    with(...r2) {
      if (this.state.matched)
        return this;
      let t3 = r2[r2.length - 1], n = [r2[0]], i;
      r2.length === 3 && typeof r2[1] == "function" ? i = r2[1] : r2.length > 2 && n.push(...r2.slice(1, r2.length - 1));
      let o = false, s = {}, a2 = (u, c) => {
        o = true, s[u] = c;
      }, l = !n.some((u) => we(u, this.input, a2)) || i && !i(this.input) ? qn : { matched: true, value: t3(o ? kt in s ? s[kt] : s : this.input, this.input) };
      return new e2(this.input, l);
    }
    when(r2, t3) {
      if (this.state.matched)
        return this;
      let n = !!r2(this.input);
      return new e2(this.input, n ? { matched: true, value: t3(this.input, this.input) } : qn);
    }
    otherwise(r2) {
      return this.state.matched ? this.state.value : r2(this.input);
    }
    exhaustive() {
      if (this.state.matched)
        return this.state.value;
      let r2;
      try {
        r2 = JSON.stringify(this.input);
      } catch {
        r2 = this.input;
      }
      throw new Error(`Pattern matching error: no pattern matches value ${r2}`);
    }
    run() {
      return this.exhaustive();
    }
    returnType() {
      return this;
    }
  };
  var Po = import.meta.require("util");
  var mu = { warn: de("prisma:warn") };
  var du = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var fu = (0, Po.promisify)(xo.default.exec);
  var te = N("prisma:get-platform");
  var gu = ["1.0.x", "1.1.x", "3.0.x"];
  var Lt = {};
  var $o = _(Mo());
  var Zn = _(Vo());
  var qt = _(import.meta.require("fs"));
  var gr = _(import.meta.require("path"));
  var Yn = N("prisma:tryLoadEnv");
  var Go = "library";
  var Qu = _(ei());
  var M = _(import.meta.require("path"));
  var Gu = _(ei());
  var hf = N("prisma:engines");
  var yf = "libquery-engine";
  M.default.join(__dirname, "../query-engine-darwin");
  M.default.join(__dirname, "../query-engine-darwin-arm64");
  M.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
  M.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
  M.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
  M.default.join(__dirname, "../query-engine-linux-static-x64");
  M.default.join(__dirname, "../query-engine-linux-static-arm64");
  M.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
  M.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
  M.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
  M.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
  M.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
  M.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
  M.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
  M.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
  M.default.join(__dirname, "../query_engine-windows.dll.node");
  var ri = _(import.meta.require("fs"));
  var Yo = N("chmodPlusX");
  var De;
  ((r2) => {
    let e2;
    ((E) => (E.findUnique = "findUnique", E.findUniqueOrThrow = "findUniqueOrThrow", E.findFirst = "findFirst", E.findFirstOrThrow = "findFirstOrThrow", E.findMany = "findMany", E.create = "create", E.createMany = "createMany", E.update = "update", E.updateMany = "updateMany", E.upsert = "upsert", E.delete = "delete", E.deleteMany = "deleteMany", E.groupBy = "groupBy", E.count = "count", E.aggregate = "aggregate", E.findRaw = "findRaw", E.aggregateRaw = "aggregateRaw"))(e2 = r2.ModelAction || (r2.ModelAction = {}));
  })(De || (De = {}));
  var Qr = _(import.meta.require("path"));
  var Xo = _(oi());
  var si = class {
    constructor(r2) {
      this.config = r2;
    }
    toString() {
      let { config: r2 } = this, t3 = r2.provider.fromEnvVar ? `env("${r2.provider.fromEnvVar}")` : r2.provider.value, n = JSON.parse(JSON.stringify({ provider: t3, binaryTargets: Ju(r2.binaryTargets) }));
      return `generator ${r2.name} {
${(0, Xo.default)(Hu(n), 2)}
}`;
    }
  };
  var Jr = {};
  Or2(Jr, { error: () => Yu, info: () => zu, log: () => Ku, query: () => Zu, should: () => es, tags: () => Gr, warn: () => li });
  var Gr = { error: ce("prisma:error"), warn: de("prisma:warn"), info: _e("prisma:info"), query: Ze("prisma:query") };
  var es = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var pi = (e2, r2) => e2.reduce((t3, n) => (t3[r2(n)] = n, t3), {});
  var os = new Set;
  var Hr = (e2, r2, ...t3) => {
    os.has(e2) || (os.add(e2), li(r2, ...t3));
  };
  var V = class extends Error {
    constructor(r2, { code: t3, clientVersion: n, meta: i, batchRequestIdx: o }) {
      super(r2), this.name = "PrismaClientKnownRequestError", this.code = t3, this.clientVersion = n, this.meta = i, Object.defineProperty(this, "batchRequestIdx", { value: o, enumerable: false, writable: true });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
  w(V, "PrismaClientKnownRequestError");
  var Le = class extends V {
    constructor(r2, t3) {
      super(r2, { code: "P2025", clientVersion: t3 }), this.name = "NotFoundError";
    }
  };
  w(Le, "NotFoundError");
  var R = class e2 extends Error {
    constructor(r2, t3, n) {
      super(r2), this.name = "PrismaClientInitializationError", this.clientVersion = t3, this.errorCode = n, Error.captureStackTrace(e2);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
  w(R, "PrismaClientInitializationError");
  var ue = class extends Error {
    constructor(r2, t3) {
      super(r2), this.name = "PrismaClientRustPanicError", this.clientVersion = t3;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  w(ue, "PrismaClientRustPanicError");
  var j = class extends Error {
    constructor(r2, { clientVersion: t3, batchRequestIdx: n }) {
      super(r2), this.name = "PrismaClientUnknownRequestError", this.clientVersion = t3, Object.defineProperty(this, "batchRequestIdx", { value: n, writable: true, enumerable: false });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
  w(j, "PrismaClientUnknownRequestError");
  var K = class extends Error {
    constructor(t3, { clientVersion: n }) {
      super(t3);
      this.name = "PrismaClientValidationError";
      this.clientVersion = n;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientValidationError";
    }
  };
  w(K, "PrismaClientValidationError");
  var yr = class {
    constructor(r2) {
      this._engine = r2;
    }
    prometheus(r2) {
      return this._engine.metrics({ format: "prometheus", ...r2 });
    }
    json(r2) {
      return this._engine.metrics({ format: "json", ...r2 });
    }
  };
  var Qt = Symbol();
  var fi = new WeakMap;
  var Ne = class {
    constructor(r2) {
      r2 === Qt ? fi.set(this, `Prisma.${this._getName()}`) : fi.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
    }
    _getName() {
      return this.constructor.name;
    }
    toString() {
      return fi.get(this);
    }
  };
  var Kr = class extends Ne {
    _getNamespace() {
      return "NullTypes";
    }
  };
  var zr = class extends Kr {
  };
  gi(zr, "DbNull");
  var Yr = class extends Kr {
  };
  gi(Yr, "JsonNull");
  var Zr = class extends Kr {
  };
  gi(Zr, "AnyNull");
  var Gt = { classes: { DbNull: zr, JsonNull: Yr, AnyNull: Zr }, instances: { DbNull: new zr(Qt), JsonNull: new Yr(Qt), AnyNull: new Zr(Qt) } };
  var hi = class {
    constructor() {
      this.registeredErrors = [];
    }
    consumeError(r2) {
      return this.registeredErrors[r2];
    }
    registerNewError(r2) {
      let t3 = 0;
      for (;this.registeredErrors[t3] !== undefined; )
        t3++;
      return this.registeredErrors[t3] = { error: r2 }, t3;
    }
  };
  var yi = (e2) => {
    let r2 = new hi, t3 = nr(r2, e2.startTransaction.bind(e2)), n = { adapterName: e2.adapterName, errorRegistry: r2, queryRaw: nr(r2, e2.queryRaw.bind(e2)), executeRaw: nr(r2, e2.executeRaw.bind(e2)), provider: e2.provider, startTransaction: async (...i) => (await t3(...i)).map((s) => rc(r2, s)) };
    return e2.getConnectionInfo && (n.getConnectionInfo = tc(r2, e2.getConnectionInfo.bind(e2))), n;
  };
  var rc = (e2, r2) => ({ adapterName: r2.adapterName, provider: r2.provider, options: r2.options, queryRaw: nr(e2, r2.queryRaw.bind(r2)), executeRaw: nr(e2, r2.executeRaw.bind(r2)), commit: nr(e2, r2.commit.bind(r2)), rollback: nr(e2, r2.rollback.bind(r2)) });
  var Il = _(Xn());
  var _l = import.meta.require("async_hooks");
  var kl = import.meta.require("events");
  var Dl = _(import.meta.require("fs"));
  var Tt = _(import.meta.require("path"));
  var oe = class e2 {
    constructor(r2, t3) {
      if (r2.length - 1 !== t3.length)
        throw r2.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${r2.length} strings to have ${r2.length - 1} values`);
      let n = t3.reduce((s, a2) => s + (a2 instanceof e2 ? a2.values.length : 1), 0);
      this.values = new Array(n), this.strings = new Array(n + 1), this.strings[0] = r2[0];
      let i = 0, o = 0;
      for (;i < t3.length; ) {
        let s = t3[i++], a2 = r2[i];
        if (s instanceof e2) {
          this.strings[o] += s.strings[0];
          let l = 0;
          for (;l < s.values.length; )
            this.values[o++] = s.values[l++], this.strings[o] = s.strings[l];
          this.strings[o] += a2;
        } else
          this.values[o++] = s, this.strings[o] = a2;
      }
    }
    get text() {
      let r2 = this.strings.length, t3 = 1, n = this.strings[0];
      for (;t3 < r2; )
        n += `\$${t3}${this.strings[t3++]}`;
      return n;
    }
    get sql() {
      let r2 = this.strings.length, t3 = 1, n = this.strings[0];
      for (;t3 < r2; )
        n += `?${this.strings[t3++]}`;
      return n;
    }
    get statement() {
      let r2 = this.strings.length, t3 = 1, n = this.strings[0];
      for (;t3 < r2; )
        n += `:${t3}${this.strings[t3++]}`;
      return n;
    }
    inspect() {
      return { text: this.text, sql: this.sql, values: this.values };
    }
  };
  var ls = Ei("");
  var xe = class {
    constructor() {
      this._map = new Map;
    }
    get(r2) {
      return this._map.get(r2)?.value;
    }
    set(r2, t3) {
      this._map.set(r2, { value: t3 });
    }
    getOrCreate(r2, t3) {
      let n = this._map.get(r2);
      if (n)
        return n.value;
      let i = t3();
      return this.set(r2, i), i;
    }
  };
  var Jt = { enumerable: true, configurable: true, writable: true };
  var us = Symbol.for("nodejs.util.inspect.custom");
  var br = class {
    constructor(r2 = 0, t3) {
      this.context = t3;
      this.lines = [];
      this.currentLine = "";
      this.currentIndent = 0;
      this.currentIndent = r2;
    }
    write(r2) {
      return typeof r2 == "string" ? this.currentLine += r2 : r2.write(this), this;
    }
    writeJoined(r2, t3) {
      let n = t3.length - 1;
      for (let i = 0;i < t3.length; i++)
        this.write(t3[i]), i !== n && this.write(r2);
      return this;
    }
    writeLine(r2) {
      return this.write(r2).newLine();
    }
    newLine() {
      this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = undefined;
      let r2 = this.afterNextNewLineCallback;
      return this.afterNextNewLineCallback = undefined, r2?.(), this;
    }
    withIndent(r2) {
      return this.indent(), r2(this), this.unindent(), this;
    }
    afterNextNewline(r2) {
      return this.afterNextNewLineCallback = r2, this;
    }
    indent() {
      return this.currentIndent++, this;
    }
    unindent() {
      return this.currentIndent > 0 && this.currentIndent--, this;
    }
    addMarginSymbol(r2) {
      return this.marginSymbol = r2, this;
    }
    toString() {
      return this.lines.concat(this.indentedCurrentLine()).join(`
`);
    }
    getCurrentLineLength() {
      return this.currentLine.length;
    }
    indentedCurrentLine() {
      let r2 = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
      return this.marginSymbol ? this.marginSymbol + r2.slice(1) : r2;
    }
  };
  var xr = 9000000000000000;
  var Je = 1e9;
  var wi = "0123456789abcdef";
  var zt = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var Yt = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var xi = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -xr, maxE: xr, crypto: false };
  var gs;
  var Oe;
  var x = true;
  var Xt = "[DecimalError] ";
  var Ge = Xt + "Invalid argument: ";
  var hs = Xt + "Precision limit exceeded";
  var ys = Xt + "crypto unavailable";
  var Es = "[object Decimal]";
  var re = Math.floor;
  var Q = Math.pow;
  var ic = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var oc = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var sc = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var bs = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var he = 1e7;
  var b = 7;
  var ac = 9007199254740991;
  var lc = zt.length - 1;
  var Pi = Yt.length - 1;
  var d = { toStringTag: Es };
  d.absoluteValue = d.abs = function() {
    var e2 = new this.constructor(this);
    return e2.s < 0 && (e2.s = 1), y(e2);
  };
  d.ceil = function() {
    return y(new this.constructor(this), this.e + 1, 2);
  };
  d.clampedTo = d.clamp = function(e2, r2) {
    var t3, n = this, i = n.constructor;
    if (e2 = new i(e2), r2 = new i(r2), !e2.s || !r2.s)
      return new i(NaN);
    if (e2.gt(r2))
      throw Error(Ge + r2);
    return t3 = n.cmp(e2), t3 < 0 ? e2 : n.cmp(r2) > 0 ? r2 : new i(n);
  };
  d.comparedTo = d.cmp = function(e2) {
    var r2, t3, n, i, o = this, s = o.d, a2 = (e2 = new o.constructor(e2)).d, l = o.s, u = e2.s;
    if (!s || !a2)
      return !l || !u ? NaN : l !== u ? l : s === a2 ? 0 : !s ^ l < 0 ? 1 : -1;
    if (!s[0] || !a2[0])
      return s[0] ? l : a2[0] ? -u : 0;
    if (l !== u)
      return l;
    if (o.e !== e2.e)
      return o.e > e2.e ^ l < 0 ? 1 : -1;
    for (n = s.length, i = a2.length, r2 = 0, t3 = n < i ? n : i;r2 < t3; ++r2)
      if (s[r2] !== a2[r2])
        return s[r2] > a2[r2] ^ l < 0 ? 1 : -1;
    return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
  };
  d.cosine = d.cos = function() {
    var e2, r2, t3 = this, n = t3.constructor;
    return t3.d ? t3.d[0] ? (e2 = n.precision, r2 = n.rounding, n.precision = e2 + Math.max(t3.e, t3.sd()) + b, n.rounding = 1, t3 = uc(n, Ts(n, t3)), n.precision = e2, n.rounding = r2, y(Oe == 2 || Oe == 3 ? t3.neg() : t3, e2, r2, true)) : new n(1) : new n(NaN);
  };
  d.cubeRoot = d.cbrt = function() {
    var e2, r2, t3, n, i, o, s, a2, l, u, c = this, p = c.constructor;
    if (!c.isFinite() || c.isZero())
      return new p(c);
    for (x = false, o = c.s * Q(c.s * c, 1 / 3), !o || Math.abs(o) == 1 / 0 ? (t3 = z2(c.d), e2 = c.e, (o = (e2 - t3.length + 1) % 3) && (t3 += o == 1 || o == -2 ? "0" : "00"), o = Q(t3, 1 / 3), e2 = re((e2 + 1) / 3) - (e2 % 3 == (e2 < 0 ? -1 : 2)), o == 1 / 0 ? t3 = "5e" + e2 : (t3 = o.toExponential(), t3 = t3.slice(0, t3.indexOf("e") + 1) + e2), n = new p(t3), n.s = c.s) : n = new p(o.toString()), s = (e2 = p.precision) + 3;; )
      if (a2 = n, l = a2.times(a2).times(a2), u = l.plus(c), n = O(u.plus(c).times(a2), u.plus(l), s + 2, 1), z2(a2.d).slice(0, s) === (t3 = z2(n.d)).slice(0, s))
        if (t3 = t3.slice(s - 3, s + 1), t3 == "9999" || !i && t3 == "4999") {
          if (!i && (y(a2, e2 + 1, 0), a2.times(a2).times(a2).eq(c))) {
            n = a2;
            break;
          }
          s += 4, i = 1;
        } else {
          (!+t3 || !+t3.slice(1) && t3.charAt(0) == "5") && (y(n, e2 + 1, 1), r2 = !n.times(n).times(n).eq(c));
          break;
        }
    return x = true, y(n, e2, p.rounding, r2);
  };
  d.decimalPlaces = d.dp = function() {
    var e2, r2 = this.d, t3 = NaN;
    if (r2) {
      if (e2 = r2.length - 1, t3 = (e2 - re(this.e / b)) * b, e2 = r2[e2], e2)
        for (;e2 % 10 == 0; e2 /= 10)
          t3--;
      t3 < 0 && (t3 = 0);
    }
    return t3;
  };
  d.dividedBy = d.div = function(e2) {
    return O(this, new this.constructor(e2));
  };
  d.dividedToIntegerBy = d.divToInt = function(e2) {
    var r2 = this, t3 = r2.constructor;
    return y(O(r2, new t3(e2), 0, 1, 1), t3.precision, t3.rounding);
  };
  d.equals = d.eq = function(e2) {
    return this.cmp(e2) === 0;
  };
  d.floor = function() {
    return y(new this.constructor(this), this.e + 1, 3);
  };
  d.greaterThan = d.gt = function(e2) {
    return this.cmp(e2) > 0;
  };
  d.greaterThanOrEqualTo = d.gte = function(e2) {
    var r2 = this.cmp(e2);
    return r2 == 1 || r2 === 0;
  };
  d.hyperbolicCosine = d.cosh = function() {
    var e2, r2, t3, n, i, o = this, s = o.constructor, a2 = new s(1);
    if (!o.isFinite())
      return new s(o.s ? 1 / 0 : NaN);
    if (o.isZero())
      return a2;
    t3 = s.precision, n = s.rounding, s.precision = t3 + Math.max(o.e, o.sd()) + 4, s.rounding = 1, i = o.d.length, i < 32 ? (e2 = Math.ceil(i / 3), r2 = (1 / rn(4, e2)).toString()) : (e2 = 16, r2 = "2.3283064365386962890625e-10"), o = Pr(s, 1, o.times(r2), new s(1), true);
    for (var l, u = e2, c = new s(8);u--; )
      l = o.times(o), o = a2.minus(l.times(c.minus(l.times(c))));
    return y(o, s.precision = t3, s.rounding = n, true);
  };
  d.hyperbolicSine = d.sinh = function() {
    var e2, r2, t3, n, i = this, o = i.constructor;
    if (!i.isFinite() || i.isZero())
      return new o(i);
    if (r2 = o.precision, t3 = o.rounding, o.precision = r2 + Math.max(i.e, i.sd()) + 4, o.rounding = 1, n = i.d.length, n < 3)
      i = Pr(o, 2, i, i, true);
    else {
      e2 = 1.4 * Math.sqrt(n), e2 = e2 > 16 ? 16 : e2 | 0, i = i.times(1 / rn(5, e2)), i = Pr(o, 2, i, i, true);
      for (var s, a2 = new o(5), l = new o(16), u = new o(20);e2--; )
        s = i.times(i), i = i.times(a2.plus(s.times(l.times(s).plus(u))));
    }
    return o.precision = r2, o.rounding = t3, y(i, r2, t3, true);
  };
  d.hyperbolicTangent = d.tanh = function() {
    var e2, r2, t3 = this, n = t3.constructor;
    return t3.isFinite() ? t3.isZero() ? new n(t3) : (e2 = n.precision, r2 = n.rounding, n.precision = e2 + 7, n.rounding = 1, O(t3.sinh(), t3.cosh(), n.precision = e2, n.rounding = r2)) : new n(t3.s);
  };
  d.inverseCosine = d.acos = function() {
    var e2, r2 = this, t3 = r2.constructor, n = r2.abs().cmp(1), i = t3.precision, o = t3.rounding;
    return n !== -1 ? n === 0 ? r2.isNeg() ? ge(t3, i, o) : new t3(0) : new t3(NaN) : r2.isZero() ? ge(t3, i + 4, o).times(0.5) : (t3.precision = i + 6, t3.rounding = 1, r2 = r2.asin(), e2 = ge(t3, i + 4, o).times(0.5), t3.precision = i, t3.rounding = o, e2.minus(r2));
  };
  d.inverseHyperbolicCosine = d.acosh = function() {
    var e2, r2, t3 = this, n = t3.constructor;
    return t3.lte(1) ? new n(t3.eq(1) ? 0 : NaN) : t3.isFinite() ? (e2 = n.precision, r2 = n.rounding, n.precision = e2 + Math.max(Math.abs(t3.e), t3.sd()) + 4, n.rounding = 1, x = false, t3 = t3.times(t3).minus(1).sqrt().plus(t3), x = true, n.precision = e2, n.rounding = r2, t3.ln()) : new n(t3);
  };
  d.inverseHyperbolicSine = d.asinh = function() {
    var e2, r2, t3 = this, n = t3.constructor;
    return !t3.isFinite() || t3.isZero() ? new n(t3) : (e2 = n.precision, r2 = n.rounding, n.precision = e2 + 2 * Math.max(Math.abs(t3.e), t3.sd()) + 6, n.rounding = 1, x = false, t3 = t3.times(t3).plus(1).sqrt().plus(t3), x = true, n.precision = e2, n.rounding = r2, t3.ln());
  };
  d.inverseHyperbolicTangent = d.atanh = function() {
    var e2, r2, t3, n, i = this, o = i.constructor;
    return i.isFinite() ? i.e >= 0 ? new o(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e2 = o.precision, r2 = o.rounding, n = i.sd(), Math.max(n, e2) < 2 * -i.e - 1 ? y(new o(i), e2, r2, true) : (o.precision = t3 = n - i.e, i = O(i.plus(1), new o(1).minus(i), t3 + e2, 1), o.precision = e2 + 4, o.rounding = 1, i = i.ln(), o.precision = e2, o.rounding = r2, i.times(0.5))) : new o(NaN);
  };
  d.inverseSine = d.asin = function() {
    var e2, r2, t3, n, i = this, o = i.constructor;
    return i.isZero() ? new o(i) : (r2 = i.abs().cmp(1), t3 = o.precision, n = o.rounding, r2 !== -1 ? r2 === 0 ? (e2 = ge(o, t3 + 4, n).times(0.5), e2.s = i.s, e2) : new o(NaN) : (o.precision = t3 + 6, o.rounding = 1, i = i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(), o.precision = t3, o.rounding = n, i.times(2)));
  };
  d.inverseTangent = d.atan = function() {
    var e2, r2, t3, n, i, o, s, a2, l, u = this, c = u.constructor, p = c.precision, m = c.rounding;
    if (u.isFinite()) {
      if (u.isZero())
        return new c(u);
      if (u.abs().eq(1) && p + 4 <= Pi)
        return s = ge(c, p + 4, m).times(0.25), s.s = u.s, s;
    } else {
      if (!u.s)
        return new c(NaN);
      if (p + 4 <= Pi)
        return s = ge(c, p + 4, m).times(0.5), s.s = u.s, s;
    }
    for (c.precision = a2 = p + 10, c.rounding = 1, t3 = Math.min(28, a2 / b + 2 | 0), e2 = t3;e2; --e2)
      u = u.div(u.times(u).plus(1).sqrt().plus(1));
    for (x = false, r2 = Math.ceil(a2 / b), n = 1, l = u.times(u), s = new c(u), i = u;e2 !== -1; )
      if (i = i.times(l), o = s.minus(i.div(n += 2)), i = i.times(l), s = o.plus(i.div(n += 2)), s.d[r2] !== undefined)
        for (e2 = r2;s.d[e2] === o.d[e2] && e2--; )
          ;
    return t3 && (s = s.times(2 << t3 - 1)), x = true, y(s, c.precision = p, c.rounding = m, true);
  };
  d.isFinite = function() {
    return !!this.d;
  };
  d.isInteger = d.isInt = function() {
    return !!this.d && re(this.e / b) > this.d.length - 2;
  };
  d.isNaN = function() {
    return !this.s;
  };
  d.isNegative = d.isNeg = function() {
    return this.s < 0;
  };
  d.isPositive = d.isPos = function() {
    return this.s > 0;
  };
  d.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  d.lessThan = d.lt = function(e2) {
    return this.cmp(e2) < 0;
  };
  d.lessThanOrEqualTo = d.lte = function(e2) {
    return this.cmp(e2) < 1;
  };
  d.logarithm = d.log = function(e2) {
    var r2, t3, n, i, o, s, a2, l, u = this, c = u.constructor, p = c.precision, m = c.rounding, f = 5;
    if (e2 == null)
      e2 = new c(10), r2 = true;
    else {
      if (e2 = new c(e2), t3 = e2.d, e2.s < 0 || !t3 || !t3[0] || e2.eq(1))
        return new c(NaN);
      r2 = e2.eq(10);
    }
    if (t3 = u.d, u.s < 0 || !t3 || !t3[0] || u.eq(1))
      return new c(t3 && !t3[0] ? -1 / 0 : u.s != 1 ? NaN : t3 ? 0 : 1 / 0);
    if (r2)
      if (t3.length > 1)
        o = true;
      else {
        for (i = t3[0];i % 10 === 0; )
          i /= 10;
        o = i !== 1;
      }
    if (x = false, a2 = p + f, s = Qe(u, a2), n = r2 ? Zt(c, a2 + 10) : Qe(e2, a2), l = O(s, n, a2, 1), tt(l.d, i = p, m))
      do
        if (a2 += 10, s = Qe(u, a2), n = r2 ? Zt(c, a2 + 10) : Qe(e2, a2), l = O(s, n, a2, 1), !o) {
          +z2(l.d).slice(i + 1, i + 15) + 1 == 100000000000000 && (l = y(l, p + 1, 0));
          break;
        }
      while (tt(l.d, i += 10, m));
    return x = true, y(l, p, m);
  };
  d.minus = d.sub = function(e2) {
    var r2, t3, n, i, o, s, a2, l, u, c, p, m, f = this, g = f.constructor;
    if (e2 = new g(e2), !f.d || !e2.d)
      return !f.s || !e2.s ? e2 = new g(NaN) : f.d ? e2.s = -e2.s : e2 = new g(e2.d || f.s !== e2.s ? f : NaN), e2;
    if (f.s != e2.s)
      return e2.s = -e2.s, f.plus(e2);
    if (u = f.d, m = e2.d, a2 = g.precision, l = g.rounding, !u[0] || !m[0]) {
      if (m[0])
        e2.s = -e2.s;
      else if (u[0])
        e2 = new g(f);
      else
        return new g(l === 3 ? -0 : 0);
      return x ? y(e2, a2, l) : e2;
    }
    if (t3 = re(e2.e / b), c = re(f.e / b), u = u.slice(), o = c - t3, o) {
      for (p = o < 0, p ? (r2 = u, o = -o, s = m.length) : (r2 = m, t3 = c, s = u.length), n = Math.max(Math.ceil(a2 / b), s) + 2, o > n && (o = n, r2.length = 1), r2.reverse(), n = o;n--; )
        r2.push(0);
      r2.reverse();
    } else {
      for (n = u.length, s = m.length, p = n < s, p && (s = n), n = 0;n < s; n++)
        if (u[n] != m[n]) {
          p = u[n] < m[n];
          break;
        }
      o = 0;
    }
    for (p && (r2 = u, u = m, m = r2, e2.s = -e2.s), s = u.length, n = m.length - s;n > 0; --n)
      u[s++] = 0;
    for (n = m.length;n > o; ) {
      if (u[--n] < m[n]) {
        for (i = n;i && u[--i] === 0; )
          u[i] = he - 1;
        --u[i], u[n] += he;
      }
      u[n] -= m[n];
    }
    for (;u[--s] === 0; )
      u.pop();
    for (;u[0] === 0; u.shift())
      --t3;
    return u[0] ? (e2.d = u, e2.e = en(u, t3), x ? y(e2, a2, l) : e2) : new g(l === 3 ? -0 : 0);
  };
  d.modulo = d.mod = function(e2) {
    var r2, t3 = this, n = t3.constructor;
    return e2 = new n(e2), !t3.d || !e2.s || e2.d && !e2.d[0] ? new n(NaN) : !e2.d || t3.d && !t3.d[0] ? y(new n(t3), n.precision, n.rounding) : (x = false, n.modulo == 9 ? (r2 = O(t3, e2.abs(), 0, 3, 1), r2.s *= e2.s) : r2 = O(t3, e2, 0, n.modulo, 1), r2 = r2.times(e2), x = true, t3.minus(r2));
  };
  d.naturalExponential = d.exp = function() {
    return vi(this);
  };
  d.naturalLogarithm = d.ln = function() {
    return Qe(this);
  };
  d.negated = d.neg = function() {
    var e2 = new this.constructor(this);
    return e2.s = -e2.s, y(e2);
  };
  d.plus = d.add = function(e2) {
    var r2, t3, n, i, o, s, a2, l, u, c, p = this, m = p.constructor;
    if (e2 = new m(e2), !p.d || !e2.d)
      return !p.s || !e2.s ? e2 = new m(NaN) : p.d || (e2 = new m(e2.d || p.s === e2.s ? p : NaN)), e2;
    if (p.s != e2.s)
      return e2.s = -e2.s, p.minus(e2);
    if (u = p.d, c = e2.d, a2 = m.precision, l = m.rounding, !u[0] || !c[0])
      return c[0] || (e2 = new m(p)), x ? y(e2, a2, l) : e2;
    if (o = re(p.e / b), n = re(e2.e / b), u = u.slice(), i = o - n, i) {
      for (i < 0 ? (t3 = u, i = -i, s = c.length) : (t3 = c, n = o, s = u.length), o = Math.ceil(a2 / b), s = o > s ? o + 1 : s + 1, i > s && (i = s, t3.length = 1), t3.reverse();i--; )
        t3.push(0);
      t3.reverse();
    }
    for (s = u.length, i = c.length, s - i < 0 && (i = s, t3 = c, c = u, u = t3), r2 = 0;i; )
      r2 = (u[--i] = u[i] + c[i] + r2) / he | 0, u[i] %= he;
    for (r2 && (u.unshift(r2), ++n), s = u.length;u[--s] == 0; )
      u.pop();
    return e2.d = u, e2.e = en(u, n), x ? y(e2, a2, l) : e2;
  };
  d.precision = d.sd = function(e2) {
    var r2, t3 = this;
    if (e2 !== undefined && e2 !== !!e2 && e2 !== 1 && e2 !== 0)
      throw Error(Ge + e2);
    return t3.d ? (r2 = ws(t3.d), e2 && t3.e + 1 > r2 && (r2 = t3.e + 1)) : r2 = NaN, r2;
  };
  d.round = function() {
    var e2 = this, r2 = e2.constructor;
    return y(new r2(e2), e2.e + 1, r2.rounding);
  };
  d.sine = d.sin = function() {
    var e2, r2, t3 = this, n = t3.constructor;
    return t3.isFinite() ? t3.isZero() ? new n(t3) : (e2 = n.precision, r2 = n.rounding, n.precision = e2 + Math.max(t3.e, t3.sd()) + b, n.rounding = 1, t3 = pc(n, Ts(n, t3)), n.precision = e2, n.rounding = r2, y(Oe > 2 ? t3.neg() : t3, e2, r2, true)) : new n(NaN);
  };
  d.squareRoot = d.sqrt = function() {
    var e2, r2, t3, n, i, o, s = this, a2 = s.d, l = s.e, u = s.s, c = s.constructor;
    if (u !== 1 || !a2 || !a2[0])
      return new c(!u || u < 0 && (!a2 || a2[0]) ? NaN : a2 ? s : 1 / 0);
    for (x = false, u = Math.sqrt(+s), u == 0 || u == 1 / 0 ? (r2 = z2(a2), (r2.length + l) % 2 == 0 && (r2 += "0"), u = Math.sqrt(r2), l = re((l + 1) / 2) - (l < 0 || l % 2), u == 1 / 0 ? r2 = "5e" + l : (r2 = u.toExponential(), r2 = r2.slice(0, r2.indexOf("e") + 1) + l), n = new c(r2)) : n = new c(u.toString()), t3 = (l = c.precision) + 3;; )
      if (o = n, n = o.plus(O(s, o, t3 + 2, 1)).times(0.5), z2(o.d).slice(0, t3) === (r2 = z2(n.d)).slice(0, t3))
        if (r2 = r2.slice(t3 - 3, t3 + 1), r2 == "9999" || !i && r2 == "4999") {
          if (!i && (y(o, l + 1, 0), o.times(o).eq(s))) {
            n = o;
            break;
          }
          t3 += 4, i = 1;
        } else {
          (!+r2 || !+r2.slice(1) && r2.charAt(0) == "5") && (y(n, l + 1, 1), e2 = !n.times(n).eq(s));
          break;
        }
    return x = true, y(n, l, c.rounding, e2);
  };
  d.tangent = d.tan = function() {
    var e2, r2, t3 = this, n = t3.constructor;
    return t3.isFinite() ? t3.isZero() ? new n(t3) : (e2 = n.precision, r2 = n.rounding, n.precision = e2 + 10, n.rounding = 1, t3 = t3.sin(), t3.s = 1, t3 = O(t3, new n(1).minus(t3.times(t3)).sqrt(), e2 + 10, 0), n.precision = e2, n.rounding = r2, y(Oe == 2 || Oe == 4 ? t3.neg() : t3, e2, r2, true)) : new n(NaN);
  };
  d.times = d.mul = function(e2) {
    var r2, t3, n, i, o, s, a2, l, u, c = this, p = c.constructor, m = c.d, f = (e2 = new p(e2)).d;
    if (e2.s *= c.s, !m || !m[0] || !f || !f[0])
      return new p(!e2.s || m && !m[0] && !f || f && !f[0] && !m ? NaN : !m || !f ? e2.s / 0 : e2.s * 0);
    for (t3 = re(c.e / b) + re(e2.e / b), l = m.length, u = f.length, l < u && (o = m, m = f, f = o, s = l, l = u, u = s), o = [], s = l + u, n = s;n--; )
      o.push(0);
    for (n = u;--n >= 0; ) {
      for (r2 = 0, i = l + n;i > n; )
        a2 = o[i] + f[n] * m[i - n - 1] + r2, o[i--] = a2 % he | 0, r2 = a2 / he | 0;
      o[i] = (o[i] + r2) % he | 0;
    }
    for (;!o[--s]; )
      o.pop();
    return r2 ? ++t3 : o.shift(), e2.d = o, e2.e = en(o, t3), x ? y(e2, p.precision, p.rounding) : e2;
  };
  d.toBinary = function(e2, r2) {
    return Ci(this, 2, e2, r2);
  };
  d.toDecimalPlaces = d.toDP = function(e2, r2) {
    var t3 = this, n = t3.constructor;
    return t3 = new n(t3), e2 === undefined ? t3 : (se(e2, 0, Je), r2 === undefined ? r2 = n.rounding : se(r2, 0, 8), y(t3, e2 + t3.e + 1, r2));
  };
  d.toExponential = function(e2, r2) {
    var t3, n = this, i = n.constructor;
    return e2 === undefined ? t3 = ve(n, true) : (se(e2, 0, Je), r2 === undefined ? r2 = i.rounding : se(r2, 0, 8), n = y(new i(n), e2 + 1, r2), t3 = ve(n, true, e2 + 1)), n.isNeg() && !n.isZero() ? "-" + t3 : t3;
  };
  d.toFixed = function(e2, r2) {
    var t3, n, i = this, o = i.constructor;
    return e2 === undefined ? t3 = ve(i) : (se(e2, 0, Je), r2 === undefined ? r2 = o.rounding : se(r2, 0, 8), n = y(new o(i), e2 + i.e + 1, r2), t3 = ve(n, false, e2 + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + t3 : t3;
  };
  d.toFraction = function(e2) {
    var r2, t3, n, i, o, s, a2, l, u, c, p, m, f = this, g = f.d, h = f.constructor;
    if (!g)
      return new h(f);
    if (u = t3 = new h(1), n = l = new h(0), r2 = new h(n), o = r2.e = ws(g) - f.e - 1, s = o % b, r2.d[0] = Q(10, s < 0 ? b + s : s), e2 == null)
      e2 = o > 0 ? r2 : u;
    else {
      if (a2 = new h(e2), !a2.isInt() || a2.lt(u))
        throw Error(Ge + a2);
      e2 = a2.gt(r2) ? o > 0 ? r2 : u : a2;
    }
    for (x = false, a2 = new h(z2(g)), c = h.precision, h.precision = o = g.length * b * 2;p = O(a2, r2, 0, 1, 1), i = t3.plus(p.times(n)), i.cmp(e2) != 1; )
      t3 = n, n = i, i = u, u = l.plus(p.times(i)), l = i, i = r2, r2 = a2.minus(p.times(i)), a2 = i;
    return i = O(e2.minus(t3), n, 0, 1, 1), l = l.plus(i.times(u)), t3 = t3.plus(i.times(n)), l.s = u.s = f.s, m = O(u, n, o, 1).minus(f).abs().cmp(O(l, t3, o, 1).minus(f).abs()) < 1 ? [u, n] : [l, t3], h.precision = c, x = true, m;
  };
  d.toHexadecimal = d.toHex = function(e2, r2) {
    return Ci(this, 16, e2, r2);
  };
  d.toNearest = function(e2, r2) {
    var t3 = this, n = t3.constructor;
    if (t3 = new n(t3), e2 == null) {
      if (!t3.d)
        return t3;
      e2 = new n(1), r2 = n.rounding;
    } else {
      if (e2 = new n(e2), r2 === undefined ? r2 = n.rounding : se(r2, 0, 8), !t3.d)
        return e2.s ? t3 : e2;
      if (!e2.d)
        return e2.s && (e2.s = t3.s), e2;
    }
    return e2.d[0] ? (x = false, t3 = O(t3, e2, 0, r2, 1).times(e2), x = true, y(t3)) : (e2.s = t3.s, t3 = e2), t3;
  };
  d.toNumber = function() {
    return +this;
  };
  d.toOctal = function(e2, r2) {
    return Ci(this, 8, e2, r2);
  };
  d.toPower = d.pow = function(e2) {
    var r2, t3, n, i, o, s, a2 = this, l = a2.constructor, u = +(e2 = new l(e2));
    if (!a2.d || !e2.d || !a2.d[0] || !e2.d[0])
      return new l(Q(+a2, u));
    if (a2 = new l(a2), a2.eq(1))
      return a2;
    if (n = l.precision, o = l.rounding, e2.eq(1))
      return y(a2, n, o);
    if (r2 = re(e2.e / b), r2 >= e2.d.length - 1 && (t3 = u < 0 ? -u : u) <= ac)
      return i = xs(l, a2, t3, n), e2.s < 0 ? new l(1).div(i) : y(i, n, o);
    if (s = a2.s, s < 0) {
      if (r2 < e2.d.length - 1)
        return new l(NaN);
      if (e2.d[r2] & 1 || (s = 1), a2.e == 0 && a2.d[0] == 1 && a2.d.length == 1)
        return a2.s = s, a2;
    }
    return t3 = Q(+a2, u), r2 = t3 == 0 || !isFinite(t3) ? re(u * (Math.log("0." + z2(a2.d)) / Math.LN10 + a2.e + 1)) : new l(t3 + "").e, r2 > l.maxE + 1 || r2 < l.minE - 1 ? new l(r2 > 0 ? s / 0 : 0) : (x = false, l.rounding = a2.s = 1, t3 = Math.min(12, (r2 + "").length), i = vi(e2.times(Qe(a2, n + t3)), n), i.d && (i = y(i, n + 5, 1), tt(i.d, n, o) && (r2 = n + 10, i = y(vi(e2.times(Qe(a2, r2 + t3)), r2), r2 + 5, 1), +z2(i.d).slice(n + 1, n + 15) + 1 == 100000000000000 && (i = y(i, n + 1, 0)))), i.s = s, x = true, l.rounding = o, y(i, n, o));
  };
  d.toPrecision = function(e2, r2) {
    var t3, n = this, i = n.constructor;
    return e2 === undefined ? t3 = ve(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (se(e2, 1, Je), r2 === undefined ? r2 = i.rounding : se(r2, 0, 8), n = y(new i(n), e2, r2), t3 = ve(n, e2 <= n.e || n.e <= i.toExpNeg, e2)), n.isNeg() && !n.isZero() ? "-" + t3 : t3;
  };
  d.toSignificantDigits = d.toSD = function(e2, r2) {
    var t3 = this, n = t3.constructor;
    return e2 === undefined ? (e2 = n.precision, r2 = n.rounding) : (se(e2, 1, Je), r2 === undefined ? r2 = n.rounding : se(r2, 0, 8)), y(new n(t3), e2, r2);
  };
  d.toString = function() {
    var e2 = this, r2 = e2.constructor, t3 = ve(e2, e2.e <= r2.toExpNeg || e2.e >= r2.toExpPos);
    return e2.isNeg() && !e2.isZero() ? "-" + t3 : t3;
  };
  d.truncated = d.trunc = function() {
    return y(new this.constructor(this), this.e + 1, 1);
  };
  d.valueOf = d.toJSON = function() {
    var e2 = this, r2 = e2.constructor, t3 = ve(e2, e2.e <= r2.toExpNeg || e2.e >= r2.toExpPos);
    return e2.isNeg() ? "-" + t3 : t3;
  };
  var O = function() {
    function e2(n, i, o) {
      var s, a2 = 0, l = n.length;
      for (n = n.slice();l--; )
        s = n[l] * i + a2, n[l] = s % o | 0, a2 = s / o | 0;
      return a2 && n.unshift(a2), n;
    }
    function r2(n, i, o, s) {
      var a2, l;
      if (o != s)
        l = o > s ? 1 : -1;
      else
        for (a2 = l = 0;a2 < o; a2++)
          if (n[a2] != i[a2]) {
            l = n[a2] > i[a2] ? 1 : -1;
            break;
          }
      return l;
    }
    function t3(n, i, o, s) {
      for (var a2 = 0;o--; )
        n[o] -= a2, a2 = n[o] < i[o] ? 1 : 0, n[o] = a2 * s + n[o] - i[o];
      for (;!n[0] && n.length > 1; )
        n.shift();
    }
    return function(n, i, o, s, a2, l) {
      var u, c, p, m, f, g, h, A, T, C, E, I, me, le, Nr, U, ie, Ae, Y, pr, Ct = n.constructor, _n = n.s == i.s ? 1 : -1, Z = n.d, L = i.d;
      if (!Z || !Z[0] || !L || !L[0])
        return new Ct(!n.s || !i.s || (Z ? L && Z[0] == L[0] : !L) ? NaN : Z && Z[0] == 0 || !L ? _n * 0 : _n / 0);
      for (l ? (f = 1, c = n.e - i.e) : (l = he, f = b, c = re(n.e / f) - re(i.e / f)), Y = L.length, ie = Z.length, T = new Ct(_n), C = T.d = [], p = 0;L[p] == (Z[p] || 0); p++)
        ;
      if (L[p] > (Z[p] || 0) && c--, o == null ? (le = o = Ct.precision, s = Ct.rounding) : a2 ? le = o + (n.e - i.e) + 1 : le = o, le < 0)
        C.push(1), g = true;
      else {
        if (le = le / f + 2 | 0, p = 0, Y == 1) {
          for (m = 0, L = L[0], le++;(p < ie || m) && le--; p++)
            Nr = m * l + (Z[p] || 0), C[p] = Nr / L | 0, m = Nr % L | 0;
          g = m || p < ie;
        } else {
          for (m = l / (L[0] + 1) | 0, m > 1 && (L = e2(L, m, l), Z = e2(Z, m, l), Y = L.length, ie = Z.length), U = Y, E = Z.slice(0, Y), I = E.length;I < Y; )
            E[I++] = 0;
          pr = L.slice(), pr.unshift(0), Ae = L[0], L[1] >= l / 2 && ++Ae;
          do
            m = 0, u = r2(L, E, Y, I), u < 0 ? (me = E[0], Y != I && (me = me * l + (E[1] || 0)), m = me / Ae | 0, m > 1 ? (m >= l && (m = l - 1), h = e2(L, m, l), A = h.length, I = E.length, u = r2(h, E, A, I), u == 1 && (m--, t3(h, Y < A ? pr : L, A, l))) : (m == 0 && (u = m = 1), h = L.slice()), A = h.length, A < I && h.unshift(0), t3(E, h, I, l), u == -1 && (I = E.length, u = r2(L, E, Y, I), u < 1 && (m++, t3(E, Y < I ? pr : L, I, l))), I = E.length) : u === 0 && (m++, E = [0]), C[p++] = m, u && E[0] ? E[I++] = Z[U] || 0 : (E = [Z[U]], I = 1);
          while ((U++ < ie || E[0] !== undefined) && le--);
          g = E[0] !== undefined;
        }
        C[0] || C.shift();
      }
      if (f == 1)
        T.e = c, gs = g;
      else {
        for (p = 1, m = C[0];m >= 10; m /= 10)
          p++;
        T.e = p + c * f - 1, y(T, a2 ? o + T.e + 1 : o, s, g);
      }
      return T;
    };
  }();
  d[Symbol.for("nodejs.util.inspect.custom")] = d.toString;
  d[Symbol.toStringTag] = "Decimal";
  var or = d.constructor = Cs(xi);
  zt = new or(zt);
  Yt = new or(Yt);
  var Te = or;
  var nt = class {
    constructor(r2, t3, n, i, o) {
      this.modelName = r2, this.name = t3, this.typeName = n, this.isList = i, this.isEnum = o;
    }
    _toGraphQLInputType() {
      let r2 = this.isList ? "List" : "", t3 = this.isEnum ? "Enum" : "";
      return `${r2}${t3}${this.typeName}FieldRefInput<${this.modelName}>`;
    }
  };
  var tn = class {
    constructor(r2) {
      this.value = r2;
    }
    write(r2) {
      r2.write(this.value);
    }
    markAsError() {
      this.value.markAsError();
    }
  };
  var nn = (e2) => e2;
  var on = { bold: nn, red: nn, green: nn, dim: nn, enabled: false };
  var Rs = { bold: W, red: ce, green: $e, dim: Ie, enabled: true };
  var Cr = { write(e2) {
    e2.writeLine(",");
  } };
  var Ce = class {
    constructor(r2) {
      this.contents = r2;
      this.isUnderlined = false;
      this.color = (r3) => r3;
    }
    underline() {
      return this.isUnderlined = true, this;
    }
    setColor(r2) {
      return this.color = r2, this;
    }
    write(r2) {
      let t3 = r2.getCurrentLineLength();
      r2.write(this.color(this.contents)), this.isUnderlined && r2.afterNextNewline(() => {
        r2.write(" ".repeat(t3)).writeLine(this.color("~".repeat(this.contents.length)));
      });
    }
  };
  var He = class {
    constructor() {
      this.hasError = false;
    }
    markAsError() {
      return this.hasError = true, this;
    }
  };
  var Rr = class extends He {
    constructor() {
      super(...arguments);
      this.items = [];
    }
    addItem(t3) {
      return this.items.push(new tn(t3)), this;
    }
    getField(t3) {
      return this.items[t3];
    }
    getPrintWidth() {
      return this.items.length === 0 ? 2 : Math.max(...this.items.map((n) => n.value.getPrintWidth())) + 2;
    }
    write(t3) {
      if (this.items.length === 0) {
        this.writeEmpty(t3);
        return;
      }
      this.writeWithItems(t3);
    }
    writeEmpty(t3) {
      let n = new Ce("[]");
      this.hasError && n.setColor(t3.context.colors.red).underline(), t3.write(n);
    }
    writeWithItems(t3) {
      let { colors: n } = t3.context;
      t3.writeLine("[").withIndent(() => t3.writeJoined(Cr, this.items).newLine()).write("]"), this.hasError && t3.afterNextNewline(() => {
        t3.writeLine(n.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var Ss = ": ";
  var sn = class {
    constructor(r2, t3) {
      this.name = r2;
      this.value = t3;
      this.hasError = false;
    }
    markAsError() {
      this.hasError = true;
    }
    getPrintWidth() {
      return this.name.length + this.value.getPrintWidth() + Ss.length;
    }
    write(r2) {
      let t3 = new Ce(this.name);
      this.hasError && t3.underline().setColor(r2.context.colors.red), r2.write(t3).write(Ss).write(this.value);
    }
  };
  var J = class e2 extends He {
    constructor() {
      super(...arguments);
      this.fields = {};
      this.suggestions = [];
    }
    addField(t3) {
      this.fields[t3.name] = t3;
    }
    addSuggestion(t3) {
      this.suggestions.push(t3);
    }
    getField(t3) {
      return this.fields[t3];
    }
    getDeepField(t3) {
      let [n, ...i] = t3, o = this.getField(n);
      if (!o)
        return;
      let s = o;
      for (let a2 of i) {
        let l;
        if (s.value instanceof e2 ? l = s.value.getField(a2) : s.value instanceof Rr && (l = s.value.getField(Number(a2))), !l)
          return;
        s = l;
      }
      return s;
    }
    getDeepFieldValue(t3) {
      return t3.length === 0 ? this : this.getDeepField(t3)?.value;
    }
    hasField(t3) {
      return !!this.getField(t3);
    }
    removeAllFields() {
      this.fields = {};
    }
    removeField(t3) {
      delete this.fields[t3];
    }
    getFields() {
      return this.fields;
    }
    isEmpty() {
      return Object.keys(this.fields).length === 0;
    }
    getFieldValue(t3) {
      return this.getField(t3)?.value;
    }
    getDeepSubSelectionValue(t3) {
      let n = this;
      for (let i of t3) {
        if (!(n instanceof e2))
          return;
        let o = n.getSubSelectionValue(i);
        if (!o)
          return;
        n = o;
      }
      return n;
    }
    getDeepSelectionParent(t3) {
      let n = this.getSelectionParent();
      if (!n)
        return;
      let i = n;
      for (let o of t3) {
        let s = i.value.getFieldValue(o);
        if (!s || !(s instanceof e2))
          return;
        let a2 = s.getSelectionParent();
        if (!a2)
          return;
        i = a2;
      }
      return i;
    }
    getSelectionParent() {
      let t3 = this.getField("select");
      if (t3?.value instanceof e2)
        return { kind: "select", value: t3.value };
      let n = this.getField("include");
      if (n?.value instanceof e2)
        return { kind: "include", value: n.value };
    }
    getSubSelectionValue(t3) {
      return this.getSelectionParent()?.value.fields[t3].value;
    }
    getPrintWidth() {
      let t3 = Object.values(this.fields);
      return t3.length == 0 ? 2 : Math.max(...t3.map((i) => i.getPrintWidth())) + 2;
    }
    write(t3) {
      let n = Object.values(this.fields);
      if (n.length === 0 && this.suggestions.length === 0) {
        this.writeEmpty(t3);
        return;
      }
      this.writeWithContents(t3, n);
    }
    writeEmpty(t3) {
      let n = new Ce("{}");
      this.hasError && n.setColor(t3.context.colors.red).underline(), t3.write(n);
    }
    writeWithContents(t3, n) {
      t3.writeLine("{").withIndent(() => {
        t3.writeJoined(Cr, [...n, ...this.suggestions]).newLine();
      }), t3.write("}"), this.hasError && t3.afterNextNewline(() => {
        t3.writeLine(t3.context.colors.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var H = class extends He {
    constructor(t3) {
      super();
      this.text = t3;
    }
    getPrintWidth() {
      return this.text.length;
    }
    write(t3) {
      let n = new Ce(this.text);
      this.hasError && n.underline().setColor(t3.context.colors.red), t3.write(n);
    }
  };
  var Ri = class {
    constructor(r2) {
      this.errorMessages = [];
      this.arguments = r2;
    }
    write(r2) {
      r2.write(this.arguments);
    }
    addErrorMessage(r2) {
      this.errorMessages.push(r2);
    }
    renderAllMessages(r2) {
      return this.errorMessages.map((t3) => t3(r2)).join(`
`);
    }
  };
  var Xc = "P2037";
  var it = "<unknown>";
  var rp = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var tp = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  var ip = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var sp = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var ap = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  var up = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  var pp = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var Si = class {
    getLocation() {
      return null;
    }
  };
  var Ai = class {
    constructor() {
      this._error = new Error;
    }
    getLocation() {
      let r2 = this._error.stack;
      if (!r2)
        return null;
      let n = ks(r2).find((i) => {
        if (!i.file)
          return false;
        let o = ii(i.file);
        return o !== "<anonymous>" && !o.includes("@prisma") && !o.includes("/packages/client/src/runtime/") && !o.endsWith("/runtime/binary.js") && !o.endsWith("/runtime/library.js") && !o.endsWith("/runtime/edge.js") && !o.endsWith("/runtime/edge-esm.js") && !o.startsWith("internal/") && !i.methodName.includes("new ") && !i.methodName.includes("getCallSite") && !i.methodName.includes("Proxy.") && i.methodName.split(".").length < 4;
      });
      return !n || !n.file ? null : { fileName: n.file, lineNumber: n.lineNumber, columnNumber: n.column };
    }
  };
  var Ds = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
  var $s = (e2) => Array.isArray(e2) ? e2 : e2.split(".");
  var Ii = (e2, r2) => $s(r2).reduce((t3, n) => t3 && t3[n], e2);
  var qs = (e2, r2, t3) => $s(r2).reduceRight((n, i, o, s) => Object.assign({}, Ii(e2, s.slice(0, o)), { [i]: n }), t3);
  var Gs = _(oi());
  var Qs = _(import.meta.require("fs"));
  var Bs = { keyword: _e, entity: _e, value: (e2) => W(Ze(e2)), punctuation: Ze, directive: _e, function: _e, variable: (e2) => W(Ze(e2)), string: (e2) => W($e(e2)), boolean: de, number: _e, comment: Fr };
  var Pp = (e2) => e2;
  var un = {};
  var vp = 0;
  var P = { manual: un.Prism && un.Prism.manual, disableWorkerMessageHandler: un.Prism && un.Prism.disableWorkerMessageHandler, util: { encode: function(e2) {
    if (e2 instanceof ye) {
      let r2 = e2;
      return new ye(r2.type, P.util.encode(r2.content), r2.alias);
    } else
      return Array.isArray(e2) ? e2.map(P.util.encode) : e2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
  }, type: function(e2) {
    return Object.prototype.toString.call(e2).slice(8, -1);
  }, objId: function(e2) {
    return e2.__id || Object.defineProperty(e2, "__id", { value: ++vp }), e2.__id;
  }, clone: function e(r2, t3) {
    let n, i, o = P.util.type(r2);
    switch (t3 = t3 || {}, o) {
      case "Object":
        if (i = P.util.objId(r2), t3[i])
          return t3[i];
        n = {}, t3[i] = n;
        for (let s in r2)
          r2.hasOwnProperty(s) && (n[s] = e(r2[s], t3));
        return n;
      case "Array":
        return i = P.util.objId(r2), t3[i] ? t3[i] : (n = [], t3[i] = n, r2.forEach(function(s, a2) {
          n[a2] = e(s, t3);
        }), n);
      default:
        return r2;
    }
  } }, languages: { extend: function(e2, r2) {
    let t3 = P.util.clone(P.languages[e2]);
    for (let n in r2)
      t3[n] = r2[n];
    return t3;
  }, insertBefore: function(e2, r2, t3, n) {
    n = n || P.languages;
    let i = n[e2], o = {};
    for (let a2 in i)
      if (i.hasOwnProperty(a2)) {
        if (a2 == r2)
          for (let l in t3)
            t3.hasOwnProperty(l) && (o[l] = t3[l]);
        t3.hasOwnProperty(a2) || (o[a2] = i[a2]);
      }
    let s = n[e2];
    return n[e2] = o, P.languages.DFS(P.languages, function(a2, l) {
      l === s && a2 != e2 && (this[a2] = o);
    }), o;
  }, DFS: function e(r2, t3, n, i) {
    i = i || {};
    let o = P.util.objId;
    for (let s in r2)
      if (r2.hasOwnProperty(s)) {
        t3.call(r2, s, r2[s], n || s);
        let a2 = r2[s], l = P.util.type(a2);
        l === "Object" && !i[o(a2)] ? (i[o(a2)] = true, e(a2, t3, null, i)) : l === "Array" && !i[o(a2)] && (i[o(a2)] = true, e(a2, t3, s, i));
      }
  } }, plugins: {}, highlight: function(e2, r2, t3) {
    let n = { code: e2, grammar: r2, language: t3 };
    return P.hooks.run("before-tokenize", n), n.tokens = P.tokenize(n.code, n.grammar), P.hooks.run("after-tokenize", n), ye.stringify(P.util.encode(n.tokens), n.language);
  }, matchGrammar: function(e2, r2, t3, n, i, o, s) {
    for (let h in t3) {
      if (!t3.hasOwnProperty(h) || !t3[h])
        continue;
      if (h == s)
        return;
      let A = t3[h];
      A = P.util.type(A) === "Array" ? A : [A];
      for (let T = 0;T < A.length; ++T) {
        let C = A[T], E = C.inside, I = !!C.lookbehind, me = !!C.greedy, le = 0, Nr = C.alias;
        if (me && !C.pattern.global) {
          let U = C.pattern.toString().match(/[imuy]*$/)[0];
          C.pattern = RegExp(C.pattern.source, U + "g");
        }
        C = C.pattern || C;
        for (let U = n, ie = i;U < r2.length; ie += r2[U].length, ++U) {
          let Ae = r2[U];
          if (r2.length > e2.length)
            return;
          if (Ae instanceof ye)
            continue;
          if (me && U != r2.length - 1) {
            C.lastIndex = ie;
            var p = C.exec(e2);
            if (!p)
              break;
            var c = p.index + (I ? p[1].length : 0), m = p.index + p[0].length, a2 = U, l = ie;
            for (let L = r2.length;a2 < L && (l < m || !r2[a2].type && !r2[a2 - 1].greedy); ++a2)
              l += r2[a2].length, c >= l && (++U, ie = l);
            if (r2[U] instanceof ye)
              continue;
            u = a2 - U, Ae = e2.slice(ie, l), p.index -= ie;
          } else {
            C.lastIndex = 0;
            var p = C.exec(Ae), u = 1;
          }
          if (!p) {
            if (o)
              break;
            continue;
          }
          I && (le = p[1] ? p[1].length : 0);
          var c = p.index + le, p = p[0].slice(le), m = c + p.length, f = Ae.slice(0, c), g = Ae.slice(m);
          let Y = [U, u];
          f && (++U, ie += f.length, Y.push(f));
          let pr = new ye(h, E ? P.tokenize(p, E) : p, Nr, p, me);
          if (Y.push(pr), g && Y.push(g), Array.prototype.splice.apply(r2, Y), u != 1 && P.matchGrammar(e2, r2, t3, U, ie, true, h), o)
            break;
        }
      }
    }
  }, tokenize: function(e2, r2) {
    let t3 = [e2], n = r2.rest;
    if (n) {
      for (let i in n)
        r2[i] = n[i];
      delete r2.rest;
    }
    return P.matchGrammar(e2, t3, r2, 0, 0, false), t3;
  }, hooks: { all: {}, add: function(e2, r2) {
    let t3 = P.hooks.all;
    t3[e2] = t3[e2] || [], t3[e2].push(r2);
  }, run: function(e2, r2) {
    let t3 = P.hooks.all[e2];
    if (!(!t3 || !t3.length))
      for (var n = 0, i;i = t3[n++]; )
        i(r2);
  } }, Token: ye };
  P.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
  P.languages.javascript = P.languages.extend("clike", { "class-name": [P.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
  P.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  P.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: P.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: P.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: P.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: P.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
  P.languages.markup && P.languages.markup.tag.addInlined("script", "javascript");
  P.languages.js = P.languages.javascript;
  P.languages.typescript = P.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
  P.languages.ts = P.languages.typescript;
  ye.stringify = function(e2, r2) {
    return typeof e2 == "string" ? e2 : Array.isArray(e2) ? e2.map(function(t3) {
      return ye.stringify(t3, r2);
    }).join("") : Tp(e2.type)(e2.content);
  };
  var js = _(Ko());
  var cn = class e2 {
    static read(r2) {
      let t3;
      try {
        t3 = Qs.default.readFileSync(r2, "utf-8");
      } catch {
        return null;
      }
      return e2.fromContent(t3);
    }
    static fromContent(r2) {
      let t3 = r2.split(/\r?\n/);
      return new e2(1, t3);
    }
    constructor(r2, t3) {
      this.firstLineNumber = r2, this.lines = t3;
    }
    get lastLineNumber() {
      return this.firstLineNumber + this.lines.length - 1;
    }
    mapLineAt(r2, t3) {
      if (r2 < this.firstLineNumber || r2 > this.lines.length + this.firstLineNumber)
        return this;
      let n = r2 - this.firstLineNumber, i = [...this.lines];
      return i[n] = t3(i[n]), new e2(this.firstLineNumber, i);
    }
    mapLines(r2) {
      return new e2(this.firstLineNumber, this.lines.map((t3, n) => r2(t3, this.firstLineNumber + n)));
    }
    lineAt(r2) {
      return this.lines[r2 - this.firstLineNumber];
    }
    prependSymbolAt(r2, t3) {
      return this.mapLines((n, i) => i === r2 ? `${t3} ${n}` : `  ${n}`);
    }
    slice(r2, t3) {
      let n = this.lines.slice(r2 - 1, t3).join(`
`);
      return new e2(r2, Us(n).split(`
`));
    }
    highlight() {
      let r2 = Vs(this.toString());
      return new e2(this.firstLineNumber, r2.split(`
`));
    }
    toString() {
      return this.lines.join(`
`);
    }
  };
  var Rp = { red: ce, gray: Fr, dim: Ie, bold: W, underline: ee, highlightSource: (e2) => e2.highlight() };
  var Sp = { red: (e2) => e2, gray: (e2) => e2, dim: (e2) => e2, bold: (e2) => e2, underline: (e2) => e2, highlightSource: (e2) => e2 };
  var Op = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
  var Fp = ["aggregate", "count", "groupBy"];
  var Di = Symbol();
  var ea = (e2) => e2;
  var mn = class {
    constructor(r2, t3) {
      this.extension = r2;
      this.previous = t3;
      this.computedFieldsCache = new xe;
      this.modelExtensionsCache = new xe;
      this.queryCallbacksCache = new xe;
      this.clientExtensions = Wr(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      this.batchCallbacks = Wr(() => {
        let r3 = this.previous?.getAllBatchQueryCallbacks() ?? [], t4 = this.extension.query?.$__internalBatch;
        return t4 ? r3.concat(t4) : r3;
      });
    }
    getAllComputedFields(r2) {
      return this.computedFieldsCache.getOrCreate(r2, () => aa(this.previous?.getAllComputedFields(r2), this.extension, r2));
    }
    getAllClientExtensions() {
      return this.clientExtensions.get();
    }
    getAllModelExtensions(r2) {
      return this.modelExtensionsCache.getOrCreate(r2, () => {
        let t3 = Re(r2);
        return !this.extension.model || !(this.extension.model[t3] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(r2) : { ...this.previous?.getAllModelExtensions(r2), ...this.extension.model.$allModels, ...this.extension.model[t3] };
      });
    }
    getAllQueryCallbacks(r2, t3) {
      return this.queryCallbacksCache.getOrCreate(`${r2}:${t3}`, () => {
        let n = this.previous?.getAllQueryCallbacks(r2, t3) ?? [], i = [], o = this.extension.query;
        return !o || !(o[r2] || o.$allModels || o[t3] || o.$allOperations) ? n : (o[r2] !== undefined && (o[r2][t3] !== undefined && i.push(o[r2][t3]), o[r2].$allOperations !== undefined && i.push(o[r2].$allOperations)), r2 !== "$none" && o.$allModels !== undefined && (o.$allModels[t3] !== undefined && i.push(o.$allModels[t3]), o.$allModels.$allOperations !== undefined && i.push(o.$allModels.$allOperations)), o[t3] !== undefined && i.push(o[t3]), o.$allOperations !== undefined && i.push(o.$allOperations), n.concat(i));
      });
    }
    getAllBatchQueryCallbacks() {
      return this.batchCallbacks.get();
    }
  };
  var dn = class e2 {
    constructor(r2) {
      this.head = r2;
    }
    static empty() {
      return new e2;
    }
    static single(r2) {
      return new e2(new mn(r2));
    }
    isEmpty() {
      return this.head === undefined;
    }
    append(r2) {
      return new e2(new mn(r2, this.head));
    }
    getAllComputedFields(r2) {
      return this.head?.getAllComputedFields(r2);
    }
    getAllClientExtensions() {
      return this.head?.getAllClientExtensions();
    }
    getAllModelExtensions(r2) {
      return this.head?.getAllModelExtensions(r2);
    }
    getAllQueryCallbacks(r2, t3) {
      return this.head?.getAllQueryCallbacks(r2, t3) ?? [];
    }
    getAllBatchQueryCallbacks() {
      return this.head?.getAllBatchQueryCallbacks() ?? [];
    }
  };
  var ua = N("prisma:client");
  var ca = { Vercel: "vercel", "Netlify CI": "netlify" };
  var Jp = "Cloudflare-Workers";
  var Hp = "node";
  var Wp = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Vercel Edge Functions or Edge Middleware" };
  var Ea = _(import.meta.require("fs"));
  var at = _(import.meta.require("path"));
  var zp = N("prisma:client:engines:resolveEnginePath");
  var Yp = () => new RegExp("runtime[\\\\/]library\\.m?js$");
  var Li = _(ui());
  var va = _(is());
  var En = class extends Error {
    constructor(r2, t3) {
      super(r2), this.clientVersion = t3.clientVersion, this.cause = t3.cause;
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
  };
  var ae = class extends En {
    constructor(r2, t3) {
      super(r2, t3), this.isRetryable = t3.isRetryable ?? true;
    }
  };
  var _r = class extends ae {
    constructor(t3) {
      super("This request must be retried", S(t3, true));
      this.name = "ForcedRetryError";
      this.code = "P5001";
    }
  };
  w(_r, "ForcedRetryError");
  var ar = class extends ae {
    constructor(t3, n) {
      super(t3, S(n, false));
      this.name = "InvalidDatasourceError";
      this.code = "P6001";
    }
  };
  w(ar, "InvalidDatasourceError");
  var lr = class extends ae {
    constructor(t3, n) {
      super(t3, S(n, false));
      this.name = "NotImplementedYetError";
      this.code = "P5004";
    }
  };
  w(lr, "NotImplementedYetError");
  var $ = class extends ae {
    constructor(r2, t3) {
      super(r2, t3), this.response = t3.response;
      let n = this.response.headers.get("prisma-request-id");
      if (n) {
        let i = `(The request id was: ${n})`;
        this.message = this.message + " " + i;
      }
    }
  };
  var ur = class extends $ {
    constructor(t3) {
      super("Schema needs to be uploaded", S(t3, true));
      this.name = "SchemaMissingError";
      this.code = "P5005";
    }
  };
  w(ur, "SchemaMissingError");
  var Ni = "This request could not be understood by the server";
  var lt = class extends $ {
    constructor(t3, n, i) {
      super(n || Ni, S(t3, false));
      this.name = "BadRequestError";
      this.code = "P5000";
      i && (this.code = i);
    }
  };
  w(lt, "BadRequestError");
  var ut = class extends $ {
    constructor(t3, n) {
      super("Engine not started: healthcheck timeout", S(t3, true));
      this.name = "HealthcheckTimeoutError";
      this.code = "P5013";
      this.logs = n;
    }
  };
  w(ut, "HealthcheckTimeoutError");
  var ct = class extends $ {
    constructor(t3, n, i) {
      super(n, S(t3, true));
      this.name = "EngineStartupError";
      this.code = "P5014";
      this.logs = i;
    }
  };
  w(ct, "EngineStartupError");
  var pt = class extends $ {
    constructor(t3) {
      super("Engine version is not supported", S(t3, false));
      this.name = "EngineVersionNotSupportedError";
      this.code = "P5012";
    }
  };
  w(pt, "EngineVersionNotSupportedError");
  var Oi = "Request timed out";
  var mt = class extends $ {
    constructor(t3, n = Oi) {
      super(n, S(t3, false));
      this.name = "GatewayTimeoutError";
      this.code = "P5009";
    }
  };
  w(mt, "GatewayTimeoutError");
  var Xp = "Interactive transaction error";
  var dt = class extends $ {
    constructor(t3, n = Xp) {
      super(n, S(t3, false));
      this.name = "InteractiveTransactionError";
      this.code = "P5015";
    }
  };
  w(dt, "InteractiveTransactionError");
  var em = "Request parameters are invalid";
  var ft = class extends $ {
    constructor(t3, n = em) {
      super(n, S(t3, false));
      this.name = "InvalidRequestError";
      this.code = "P5011";
    }
  };
  w(ft, "InvalidRequestError");
  var Fi = "Requested resource does not exist";
  var gt = class extends $ {
    constructor(t3, n = Fi) {
      super(n, S(t3, false));
      this.name = "NotFoundError";
      this.code = "P5003";
    }
  };
  w(gt, "NotFoundError");
  var Mi = "Unknown server error";
  var kr = class extends $ {
    constructor(t3, n, i) {
      super(n || Mi, S(t3, true));
      this.name = "ServerError";
      this.code = "P5006";
      this.logs = i;
    }
  };
  w(kr, "ServerError");
  var $i = "Unauthorized, check your connection string";
  var ht = class extends $ {
    constructor(t3, n = $i) {
      super(n, S(t3, false));
      this.name = "UnauthorizedError";
      this.code = "P5007";
    }
  };
  w(ht, "UnauthorizedError");
  var qi = "Usage exceeded, retry again later";
  var yt = class extends $ {
    constructor(t3, n = qi) {
      super(n, S(t3, true));
      this.name = "UsageExceededError";
      this.code = "P5008";
    }
  };
  w(yt, "UsageExceededError");
  var Fe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var _a = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "5.12.0-21.473ed3124229e22d881cb7addf559799debae1ab", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*" };
  var bt = class extends ae {
    constructor(t3, n) {
      super(`Cannot fetch data from service:
${t3}`, S(n, true));
      this.name = "RequestError";
      this.code = "P5010";
    }
  };
  w(bt, "RequestError");
  var am = typeof import.meta.require < "u" ? import.meta.require : () => {
  };
  var Vi = class {
    constructor(r2 = {}) {
      this.headers = new Map;
      for (let [t3, n] of Object.entries(r2))
        if (typeof n == "string")
          this.headers.set(t3, n);
        else if (Array.isArray(n))
          for (let i of n)
            this.headers.set(t3, i);
    }
    append(r2, t3) {
      this.headers.set(r2, t3);
    }
    delete(r2) {
      this.headers.delete(r2);
    }
    get(r2) {
      return this.headers.get(r2) ?? null;
    }
    has(r2) {
      return this.headers.has(r2);
    }
    set(r2, t3) {
      this.headers.set(r2, t3);
    }
    forEach(r2, t3) {
      for (let [n, i] of this.headers)
        r2.call(t3, i, n, this);
    }
  };
  var lm = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
  var ka = N("prisma:client:dataproxyEngine");
  var La = 3;
  var ji = N("prisma:client:dataproxyEngine");
  var Ui = class {
    constructor({ apiKey: r2, tracingHelper: t3, logLevel: n, logQueries: i, engineHash: o }) {
      this.apiKey = r2, this.tracingHelper = t3, this.logLevel = n, this.logQueries = i, this.engineHash = o;
    }
    build({ traceparent: r2, interactiveTransaction: t3 } = {}) {
      let n = { Authorization: `Bearer ${this.apiKey}`, "Prisma-Engine-Hash": this.engineHash };
      this.tracingHelper.isEnabled() && (n.traceparent = r2 ?? this.tracingHelper.getTraceParent()), t3 && (n["X-transaction-id"] = t3.id);
      let i = this.buildCaptureSettings();
      return i.length > 0 && (n["X-capture-telemetry"] = i.join(", ")), n;
    }
    buildCaptureSettings() {
      let r2 = [];
      return this.tracingHelper.isEnabled() && r2.push("tracing"), this.logLevel && r2.push(this.logLevel), this.logQueries && r2.push("query"), r2;
    }
  };
  var wt = class {
    constructor(r2) {
      this.name = "DataProxyEngine";
      Aa(r2), this.config = r2, this.env = { ...r2.env, ...typeof process < "u" ? process.env : {} }, this.inlineSchema = Sa(r2.inlineSchema), this.inlineDatasources = r2.inlineDatasources, this.inlineSchemaHash = r2.inlineSchemaHash, this.clientVersion = r2.clientVersion, this.engineHash = r2.engineVersion, this.logEmitter = r2.logEmitter, this.tracingHelper = r2.tracingHelper;
    }
    apiKey() {
      return this.headerBuilder.apiKey;
    }
    version() {
      return this.engineHash;
    }
    async start() {
      this.startPromise !== undefined && await this.startPromise, this.startPromise = (async () => {
        let [r2, t3] = this.extractHostAndApiKey();
        this.host = r2, this.headerBuilder = new Ui({ apiKey: t3, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries, engineHash: this.engineHash }), this.remoteClientVersion = await Da(r2, this.config), ji("host", this.host);
      })(), await this.startPromise;
    }
    async stop() {
    }
    propagateResponseExtensions(r2) {
      r2?.logs?.length && r2.logs.forEach((t3) => {
        switch (t3.level) {
          case "debug":
          case "error":
          case "trace":
          case "warn":
          case "info":
            break;
          case "query": {
            let n = typeof t3.attributes.query == "string" ? t3.attributes.query : "";
            if (!this.tracingHelper.isEnabled()) {
              let [i] = n.split("/* traceparent");
              n = i;
            }
            this.logEmitter.emit("query", { query: n, timestamp: Ia(t3.timestamp), duration: Number(t3.attributes.duration_ms), params: t3.attributes.params, target: t3.attributes.target });
          }
        }
      }), r2?.traces?.length && this.tracingHelper.createEngineSpan({ span: true, spans: r2.traces });
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the remote query engine');
    }
    async url(r2) {
      return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r2}`;
    }
    async uploadSchema() {
      let r2 = { name: "schemaUpload", internal: true };
      return this.tracingHelper.runInChildSpan(r2, async () => {
        let t3 = await cr(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
        t3.ok || ji("schema response status", t3.status);
        let n = await Et(t3, this.clientVersion);
        if (n)
          throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${n.message}`, timestamp: new Date, target: "" }), n;
        this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`, timestamp: new Date, target: "" });
      });
    }
    request(r2, { traceparent: t3, interactiveTransaction: n, customDataProxyFetch: i }) {
      return this.requestInternal({ body: r2, traceparent: t3, interactiveTransaction: n, customDataProxyFetch: i });
    }
    async requestBatch(r2, { traceparent: t3, transaction: n, customDataProxyFetch: i }) {
      let o = n?.kind === "itx" ? n.options : undefined, s = Er(r2, n), { batchResult: a2, elapsed: l } = await this.requestInternal({ body: s, customDataProxyFetch: i, interactiveTransaction: o, traceparent: t3 });
      return a2.map((u) => ("errors" in u) && u.errors.length > 0 ? sr(u.errors[0], this.clientVersion, this.config.activeProvider) : { data: u, elapsed: l });
    }
    requestInternal({ body: r2, traceparent: t3, customDataProxyFetch: n, interactiveTransaction: i }) {
      return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: o }) => {
        let s = i ? `${i.payload.endpoint}/graphql` : await this.url("graphql");
        o(s);
        let a2 = await cr(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: t3, interactiveTransaction: i }), body: JSON.stringify(r2), clientVersion: this.clientVersion }, n);
        a2.ok || ji("graphql response status", a2.status), await this.handleError(await Et(a2, this.clientVersion));
        let l = await a2.json(), u = l.extensions;
        if (u && this.propagateResponseExtensions(u), l.errors)
          throw l.errors.length === 1 ? sr(l.errors[0], this.config.clientVersion, this.config.activeProvider) : new j(l.errors, { clientVersion: this.config.clientVersion });
        return l;
      } });
    }
    async transaction(r2, t3, n) {
      let i = { start: "starting", commit: "committing", rollback: "rolling back" };
      return this.withRetry({ actionGerund: `${i[r2]} transaction`, callback: async ({ logHttpCall: o }) => {
        if (r2 === "start") {
          let s = JSON.stringify({ max_wait: n.maxWait, timeout: n.timeout, isolation_level: n.isolationLevel }), a2 = await this.url("transaction/start");
          o(a2);
          let l = await cr(a2, { method: "POST", headers: this.headerBuilder.build({ traceparent: t3.traceparent }), body: s, clientVersion: this.clientVersion });
          await this.handleError(await Et(l, this.clientVersion));
          let u = await l.json(), c = u.extensions;
          c && this.propagateResponseExtensions(c);
          let p = u.id, m = u["data-proxy"].endpoint;
          return { id: p, payload: { endpoint: m } };
        } else {
          let s = `${n.payload.endpoint}/${r2}`;
          o(s);
          let a2 = await cr(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: t3.traceparent }), clientVersion: this.clientVersion });
          await this.handleError(await Et(a2, this.clientVersion));
          let u = (await a2.json()).extensions;
          u && this.propagateResponseExtensions(u);
          return;
        }
      } });
    }
    extractHostAndApiKey() {
      let r2 = { clientVersion: this.clientVersion }, t3 = Object.keys(this.inlineDatasources)[0], n = Ir({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), i;
      try {
        i = new URL(n);
      } catch {
        throw new ar(`Error validating datasource \`${t3}\`: the URL must start with the protocol \`prisma://\``, r2);
      }
      let { protocol: o, host: s, searchParams: a2 } = i;
      if (o !== "prisma:")
        throw new ar(`Error validating datasource \`${t3}\`: the URL must start with the protocol \`prisma://\``, r2);
      let l = a2.get("api_key");
      if (l === null || l.length < 1)
        throw new ar(`Error validating datasource \`${t3}\`: the URL must contain a valid API key`, r2);
      return [s, l];
    }
    metrics() {
      throw new lr("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
    }
    async withRetry(r2) {
      for (let t3 = 0;; t3++) {
        let n = (i) => {
          this.logEmitter.emit("info", { message: `Calling ${i} (n=${t3})`, timestamp: new Date, target: "" });
        };
        try {
          return await r2.callback({ logHttpCall: n });
        } catch (i) {
          if (!(i instanceof ae) || !i.isRetryable)
            throw i;
          if (t3 >= La)
            throw i instanceof _r ? i.cause : i;
          this.logEmitter.emit("warn", { message: `Attempt ${t3 + 1}/${La} failed for ${r2.actionGerund}: ${i.message ?? "(unknown)"}`, timestamp: new Date, target: "" });
          let o = await Ra(t3);
          this.logEmitter.emit("warn", { message: `Retrying after ${o}ms`, timestamp: new Date, target: "" });
        }
      }
    }
    async handleError(r2) {
      if (r2 instanceof ur)
        throw await this.uploadSchema(), new _r({ clientVersion: this.clientVersion, cause: r2 });
      if (r2)
        throw r2;
    }
  };
  var Gi = _(import.meta.require("os"));
  var Oa = _(import.meta.require("path"));
  var Qi = Symbol("PrismaLibraryEngineCache");
  var Fa = { async loadLibrary(e2) {
    let r2 = await jn(), t3 = await ba("library", e2);
    try {
      return e2.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => mm(t3));
    } catch (n) {
      let i = ni({ e: n, platformInfo: r2, id: t3 });
      throw new R(i, e2.clientVersion);
    }
  } };
  var Ji;
  var Ma = { async loadLibrary(e2) {
    let { clientVersion: r2, adapter: t3, engineWasm: n } = e2;
    if (t3 === undefined)
      throw new R(`The \`adapter\` option for \`PrismaClient\` is required in this context (${fn().prettyName})`, r2);
    if (n === undefined)
      throw new R("WASM engine was unexpectedly `undefined`", r2);
    Ji === undefined && (Ji = (async () => {
      let o = n.getRuntime(), s = await n.getQueryEngineWasmModule();
      if (s == null)
        throw new R("The loaded wasm module was unexpectedly `undefined` or `null` once loaded", r2);
      let a2 = { "./query_engine_bg.js": o }, l = new WebAssembly.Instance(s, a2);
      return o.__wbg_set_wasm(l.exports), o.QueryEngine;
    })());
    let i = await Ji;
    return { debugPanic() {
      return Promise.reject("{}");
    }, dmmf() {
      return Promise.resolve("{}");
    }, version() {
      return { commit: "unknown", version: "unknown" };
    }, QueryEngine: i };
  } };
  var dm = "P2036";
  var Se = N("prisma:client:libraryEngine");
  var $a = [...Mn, "native"];
  var qa = 0;
  var xt = class {
    constructor(r2, t3) {
      this.name = "LibraryEngine";
      this.libraryLoader = t3 ?? Fa, r2.engineWasm !== undefined && (this.libraryLoader = t3 ?? Ma), this.config = r2, this.libraryStarted = false, this.logQueries = r2.logQueries ?? false, this.logLevel = r2.logLevel ?? "error", this.logEmitter = r2.logEmitter, this.datamodel = r2.inlineSchema, r2.enableDebugLogs && (this.logLevel = "debug");
      let n = Object.keys(r2.overrideDatasources)[0], i = r2.overrideDatasources[n]?.url;
      n !== undefined && i !== undefined && (this.datasourceOverrides = { [n]: i }), this.libraryInstantiationPromise = this.instantiateLibrary(), this.checkForTooManyEngines();
    }
    checkForTooManyEngines() {
      qa === 10 && console.warn(`${de("warn(prisma-client)")} This is the 10th instance of Prisma Client being started. Make sure this is intentional.`);
    }
    async transaction(r2, t3, n) {
      await this.start();
      let i = JSON.stringify(t3), o;
      if (r2 === "start") {
        let a2 = JSON.stringify({ max_wait: n.maxWait, timeout: n.timeout, isolation_level: n.isolationLevel });
        o = await this.engine?.startTransaction(a2, i);
      } else
        r2 === "commit" ? o = await this.engine?.commitTransaction(n.id, i) : r2 === "rollback" && (o = await this.engine?.rollbackTransaction(n.id, i));
      let s = this.parseEngineResponse(o);
      if (hm(s)) {
        let a2 = this.getExternalAdapterError(s);
        throw a2 ? a2.error : new V(s.message, { code: s.error_code, clientVersion: this.config.clientVersion, meta: s.meta });
      }
      return s;
    }
    async instantiateLibrary() {
      if (Se("internalSetup"), this.libraryInstantiationPromise)
        return this.libraryInstantiationPromise;
      Fn(), this.binaryTarget = await this.getCurrentBinaryTarget(), await this.loadEngine(), this.version();
    }
    async getCurrentBinaryTarget() {
      {
        if (this.binaryTarget)
          return this.binaryTarget;
        let r2 = await rr();
        if (!$a.includes(r2))
          throw new R(`Unknown ${ce("PRISMA_QUERY_ENGINE_LIBRARY")} ${ce(W(r2))}. Possible binaryTargets: ${$e($a.join(", "))} or a path to the query engine library.
You may have to run ${$e("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
        return r2;
      }
    }
    parseEngineResponse(r2) {
      if (!r2)
        throw new j("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
      try {
        return JSON.parse(r2);
      } catch {
        throw new j("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
      }
    }
    async loadEngine() {
      if (!this.engine) {
        this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(this.config), this.QueryEngineConstructor = this.library.QueryEngine);
        try {
          let r2 = new WeakRef(this), { adapter: t3 } = this.config;
          t3 && Se("Using driver adapter: %O", t3), this.engine = new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json" }, (n) => {
            r2.deref()?.logger(n);
          }, t3), qa++;
        } catch (r2) {
          let t3 = r2, n = this.parseInitError(t3.message);
          throw typeof n == "string" ? t3 : new R(n.message, this.config.clientVersion, n.error_code);
        }
      }
    }
    logger(r2) {
      let t3 = this.parseEngineResponse(r2);
      if (t3) {
        if ("span" in t3) {
          this.config.tracingHelper.createEngineSpan(t3);
          return;
        }
        t3.level = t3?.level.toLowerCase() ?? "unknown", fm(t3) ? this.logEmitter.emit("query", { timestamp: new Date, query: t3.query, params: t3.params, duration: Number(t3.duration_ms), target: t3.module_path }) : gm(t3) ? this.loggerRustPanic = new ue(Hi(this, `${t3.message}: ${t3.reason} in ${t3.file}:${t3.line}:${t3.column}`), this.config.clientVersion) : this.logEmitter.emit(t3.level, { timestamp: new Date, message: t3.message, target: t3.module_path });
      }
    }
    parseInitError(r2) {
      try {
        return JSON.parse(r2);
      } catch {
      }
      return r2;
    }
    parseRequestError(r2) {
      try {
        return JSON.parse(r2);
      } catch {
      }
      return r2;
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
    }
    async start() {
      if (await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
        return Se(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
      if (this.libraryStarted)
        return;
      let r2 = async () => {
        Se("library starting");
        try {
          let t3 = { traceparent: this.config.tracingHelper.getTraceParent() };
          await this.engine?.connect(JSON.stringify(t3)), this.libraryStarted = true, Se("library started");
        } catch (t3) {
          let n = this.parseInitError(t3.message);
          throw typeof n == "string" ? t3 : new R(n.message, this.config.clientVersion, n.error_code);
        } finally {
          this.libraryStartingPromise = undefined;
        }
      };
      return this.libraryStartingPromise = this.config.tracingHelper.runInChildSpan("connect", r2), this.libraryStartingPromise;
    }
    async stop() {
      if (await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
        return Se("library is already stopping"), this.libraryStoppingPromise;
      if (!this.libraryStarted)
        return;
      let r2 = async () => {
        await new Promise((n) => setTimeout(n, 5)), Se("library stopping");
        let t3 = { traceparent: this.config.tracingHelper.getTraceParent() };
        await this.engine?.disconnect(JSON.stringify(t3)), this.libraryStarted = false, this.libraryStoppingPromise = undefined, Se("library stopped");
      };
      return this.libraryStoppingPromise = this.config.tracingHelper.runInChildSpan("disconnect", r2), this.libraryStoppingPromise;
    }
    version() {
      return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
    }
    debugPanic(r2) {
      return this.library?.debugPanic(r2);
    }
    async request(r2, { traceparent: t3, interactiveTransaction: n }) {
      Se(`sending request, this.libraryStarted: ${this.libraryStarted}`);
      let i = JSON.stringify({ traceparent: t3 }), o = JSON.stringify(r2);
      try {
        await this.start(), this.executingQueryPromise = this.engine?.query(o, i, n?.id), this.lastQuery = o;
        let s = this.parseEngineResponse(await this.executingQueryPromise);
        if (s.errors)
          throw s.errors.length === 1 ? this.buildQueryError(s.errors[0]) : new j(JSON.stringify(s.errors), { clientVersion: this.config.clientVersion });
        if (this.loggerRustPanic)
          throw this.loggerRustPanic;
        return { data: s, elapsed: 0 };
      } catch (s) {
        if (s instanceof R)
          throw s;
        if (s.code === "GenericFailure" && s.message?.startsWith("PANIC:"))
          throw new ue(Hi(this, s.message), this.config.clientVersion);
        let a2 = this.parseRequestError(s.message);
        throw typeof a2 == "string" ? s : new j(`${a2.message}
${a2.backtrace}`, { clientVersion: this.config.clientVersion });
      }
    }
    async requestBatch(r2, { transaction: t3, traceparent: n }) {
      Se("requestBatch");
      let i = Er(r2, t3);
      await this.start(), this.lastQuery = JSON.stringify(i), this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify({ traceparent: n }), Na(t3));
      let o = await this.executingQueryPromise, s = this.parseEngineResponse(o);
      if (s.errors)
        throw s.errors.length === 1 ? this.buildQueryError(s.errors[0]) : new j(JSON.stringify(s.errors), { clientVersion: this.config.clientVersion });
      let { batchResult: a2, errors: l } = s;
      if (Array.isArray(a2))
        return a2.map((u) => u.errors && u.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(u.errors[0]) : { data: u, elapsed: 0 });
      throw l && l.length === 1 ? new Error(l[0].error) : new Error(JSON.stringify(s));
    }
    buildQueryError(r2) {
      if (r2.user_facing_error.is_panic)
        return new ue(Hi(this, r2.user_facing_error.message), this.config.clientVersion);
      let t3 = this.getExternalAdapterError(r2.user_facing_error);
      return t3 ? t3.error : sr(r2, this.config.clientVersion, this.config.activeProvider);
    }
    getExternalAdapterError(r2) {
      if (r2.error_code === dm && this.config.adapter) {
        let t3 = r2.meta?.id;
        Vt(typeof t3 == "number", "Malformed external JS error received from the engine");
        let n = this.config.adapter.errorRegistry.consumeError(t3);
        return Vt(n, "External error with reported id was not registered"), n;
      }
    }
    async metrics(r2) {
      await this.start();
      let t3 = await this.engine.metrics(JSON.stringify(r2));
      return r2.format === "prometheus" ? t3 : this.parseEngineResponse(t3);
    }
  };
  var Ja = _(Wi());
  var Me = class {
    constructor(r2, t3) {
      this.name = r2;
      this.value = t3;
      this.isRequired = false;
    }
    makeRequired() {
      return this.isRequired = true, this;
    }
    write(r2) {
      let { colors: { green: t3 } } = r2.context;
      r2.addMarginSymbol(t3(this.isRequired ? "+" : "?")), r2.write(t3(this.name)), this.isRequired || r2.write(t3("?")), r2.write(t3(": ")), typeof this.value == "string" ? r2.write(t3(this.value)) : r2.write(this.value);
    }
  };
  var xn = class {
    constructor() {
      this.fields = [];
    }
    addField(r2, t3) {
      return this.fields.push({ write(n) {
        let { green: i, dim: o } = n.context.colors;
        n.write(i(o(`${r2}: ${t3}`))).addMarginSymbol(i(o("+")));
      } }), this;
    }
    write(r2) {
      let { colors: { green: t3 } } = r2.context;
      r2.writeLine(t3("{")).withIndent(() => {
        r2.writeJoined(Cr, this.fields).newLine();
      }).write(t3("}")).addMarginSymbol(t3("+"));
    }
  };
  var Lm = 3;
  var Om = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", update: "updateOne", updateMany: "updateMany", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
  var Ki = class e2 {
    constructor(r2) {
      this.params = r2;
      this.params.modelName && (this.model = this.params.runtimeDataModel.models[this.params.modelName]);
    }
    throwValidationError(r2) {
      Tn({ errors: [r2], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion });
    }
    getSelectionPath() {
      return this.params.selectionPath;
    }
    getArgumentPath() {
      return this.params.argumentPath;
    }
    getArgumentName() {
      return this.params.argumentPath[this.params.argumentPath.length - 1];
    }
    getOutputTypeDescription() {
      if (!(!this.params.modelName || !this.model))
        return { name: this.params.modelName, fields: this.model.fields.map((r2) => ({ name: r2.name, typeName: "boolean", isRelation: r2.kind === "object" })) };
    }
    isRawAction() {
      return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
    }
    getComputedFields() {
      if (this.params.modelName)
        return this.params.extensions.getAllComputedFields(this.params.modelName);
    }
    findField(r2) {
      return this.model?.fields.find((t3) => t3.name === r2);
    }
    nestSelection(r2) {
      let t3 = this.findField(r2), n = t3?.kind === "object" ? t3.type : undefined;
      return new e2({ ...this.params, modelName: n, selectionPath: this.params.selectionPath.concat(r2) });
    }
    nestArgument(r2) {
      return new e2({ ...this.params, argumentPath: this.params.argumentPath.concat(r2) });
    }
  };
  var el = (e2) => ({ command: e2 });
  var rl = (e2) => e2.strings.reduce((r2, t3, n) => `${r2}@P${n}${t3}`);
  var Gm = /^(\s*alter\s)/i;
  var ol = N("prisma:client");
  var Zi = ({ clientMethod: e2, activeProvider: r2 }) => (t3) => {
    let n = "", i;
    if (Array.isArray(t3)) {
      let [o, ...s] = t3;
      n = o, i = { values: vt(s || []), __prismaRawParameters__: true };
    } else
      switch (r2) {
        case "sqlite":
        case "mysql": {
          n = t3.sql, i = { values: vt(t3.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          n = t3.text, i = { values: vt(t3.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          n = rl(t3), i = { values: vt(t3.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${r2} provider does not support ${e2}`);
      }
    return i?.values ? ol(`prisma.${e2}(${n}, ${i.values})`) : ol(`prisma.${e2}(${n})`), { query: n, parameters: i };
  };
  var sl = { requestArgsToMiddlewareArgs(e2) {
    return [e2.strings, ...e2.values];
  }, middlewareArgsToRequestArgs(e2) {
    let [r2, ...t3] = e2;
    return new oe(r2, t3);
  } };
  var al = { requestArgsToMiddlewareArgs(e2) {
    return [e2];
  }, middlewareArgsToRequestArgs(e2) {
    return e2[0];
  } };
  var ul = { isEnabled() {
    return false;
  }, getTraceParent() {
    return "00-10-10-00";
  }, async createEngineSpan() {
  }, getActiveContext() {
  }, runInChildSpan(e2, r2) {
    return r2();
  } };
  var eo = class {
    isEnabled() {
      return this.getGlobalTracingHelper().isEnabled();
    }
    getTraceParent(r2) {
      return this.getGlobalTracingHelper().getTraceParent(r2);
    }
    createEngineSpan(r2) {
      return this.getGlobalTracingHelper().createEngineSpan(r2);
    }
    getActiveContext() {
      return this.getGlobalTracingHelper().getActiveContext();
    }
    runInChildSpan(r2, t3) {
      return this.getGlobalTracingHelper().runInChildSpan(r2, t3);
    }
    getGlobalTracingHelper() {
      return globalThis.PRISMA_INSTRUMENTATION?.helper ?? ul;
    }
  };
  var Jm = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
  var ml = Jm;
  var Cn = class {
    constructor() {
      this._middlewares = [];
    }
    use(r2) {
      this._middlewares.push(r2);
    }
    get(r2) {
      return this._middlewares[r2];
    }
    has(r2) {
      return !!this._middlewares[r2];
    }
    length() {
      return this._middlewares.length;
    }
  };
  var gl = _(ui());
  var Km = { aggregate: false, aggregateRaw: false, createMany: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateOne: true, upsertOne: true };
  var An = class {
    constructor(r2) {
      this.options = r2;
      this.tickActive = false;
      this.batches = {};
    }
    request(r2) {
      let t3 = this.options.batchBy(r2);
      return t3 ? (this.batches[t3] || (this.batches[t3] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
        this.dispatchBatches(), this.tickActive = false;
      }))), new Promise((n, i) => {
        this.batches[t3].push({ request: r2, resolve: n, reject: i });
      })) : this.options.singleLoader(r2);
    }
    dispatchBatches() {
      for (let r2 in this.batches) {
        let t3 = this.batches[r2];
        delete this.batches[r2], t3.length === 1 ? this.options.singleLoader(t3[0].request).then((n) => {
          n instanceof Error ? t3[0].reject(n) : t3[0].resolve(n);
        }).catch((n) => {
          t3[0].reject(n);
        }) : (t3.sort((n, i) => this.options.batchOrder(n.request, i.request)), this.options.batchLoader(t3.map((n) => n.request)).then((n) => {
          if (n instanceof Error)
            for (let i = 0;i < t3.length; i++)
              t3[i].reject(n);
          else
            for (let i = 0;i < t3.length; i++) {
              let o = n[i];
              o instanceof Error ? t3[i].reject(o) : t3[i].resolve(o);
            }
        }).catch((n) => {
          for (let i = 0;i < t3.length; i++)
            t3[i].reject(n);
        }));
      }
    }
    get [Symbol.toStringTag]() {
      return "DataLoader";
    }
  };
  var zm = N("prisma:client:request_handler");
  var In = class {
    constructor(r2, t3) {
      this.logEmitter = t3, this.client = r2, this.dataloader = new An({ batchLoader: na(async ({ requests: n, customDataProxyFetch: i }) => {
        let { transaction: o, otelParentCtx: s } = n[0], a2 = n.map((p) => p.protocolQuery), l = this.client._tracingHelper.getTraceParent(s), u = n.some((p) => to(p.protocolQuery.action));
        return (await this.client._engine.requestBatch(a2, { traceparent: l, transaction: Ym(o), containsWrite: u, customDataProxyFetch: i })).map((p, m) => {
          if (p instanceof Error)
            return p;
          try {
            return this.mapQueryEngineResult(n[m], p);
          } catch (f) {
            return f;
          }
        });
      }), singleLoader: async (n) => {
        let i = n.transaction?.kind === "itx" ? hl(n.transaction) : undefined, o = await this.client._engine.request(n.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: to(n.protocolQuery.action), customDataProxyFetch: n.customDataProxyFetch });
        return this.mapQueryEngineResult(n, o);
      }, batchBy: (n) => n.transaction?.id ? `transaction-${n.transaction.id}` : fl(n.protocolQuery), batchOrder(n, i) {
        return n.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n.transaction.index - i.transaction.index : 0;
      } });
    }
    async request(r2) {
      try {
        return await this.dataloader.request(r2);
      } catch (t3) {
        let { clientMethod: n, callsite: i, transaction: o, args: s, modelName: a2 } = r2;
        this.handleAndLogRequestError({ error: t3, clientMethod: n, callsite: i, transaction: o, args: s, modelName: a2 });
      }
    }
    mapQueryEngineResult({ dataPath: r2, unpacker: t3 }, n) {
      let i = n?.data, o = n?.elapsed, s = this.unpack(i, r2, t3);
      return process.env.PRISMA_CLIENT_GET_TIME ? { data: s, elapsed: o } : s;
    }
    handleAndLogRequestError(r2) {
      try {
        this.handleRequestError(r2);
      } catch (t3) {
        throw this.logEmitter && this.logEmitter.emit("error", { message: t3.message, target: r2.clientMethod, timestamp: new Date }), t3;
      }
    }
    handleRequestError({ error: r2, clientMethod: t3, callsite: n, transaction: i, args: o, modelName: s }) {
      if (zm(r2), Zm(r2, i) || r2 instanceof Le)
        throw r2;
      if (r2 instanceof V && Xm(r2)) {
        let l = yl(r2.meta);
        Tn({ args: o, errors: [l], callsite: n, errorFormat: this.client._errorFormat, originalMethod: t3, clientVersion: this.client._clientVersion });
      }
      let a2 = r2.message;
      if (n && (a2 = Ar({ callsite: n, originalMethod: t3, isPanic: r2.isPanic, showColors: this.client._errorFormat === "pretty", message: a2 })), a2 = this.sanitizeMessage(a2), r2.code) {
        let l = s ? { modelName: s, ...r2.meta } : r2.meta;
        throw new V(a2, { code: r2.code, clientVersion: this.client._clientVersion, meta: l, batchRequestIdx: r2.batchRequestIdx });
      } else {
        if (r2.isPanic)
          throw new ue(a2, this.client._clientVersion);
        if (r2 instanceof j)
          throw new j(a2, { clientVersion: this.client._clientVersion, batchRequestIdx: r2.batchRequestIdx });
        if (r2 instanceof R)
          throw new R(a2, this.client._clientVersion);
        if (r2 instanceof ue)
          throw new ue(a2, this.client._clientVersion);
      }
      throw r2.clientVersion = this.client._clientVersion, r2;
    }
    sanitizeMessage(r2) {
      return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, gl.default)(r2) : r2;
    }
    unpack(r2, t3, n) {
      if (!r2 || (r2.data && (r2 = r2.data), !r2))
        return r2;
      let i = Object.values(r2)[0], o = t3.filter((a2) => a2 !== "select" && a2 !== "include"), s = Sn(Ii(i, o));
      return n ? n(s) : s;
    }
    get [Symbol.toStringTag]() {
      return "RequestHandler";
    }
  };
  var El = "5.12.1";
  var bl = El;
  var Cl = _(Wi());
  var q = class extends Error {
    constructor(r2) {
      super(r2 + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientConstructorValidationError";
    }
  };
  w(q, "PrismaClientConstructorValidationError");
  var Pl = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "transactionOptions", "__internal"];
  var vl = ["pretty", "colorless", "minimal"];
  var Tl = ["info", "query", "warn", "error"];
  var rd = { datasources: (e2, { datasourceNames: r2 }) => {
    if (e2) {
      if (typeof e2 != "object" || Array.isArray(e2))
        throw new q(`Invalid value ${JSON.stringify(e2)} for "datasources" provided to PrismaClient constructor`);
      for (let [t3, n] of Object.entries(e2)) {
        if (!r2.includes(t3)) {
          let i = Lr(t3, r2) || ` Available datasources: ${r2.join(", ")}`;
          throw new q(`Unknown datasource ${t3} provided to PrismaClient constructor.${i}`);
        }
        if (typeof n != "object" || Array.isArray(n))
          throw new q(`Invalid value ${JSON.stringify(e2)} for datasource "${t3}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
        if (n && typeof n == "object")
          for (let [i, o] of Object.entries(n)) {
            if (i !== "url")
              throw new q(`Invalid value ${JSON.stringify(e2)} for datasource "${t3}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o != "string")
              throw new q(`Invalid value ${JSON.stringify(o)} for datasource "${t3}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
      }
    }
  }, adapter: (e2, r2) => {
    if (e2 === null)
      return;
    if (e2 === undefined)
      throw new q('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
    if (!bn(r2).includes("driverAdapters"))
      throw new q('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
    if (Ur() === "binary")
      throw new q('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.');
  }, datasourceUrl: (e2) => {
    if (typeof e2 < "u" && typeof e2 != "string")
      throw new q(`Invalid value ${JSON.stringify(e2)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
  }, errorFormat: (e2) => {
    if (e2) {
      if (typeof e2 != "string")
        throw new q(`Invalid value ${JSON.stringify(e2)} for "errorFormat" provided to PrismaClient constructor.`);
      if (!vl.includes(e2)) {
        let r2 = Lr(e2, vl);
        throw new q(`Invalid errorFormat ${e2} provided to PrismaClient constructor.${r2}`);
      }
    }
  }, log: (e2) => {
    if (!e2)
      return;
    if (!Array.isArray(e2))
      throw new q(`Invalid value ${JSON.stringify(e2)} for "log" provided to PrismaClient constructor.`);
    function r2(t3) {
      if (typeof t3 == "string" && !Tl.includes(t3)) {
        let n = Lr(t3, Tl);
        throw new q(`Invalid log level "${t3}" provided to PrismaClient constructor.${n}`);
      }
    }
    for (let t3 of e2) {
      r2(t3);
      let n = { level: r2, emit: (i) => {
        let o = ["stdout", "event"];
        if (!o.includes(i)) {
          let s = Lr(i, o);
          throw new q(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
        }
      } };
      if (t3 && typeof t3 == "object")
        for (let [i, o] of Object.entries(t3))
          if (n[i])
            n[i](o);
          else
            throw new q(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
    }
  }, transactionOptions: (e2) => {
    if (!e2)
      return;
    let r2 = e2.maxWait;
    if (r2 != null && r2 <= 0)
      throw new q(`Invalid value ${r2} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);
    let t3 = e2.timeout;
    if (t3 != null && t3 <= 0)
      throw new q(`Invalid value ${t3} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`);
  }, __internal: (e2) => {
    if (!e2)
      return;
    let r2 = ["debug", "engine", "configOverride"];
    if (typeof e2 != "object")
      throw new q(`Invalid value ${JSON.stringify(e2)} for "__internal" to PrismaClient constructor`);
    for (let [t3] of Object.entries(e2))
      if (!r2.includes(t3)) {
        let n = Lr(t3, r2);
        throw new q(`Invalid property ${JSON.stringify(t3)} for "__internal" provided to PrismaClient constructor.${n}`);
      }
  } };
  var Ye = N("prisma:client");
  typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
  var nd = { requestArgsToMiddlewareArgs: (e2) => e2, middlewareArgsToRequestArgs: (e2) => e2 };
  var id = Symbol.for("prisma.client.transaction.id");
  var od = { id: 0, nextId() {
    return ++this.id;
  } };
  var ad = new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
  /*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
});

// node_modules/.prisma/client/index.js
var require_client = __commonJS((exports) => {
  var __dirname = "/home/jam/Projects/Web/Personal/data-management-tool/api/node_modules/.prisma/client";
  Object.defineProperty(exports, "__esModule", { value: true });
  var {
    PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
    PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
    PrismaClientRustPanicError: PrismaClientRustPanicError2,
    PrismaClientInitializationError: PrismaClientInitializationError2,
    PrismaClientValidationError: PrismaClientValidationError2,
    NotFoundError: NotFoundError3,
    getPrismaClient: getPrismaClient2,
    sqltag: sqltag2,
    empty: empty2,
    join: join2,
    raw: raw2,
    Decimal: Decimal2,
    Debug: Debug2,
    objectEnumValues: objectEnumValues2,
    makeStrictEnum: makeStrictEnum2,
    Extensions: Extensions2,
    warnOnce: warnOnce2,
    defineDmmfProperty: defineDmmfProperty2,
    Public: Public2,
    getRuntime: getRuntime2
  } = require_library();
  var Prisma = {};
  exports.Prisma = Prisma;
  exports.$Enums = {};
  Prisma.prismaVersion = {
    client: "5.12.1",
    engine: "473ed3124229e22d881cb7addf559799debae1ab"
  };
  Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
  Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
  Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
  Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
  Prisma.PrismaClientValidationError = PrismaClientValidationError2;
  Prisma.NotFoundError = NotFoundError3;
  Prisma.Decimal = Decimal2;
  Prisma.sql = sqltag2;
  Prisma.empty = empty2;
  Prisma.join = join2;
  Prisma.raw = raw2;
  Prisma.validator = Public2.validator;
  Prisma.getExtensionContext = Extensions2.getExtensionContext;
  Prisma.defineExtension = Extensions2.defineExtension;
  Prisma.DbNull = objectEnumValues2.instances.DbNull;
  Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
  Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
  Prisma.NullTypes = {
    DbNull: objectEnumValues2.classes.DbNull,
    JsonNull: objectEnumValues2.classes.JsonNull,
    AnyNull: objectEnumValues2.classes.AnyNull
  };
  var path = import.meta.require("path");
  exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable"
  });
  exports.Prisma.CrewScalarFieldEnum = {
    id: "id",
    name: "name"
  };
  exports.Prisma.DutyScalarFieldEnum = {
    id: "id",
    name: "name",
    crewmate_id: "crewmate_id"
  };
  exports.Prisma.MonsterScalarFieldEnum = {
    id: "id",
    name: "name",
    is_skinwalker: "is_skinwalker"
  };
  exports.Prisma.SortOrder = {
    asc: "asc",
    desc: "desc"
  };
  exports.Prisma.QueryMode = {
    default: "default",
    insensitive: "insensitive"
  };
  exports.Prisma.NullsOrder = {
    first: "first",
    last: "last"
  };
  exports.Prisma.ModelName = {
    crew: "crew",
    duty: "duty",
    monster: "monster"
  };
  var config2 = {
    generator: {
      name: "client",
      provider: {
        fromEnvVar: null,
        value: "prisma-client-js"
      },
      output: {
        value: "/home/bun/app/node_modules/@prisma/client",
        fromEnvVar: null
      },
      config: {
        engineType: "library"
      },
      binaryTargets: [
        {
          fromEnvVar: null,
          value: "debian-openssl-1.1.x",
          native: true
        },
        {
          fromEnvVar: null,
          value: "debian-openssl-1.1.x"
        },
        {
          fromEnvVar: null,
          value: "darwin"
        }
      ],
      previewFeatures: []
    },
    relativeEnvPaths: {
      rootEnvPath: null,
      schemaEnvPath: "../../../.env"
    },
    relativePath: "../../../prisma",
    clientVersion: "5.12.1",
    engineVersion: "473ed3124229e22d881cb7addf559799debae1ab",
    datasourceNames: [
      "db"
    ],
    activeProvider: "postgresql",
    inlineDatasources: {
      db: {
        url: {
          fromEnvVar: "DATABASE_URL",
          value: null
        }
      }
    },
    inlineSchema: "generator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = [\"native\", \"debian-openssl-1.1.x\", \"darwin\"]\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel crew {\n  id   Int    @id @default(autoincrement())\n  name String @unique(map: \"crew_username_key\") @db.VarChar(255)\n  duty duty?\n}\n\nmodel duty {\n  id          Int     @id @default(autoincrement())\n  name        String?\n  crewmate_id Int     @unique\n  crew        crew    @relation(fields: [crewmate_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n}\n\nmodel monster {\n  id            Int      @id @default(autoincrement())\n  name          String?\n  is_skinwalker Boolean?\n}\n\n/// We could not retrieve columns for the underlying table. Either it has none or you are missing rights to see them. Please check your privileges.\n// model undefined {\n// }\n\n/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.\nmodel what {\n  test_col String?\n\n  @@ignore\n}\n",
    inlineSchemaHash: "6958330d072b399ca28d300c631ce80a7d9cc4c6bf3d4335e55c7f8c20d18daa",
    copyEngine: true
  };
  var fs = import.meta.require("fs");
  config2.dirname = __dirname;
  if (!fs.existsSync(path.join(__dirname, "schema.prisma"))) {
    const alternativePaths = [
      "node_modules/.prisma/client",
      ".prisma/client"
    ];
    const alternativePath = alternativePaths.find((altPath) => {
      return fs.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
    }) ?? alternativePaths[0];
    config2.dirname = path.join(process.cwd(), alternativePath);
    config2.isBundled = true;
  }
  config2.runtimeDataModel = JSON.parse("{\"models\":{\"crew\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"duty\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"duty\",\"relationName\":\"crewToduty\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"duty\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"crewmate_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"crew\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"crew\",\"relationName\":\"crewToduty\",\"relationFromFields\":[\"crewmate_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"NoAction\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"monster\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"is_skinwalker\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Boolean\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false}},\"enums\":{},\"types\":{}}");
  defineDmmfProperty2(exports.Prisma, config2.runtimeDataModel);
  config2.engineWasm = undefined;
  var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
  warnEnvConflicts2({
    rootEnvPath: config2.relativeEnvPaths.rootEnvPath && path.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),
    schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && path.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)
  });
  var PrismaClient = getPrismaClient2(config2);
  exports.PrismaClient = PrismaClient;
  Object.assign(exports, Prisma);
  path.join(__dirname, "libquery_engine-debian-openssl-1.1.x.so.node");
  path.join(process.cwd(), "node_modules/.prisma/client/libquery_engine-debian-openssl-1.1.x.so.node");
  path.join(__dirname, "libquery_engine-darwin.dylib.node");
  path.join(process.cwd(), "node_modules/.prisma/client/libquery_engine-darwin.dylib.node");
  path.join(__dirname, "schema.prisma");
  path.join(process.cwd(), "node_modules/.prisma/client/schema.prisma");
});

// node_modules/.prisma/client/default.js
var require_default = __commonJS((exports, module) => {
  module.exports = { ...require_client() };
});

// node_modules/@prisma/client/default.js
var require_default2 = __commonJS((exports, module) => {
  module.exports = {
    ...require_default()
  };
});

// node_modules/@kitajs/html/index.js
var require_html = __commonJS((exports, module) => {
  var isUpper = function(input, index) {
    const code = input.charCodeAt(index);
    return code >= 65 && code <= 90;
  };
  var toKebabCase = function(camel) {
    if (!CAMEL_REGEX.test(camel)) {
      return camel;
    }
    const length = camel.length;
    let start = 0;
    let end = 0;
    let kebab = "";
    let prev = true;
    let curr = isUpper(camel, 0);
    let next;
    for (;end < length; end++) {
      next = isUpper(camel, end + 1);
      if (!prev && curr && !next) {
        kebab += camel.slice(start, end) + "-" + camel[end].toLowerCase();
        start = end + 1;
      }
      prev = curr;
      curr = next;
    }
    kebab += camel.slice(start, end);
    return kebab;
  };
  var escape = function(strings, ...values) {
    const stringsLength = strings.length;
    const valuesLength = values.length;
    let index = 0;
    let result = "";
    for (;index < stringsLength; index++) {
      result += strings[index];
      if (index < valuesLength) {
        result += values[index];
      }
    }
    return escapeHtml(result);
  };
  var isVoidElement = function(tag) {
    return tag === "meta" || tag === "link" || tag === "img" || tag === "br" || tag === "input" || tag === "hr" || tag === "area" || tag === "base" || tag === "col" || tag === "command" || tag === "embed" || tag === "keygen" || tag === "param" || tag === "source" || tag === "track" || tag === "wbr";
  };
  var styleToString = function(style) {
    if (typeof style === "string") {
      let end2 = style.indexOf('"');
      if (end2 === -1) {
        return style;
      }
      const length2 = style.length;
      let escaped = "";
      let start2 = 0;
      for (;end2 < length2; end2++) {
        if (style[end2] === '"') {
          escaped += style.slice(start2, end2) + "&#34;";
          start2 = end2 + 1;
        }
      }
      escaped += style.slice(start2, end2);
      return escaped;
    }
    const keys = Object.keys(style);
    const length = keys.length;
    let key, value15, end, start;
    let index = 0;
    let result = "";
    for (;index < length; index++) {
      key = keys[index];
      value15 = style[key];
      if (value15 === null || value15 === undefined) {
        continue;
      }
      result += toKebabCase(key) + ":";
      if (typeof value15 !== "string") {
        result += value15.toString() + ";";
        continue;
      }
      end = value15.indexOf('"');
      if (end === -1) {
        result += value15 + ";";
        continue;
      }
      const length2 = value15.length;
      start = 0;
      for (;end < length2; end++) {
        if (value15[end] === '"') {
          result += value15.slice(start, end) + "&#34;";
          start = end + 1;
        }
      }
      result += value15.slice(start, end) + ";";
    }
    return result;
  };
  var attributesToString = function(attributes) {
    const keys = Object.keys(attributes);
    const length = keys.length;
    let key, value15, type74, end, start, classItems, valueLength;
    let result = "";
    let index = 0;
    for (;index < length; index++) {
      key = keys[index];
      if (key === "children" || key === "safe") {
        continue;
      }
      value15 = attributes[key];
      if (key === "className") {
        if (attributes.class !== undefined) {
          continue;
        }
        key = "class";
      } else if (key === "class" && Array.isArray(value15)) {
        classItems = value15;
        valueLength = value15.length;
        value15 = "";
        for (let i = 0;i < valueLength; i++) {
          if (classItems[i] && classItems[i].length > 0) {
            if (value15) {
              value15 += " " + classItems[i].trim();
            } else {
              value15 += classItems[i].trim();
            }
          }
        }
        if (value15.length === 0) {
          continue;
        }
      } else if (key === "style") {
        result += ' style="' + styleToString(value15) + '"';
        continue;
      } else if (key === "attrs") {
        if (typeof value15 === "string") {
          result += " " + value15;
        } else {
          result += attributesToString(value15);
        }
        continue;
      }
      type74 = typeof value15;
      if (type74 === "boolean") {
        if (value15) {
          result += " " + key;
        }
        continue;
      }
      if (value15 === null || value15 === undefined) {
        continue;
      }
      result += " " + key;
      if (type74 !== "string") {
        if (type74 !== "object") {
          result += '="' + value15.toString() + '"';
          continue;
        }
        if (value15 instanceof Date) {
          result += '="' + value15.toISOString() + '"';
          continue;
        }
        value15 = value15.toString();
      }
      end = value15.indexOf('"');
      if (end === -1) {
        result += '="' + value15 + '"';
        continue;
      }
      result += '="';
      valueLength = value15.length;
      start = 0;
      for (;end < valueLength; end++) {
        if (value15[end] === '"') {
          result += value15.slice(start, end) + "&#34;";
          start = end + 1;
        }
      }
      result += value15.slice(start, end) + '"';
    }
    return result;
  };
  var contentsToString = function(contents, escape2) {
    let length = contents.length;
    let result = "";
    let content;
    let index = 0;
    for (;index < length; index++) {
      content = contents[index];
      if (typeof content !== "string") {
        if (!content && content !== 0) {
          continue;
        }
        if (content.then) {
          return Promise.all(contents.slice(index)).then(function resolveAsyncContent(resolved) {
            resolved.unshift(result);
            return contentsToString(resolved, escape2);
          });
        }
        if (Array.isArray(content)) {
          contents.splice(index--, 1, ...content);
          length += content.length - 1;
          continue;
        }
      }
      result += content;
    }
    if (escape2 === true) {
      return escapeHtml(result);
    }
    return result;
  };
  var createElement = function(name, attrs, ...children) {
    const hasAttrs = attrs !== null;
    if (typeof name === "function") {
      if (!hasAttrs) {
        attrs = { children: children.length > 1 ? children : children[0] };
      } else if (attrs.children === undefined) {
        attrs.children = children.length > 1 ? children : children[0];
      }
      return name(attrs);
    }
    if (hasAttrs && name === "tag") {
      name = String(attrs.of);
      delete attrs.of;
    }
    const attributes = hasAttrs ? attributesToString(attrs) : "";
    if (children.length === 0 && isVoidElement(name)) {
      return "<" + name + attributes + "/>";
    }
    const contents = contentsToString(children, hasAttrs && attrs.safe);
    if (typeof contents === "string") {
      return "<" + name + attributes + ">" + contents + "</" + name + ">";
    }
    return contents.then(function asyncChildren(child) {
      return "<" + name + attributes + ">" + child + "</" + name + ">";
    });
  };
  var Fragment = function(props) {
    return Html2.contentsToString([props.children]);
  };
  var compile = function(htmlFn, strict4 = true, separator = "/*\0*/") {
    if (typeof htmlFn !== "function") {
      throw new Error("The first argument must be a function.");
    }
    const properties = new Set;
    const html = htmlFn(new Proxy({}, {
      get(_, name) {
        properties.add(name);
        const isChildren = name === "children";
        let access = `args[${separator}\`${name.toString()}\`${separator}]`;
        if (isChildren) {
          access = `Array.isArray(${access}) ? ${access}.join(${separator}\`\`${separator}) : ${access}`;
        }
        return `\`${separator} + (${access} || ${strict4 && !isChildren ? `throwPropertyNotFound(${separator}\`${name.toString()}\`${separator})` : `${separator}\`\`${separator}`}) + ${separator}\``;
      }
    }));
    if (typeof html !== "string") {
      throw new Error("You cannot use compile() with async components.");
    }
    const sepLength = separator.length;
    const length = html.length;
    let body = "";
    let nextStart = 0;
    let index = 0;
    for (;index < length; index++) {
      if (html[index] === "`" && html.slice(index - sepLength, index) !== separator && html.slice(index + 1, index + sepLength + 1) !== separator) {
        body += html.slice(nextStart, index) + "\\`";
        nextStart = index + 1;
        continue;
      }
    }
    body += html.slice(nextStart);
    if (strict4) {
      return Function("args", 'if (args === undefined) { throw new Error("The arguments object was not provided.") };\nfunction throwPropertyNotFound(name) { throw new Error("Property " + name + " was not provided.") };\n' + `return \`${body}\``);
    }
    return Function("args", "if (args === undefined) { args = Object.create(null) };\n" + `return \`${body}\``);
  };
  var ESCAPED_REGEX = /[<"'&]/;
  var CAMEL_REGEX = /[a-z][A-Z]/;
  var escapeHtml = function(value15) {
    if (typeof value15 !== "string") {
      value15 = value15.toString();
    }
    if (!ESCAPED_REGEX.test(value15)) {
      return value15;
    }
    const length = value15.length;
    let escaped = "";
    let start = 0;
    let end = 0;
    for (;end < length; end++) {
      switch (value15[end]) {
        case "&":
          escaped += value15.slice(start, end) + "&amp;";
          start = end + 1;
          continue;
        case "<":
          escaped += value15.slice(start, end) + "&lt;";
          start = end + 1;
          continue;
        case '"':
          escaped += value15.slice(start, end) + "&#34;";
          start = end + 1;
          continue;
        case "'":
          escaped += value15.slice(start, end) + "&#39;";
          start = end + 1;
          continue;
      }
    }
    escaped += value15.slice(start, end);
    return escaped;
  };
  if (typeof Bun !== "undefined")
    escapeHtml = Bun.escapeHTML;
  var Html2 = {
    escape,
    e: escape,
    escapeHtml,
    isVoidElement,
    attributesToString,
    toKebabCase,
    isUpper,
    styleToString,
    createElement,
    h: createElement,
    contentsToString,
    compile,
    Fragment
  };
  module.exports = Html2;
  module.exports.Html = Html2;
  module.exports.default = Html2;
});

// node_modules/@kitajs/html/register.js
var require_register = __commonJS(() => {
  var root;
  try {
    root = Function("return this")();
  } catch (_) {
    root = window;
  }
  if (!root.Html) {
    root.Html = require_html();
  }
  if (root.Html.default) {
    root.Html = root.Html.default;
  }
});

// node_modules/@poppinss/validator-lite/build/src/contracts/index.js
var require_contracts = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@poppinss/validator-lite/build/src/schema/helpers.js
var require_helpers = __commonJS((exports) => {
  var ensureValue = function(key, value15, message) {
    if (!value15) {
      throw new Error(message || `Missing environment variable "${key}"`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ensureValue = exports.BOOLEAN_NEGATIVES = exports.BOOLEAN_POSITIVES = undefined;
  exports.BOOLEAN_POSITIVES = ["1", 1, "true", true];
  exports.BOOLEAN_NEGATIVES = ["0", 0, "false", false];
  exports.ensureValue = ensureValue;
});

// node_modules/@poppinss/validator-lite/build/src/schema/number.js
var require_number = __commonJS((exports) => {
  var castToNumber = function(key, value15, message) {
    const castedValue = Number(value15);
    if (isNaN(castedValue)) {
      throw new Error(message || `Value for environment variable "${key}" must be numeric, instead received "${value15}"`);
    }
    return castedValue;
  };
  var number7 = function(options2) {
    return function validate(key, value15) {
      (0, helpers_1.ensureValue)(key, value15, options2?.message);
      return castToNumber(key, value15, options2?.message);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.number = exports.castToNumber = undefined;
  var helpers_1 = require_helpers();
  exports.castToNumber = castToNumber;
  exports.number = number7;
  number7.optional = function optionalNumber(options2) {
    return function validate(key, value15) {
      if (!value15) {
        return;
      }
      return castToNumber(key, value15, options2?.message);
    };
  };
});

// node_modules/validator/lib/util/assertString.js
var require_assertString = __commonJS((exports, module) => {
  var _typeof = function(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  };
  var assertString = function(input) {
    var isString = typeof input === "string" || input instanceof String;
    if (!isString) {
      var invalidType = _typeof(input);
      if (input === null)
        invalidType = "null";
      else if (invalidType === "object")
        invalidType = input.constructor.name;
      throw new TypeError("Expected a string but received a ".concat(invalidType));
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assertString;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isByteLength.js
var require_isByteLength = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _typeof = function(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  };
  var isByteLength = function(str, options2) {
    (0, _assertString.default)(str);
    var min;
    var max;
    if (_typeof(options2) === "object") {
      min = options2.min || 0;
      max = options2.max;
    } else {
      min = arguments[1];
      max = arguments[2];
    }
    var len = encodeURI(str).split(/%..|./).length - 1;
    return len >= min && (typeof max === "undefined" || len <= max);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isByteLength;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/util/merge.js
var require_merge = __commonJS((exports, module) => {
  var merge = function() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var defaults = arguments.length > 1 ? arguments[1] : undefined;
    for (var key in defaults) {
      if (typeof obj[key] === "undefined") {
        obj[key] = defaults[key];
      }
    }
    return obj;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = merge;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isFQDN.js
var require_isFQDN = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isFQDN = function(str, options2) {
    (0, _assertString.default)(str);
    options2 = (0, _merge.default)(options2, default_fqdn_options);
    if (options2.allow_trailing_dot && str[str.length - 1] === ".") {
      str = str.substring(0, str.length - 1);
    }
    if (options2.allow_wildcard === true && str.indexOf("*.") === 0) {
      str = str.substring(2);
    }
    var parts = str.split(".");
    var tld = parts[parts.length - 1];
    if (options2.require_tld) {
      if (parts.length < 2) {
        return false;
      }
      if (!options2.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
        return false;
      }
      if (/\s/.test(tld)) {
        return false;
      }
    }
    if (!options2.allow_numeric_tld && /^\d+$/.test(tld)) {
      return false;
    }
    return parts.every(function(part) {
      if (part.length > 63 && !options2.ignore_max_length) {
        return false;
      }
      if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
        return false;
      }
      if (/[\uff01-\uff5e]/.test(part)) {
        return false;
      }
      if (/^-|-$/.test(part)) {
        return false;
      }
      if (!options2.allow_underscores && /_/.test(part)) {
        return false;
      }
      return true;
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFQDN;
  var _assertString = _interopRequireDefault(require_assertString());
  var _merge = _interopRequireDefault(require_merge());
  var default_fqdn_options = {
    require_tld: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_numeric_tld: false,
    allow_wildcard: false,
    ignore_max_length: false
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isIP.js
var require_isIP = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isIP = function(str) {
    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    (0, _assertString.default)(str);
    version = String(version);
    if (!version) {
      return isIP(str, 4) || isIP(str, 6);
    }
    if (version === "4") {
      return IPv4AddressRegExp.test(str);
    }
    if (version === "6") {
      return IPv6AddressRegExp.test(str);
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIP;
  var _assertString = _interopRequireDefault(require_assertString());
  var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
  var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
  var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
  var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isEmail.js
var require_isEmail = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validateDisplayName = function(display_name) {
    var display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
    if (!display_name_without_quotes.trim()) {
      return false;
    }
    var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
    if (contains_illegal) {
      if (display_name_without_quotes === display_name) {
        return false;
      }
      var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
      if (!all_start_with_back_slash) {
        return false;
      }
    }
    return true;
  };
  var isEmail = function(str, options2) {
    (0, _assertString.default)(str);
    options2 = (0, _merge.default)(options2, default_email_options);
    if (options2.require_display_name || options2.allow_display_name) {
      var display_email = str.match(splitNameAddress);
      if (display_email) {
        var display_name = display_email[1];
        str = str.replace(display_name, "").replace(/(^<|>$)/g, "");
        if (display_name.endsWith(" ")) {
          display_name = display_name.slice(0, -1);
        }
        if (!validateDisplayName(display_name)) {
          return false;
        }
      } else if (options2.require_display_name) {
        return false;
      }
    }
    if (!options2.ignore_max_length && str.length > defaultMaxEmailLength) {
      return false;
    }
    var parts = str.split("@");
    var domain = parts.pop();
    var lower_domain = domain.toLowerCase();
    if (options2.host_blacklist.includes(lower_domain)) {
      return false;
    }
    if (options2.host_whitelist.length > 0 && !options2.host_whitelist.includes(lower_domain)) {
      return false;
    }
    var user = parts.join("@");
    if (options2.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
      user = user.toLowerCase();
      var username = user.split("+")[0];
      if (!(0, _isByteLength.default)(username.replace(/\./g, ""), {
        min: 6,
        max: 30
      })) {
        return false;
      }
      var _user_parts = username.split(".");
      for (var i = 0;i < _user_parts.length; i++) {
        if (!gmailUserPart.test(_user_parts[i])) {
          return false;
        }
      }
    }
    if (options2.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
      max: 64
    }) || !(0, _isByteLength.default)(domain, {
      max: 254
    }))) {
      return false;
    }
    if (!(0, _isFQDN.default)(domain, {
      require_tld: options2.require_tld,
      ignore_max_length: options2.ignore_max_length,
      allow_underscores: options2.allow_underscores
    })) {
      if (!options2.allow_ip_domain) {
        return false;
      }
      if (!(0, _isIP.default)(domain)) {
        if (!domain.startsWith("[") || !domain.endsWith("]")) {
          return false;
        }
        var noBracketdomain = domain.slice(1, -1);
        if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
          return false;
        }
      }
    }
    if (user[0] === '"') {
      user = user.slice(1, user.length - 1);
      return options2.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
    }
    var pattern3 = options2.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
    var user_parts = user.split(".");
    for (var _i = 0;_i < user_parts.length; _i++) {
      if (!pattern3.test(user_parts[_i])) {
        return false;
      }
    }
    if (options2.blacklisted_chars) {
      if (user.search(new RegExp("[".concat(options2.blacklisted_chars, "]+"), "g")) !== -1)
        return false;
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEmail;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isByteLength = _interopRequireDefault(require_isByteLength());
  var _isFQDN = _interopRequireDefault(require_isFQDN());
  var _isIP = _interopRequireDefault(require_isIP());
  var _merge = _interopRequireDefault(require_merge());
  var default_email_options = {
    allow_display_name: false,
    allow_underscores: false,
    require_display_name: false,
    allow_utf8_local_part: true,
    require_tld: true,
    blacklisted_chars: "",
    ignore_max_length: false,
    host_blacklist: [],
    host_whitelist: []
  };
  var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
  var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
  var gmailUserPart = /^[a-z\d]+$/;
  var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
  var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
  var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
  var defaultMaxEmailLength = 254;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isURL.js
var require_isURL = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _slicedToArray = function(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  };
  var _nonIterableRest = function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  };
  var _unsupportedIterableToArray = function(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  };
  var _arrayLikeToArray = function(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len);i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  };
  var _iterableToArrayLimit = function(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (var _i = arr[Symbol.iterator](), _s;!(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  };
  var _arrayWithHoles = function(arr) {
    if (Array.isArray(arr))
      return arr;
  };
  var isRegExp = function(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var checkHost = function(host, matches) {
    for (var i = 0;i < matches.length; i++) {
      var match = matches[i];
      if (host === match || isRegExp(match) && match.test(host)) {
        return true;
      }
    }
    return false;
  };
  var isURL = function(url, options2) {
    (0, _assertString.default)(url);
    if (!url || /[\s<>]/.test(url)) {
      return false;
    }
    if (url.indexOf("mailto:") === 0) {
      return false;
    }
    options2 = (0, _merge.default)(options2, default_url_options);
    if (options2.validate_length && url.length >= 2083) {
      return false;
    }
    if (!options2.allow_fragments && url.includes("#")) {
      return false;
    }
    if (!options2.allow_query_components && (url.includes("?") || url.includes("&"))) {
      return false;
    }
    var protocol, auth, host, hostname, port, port_str, split, ipv6;
    split = url.split("#");
    url = split.shift();
    split = url.split("?");
    url = split.shift();
    split = url.split("://");
    if (split.length > 1) {
      protocol = split.shift().toLowerCase();
      if (options2.require_valid_protocol && options2.protocols.indexOf(protocol) === -1) {
        return false;
      }
    } else if (options2.require_protocol) {
      return false;
    } else if (url.slice(0, 2) === "//") {
      if (!options2.allow_protocol_relative_urls) {
        return false;
      }
      split[0] = url.slice(2);
    }
    url = split.join("://");
    if (url === "") {
      return false;
    }
    split = url.split("/");
    url = split.shift();
    if (url === "" && !options2.require_host) {
      return true;
    }
    split = url.split("@");
    if (split.length > 1) {
      if (options2.disallow_auth) {
        return false;
      }
      if (split[0] === "") {
        return false;
      }
      auth = split.shift();
      if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
        return false;
      }
      var _auth$split = auth.split(":"), _auth$split2 = _slicedToArray(_auth$split, 2), user = _auth$split2[0], password = _auth$split2[1];
      if (user === "" && password === "") {
        return false;
      }
    }
    hostname = split.join("@");
    port_str = null;
    ipv6 = null;
    var ipv6_match = hostname.match(wrapped_ipv6);
    if (ipv6_match) {
      host = "";
      ipv6 = ipv6_match[1];
      port_str = ipv6_match[2] || null;
    } else {
      split = hostname.split(":");
      host = split.shift();
      if (split.length) {
        port_str = split.join(":");
      }
    }
    if (port_str !== null && port_str.length > 0) {
      port = parseInt(port_str, 10);
      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
        return false;
      }
    } else if (options2.require_port) {
      return false;
    }
    if (options2.host_whitelist) {
      return checkHost(host, options2.host_whitelist);
    }
    if (host === "" && !options2.require_host) {
      return true;
    }
    if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options2) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
      return false;
    }
    host = host || ipv6;
    if (options2.host_blacklist && checkHost(host, options2.host_blacklist)) {
      return false;
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isURL;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isFQDN = _interopRequireDefault(require_isFQDN());
  var _isIP = _interopRequireDefault(require_isIP());
  var _merge = _interopRequireDefault(require_merge());
  var default_url_options = {
    protocols: ["http", "https", "ftp"],
    require_tld: true,
    require_protocol: false,
    require_host: true,
    require_port: false,
    require_valid_protocol: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_protocol_relative_urls: false,
    allow_fragments: true,
    allow_query_components: true,
    validate_length: true
  };
  var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/@poppinss/validator-lite/build/src/schema/string.js
var require_string = __commonJS((exports) => {
  var string7 = function(options2) {
    return function validate(key, value15) {
      (0, helpers_1.ensureValue)(key, value15, options2?.message);
      if (options2?.format) {
        formats[options2.format](key, value15, options2);
      }
      return value15;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.string = undefined;
  var helpers_1 = require_helpers();
  var formats = {
    email: (key, value15, options2) => {
      if (!require_isEmail()(value15)) {
        throw new Error(options2.message || `Value for environment variable "${key}" must be a valid email, instead received "${value15}"`);
      }
    },
    host: (key, value15, options2) => {
      if (!require_isFQDN()(value15, { require_tld: false }) && !require_isIP()(value15)) {
        throw new Error(options2.message || `Value for environment variable "${key}" must be a valid (domain or ip), instead received "${value15}"`);
      }
    },
    url: (key, value15, options2) => {
      const { tld = true, protocol = true } = options2;
      if (!require_isURL()(value15, { require_tld: tld, require_protocol: protocol })) {
        throw new Error(options2.message || `Value for environment variable "${key}" must be a valid URL, instead received "${value15}"`);
      }
    }
  };
  exports.string = string7;
  string7.optional = function optionalString(options2) {
    return function validate(key, value15) {
      if (!value15) {
        return;
      }
      if (options2?.format) {
        formats[options2.format](key, value15, options2);
      }
      return value15;
    };
  };
});

// node_modules/@poppinss/validator-lite/build/src/schema/boolean.js
var require_boolean = __commonJS((exports) => {
  var castToBoolean = function(key, value15, message) {
    if (helpers_1.BOOLEAN_POSITIVES.includes(value15)) {
      return true;
    }
    if (helpers_1.BOOLEAN_NEGATIVES.includes(value15)) {
      return false;
    }
    throw new Error(message || `Value for environment variable "${key}" must be a boolean, instead received "${value15}"`);
  };
  var boolean5 = function(options2) {
    return function validate(key, value15) {
      (0, helpers_1.ensureValue)(key, value15, options2?.message);
      return castToBoolean(key, value15, options2?.message);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.boolean = undefined;
  var helpers_1 = require_helpers();
  exports.boolean = boolean5;
  boolean5.optional = function optionalBoolean(options2) {
    return function validate(key, value15) {
      if (!value15) {
        return;
      }
      return castToBoolean(key, value15, options2?.message);
    };
  };
});

// node_modules/@poppinss/validator-lite/build/src/schema/oneOf.js
var require_oneOf = __commonJS((exports) => {
  var ensureOneOf = function(choices, key, value15, message) {
    if (helpers_1.BOOLEAN_NEGATIVES.includes(value15)) {
      value15 = false;
    } else if (helpers_1.BOOLEAN_POSITIVES.includes(value15)) {
      value15 = true;
    } else {
      const toNumber = Number(value15);
      if (!isNaN(toNumber)) {
        value15 = toNumber;
      }
    }
    if (choices.includes(value15)) {
      return value15;
    }
    throw new Error(message || `Value for environment variable "${key}" must be one of "${choices.join(",")}", instead received "${value15}"`);
  };
  var oneOf = function(choices, options2) {
    return function validate(key, value15) {
      (0, helpers_1.ensureValue)(key, value15, options2?.message);
      return ensureOneOf(choices, key, value15, options2?.message);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.oneOf = undefined;
  var helpers_1 = require_helpers();
  exports.oneOf = oneOf;
  oneOf.optional = function optionalEnum(choices, options2) {
    return function validate(key, value15) {
      if (!value15) {
        return;
      }
      return ensureOneOf(choices, key, value15, options2?.message);
    };
  };
});

// node_modules/@poppinss/validator-lite/build/src/schema/index.js
var require_schema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.schema = undefined;
  var number_1 = require_number();
  var string_1 = require_string();
  var boolean_1 = require_boolean();
  var oneOf_1 = require_oneOf();
  exports.schema = {
    number: number_1.number,
    string: string_1.string,
    boolean: boolean_1.boolean,
    enum: oneOf_1.oneOf
  };
});

// node_modules/@poppinss/validator-lite/build/index.js
var require_build = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.schema = undefined;
  __exportStar(require_contracts(), exports);
  var index_1 = require_schema();
  Object.defineProperty(exports, "schema", { enumerable: true, get: function() {
    return index_1.schema;
  } });
});

// node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS((exports, module) => {
  var _parse = function(text, reviver, options2) {
    if (options2 == null) {
      if (reviver !== null && typeof reviver === "object") {
        options2 = reviver;
        reviver = undefined;
      }
    }
    if (hasBuffer && Buffer.isBuffer(text)) {
      text = text.toString();
    }
    if (text && text.charCodeAt(0) === 65279) {
      text = text.slice(1);
    }
    const obj = JSON.parse(text, reviver);
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    const protoAction = options2 && options2.protoAction || "error";
    const constructorAction = options2 && options2.constructorAction || "error";
    if (protoAction === "ignore" && constructorAction === "ignore") {
      return obj;
    }
    if (protoAction !== "ignore" && constructorAction !== "ignore") {
      if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
        return obj;
      }
    } else if (protoAction !== "ignore" && constructorAction === "ignore") {
      if (suspectProtoRx.test(text) === false) {
        return obj;
      }
    } else {
      if (suspectConstructorRx.test(text) === false) {
        return obj;
      }
    }
    return filter(obj, { protoAction, constructorAction, safe: options2 && options2.safe });
  };
  var filter = function(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
    let next = [obj];
    while (next.length) {
      const nodes = next;
      next = [];
      for (const node of nodes) {
        if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
          if (safe === true) {
            return null;
          } else if (protoAction === "error") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node.__proto__;
        }
        if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
          if (safe === true) {
            return null;
          } else if (constructorAction === "error") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node.constructor;
        }
        for (const key in node) {
          const value15 = node[key];
          if (value15 && typeof value15 === "object") {
            next.push(value15);
          }
        }
      }
    }
    return obj;
  };
  var parse6 = function(text, reviver, options2) {
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
      return _parse(text, reviver, options2);
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  };
  var safeParse = function(text, reviver) {
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
      return _parse(text, reviver, { safe: true });
    } catch (_e) {
      return null;
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  };
  var hasBuffer = typeof Buffer !== "undefined";
  var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
  var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
  module.exports = parse6;
  module.exports.default = parse6;
  module.exports.parse = parse6;
  module.exports.safeParse = safeParse;
  module.exports.scan = filter;
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS((exports, module) => {
  var strEscape = function(str) {
    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
      return `"${str}"`;
    }
    return JSON.stringify(str);
  };
  var insertSort = function(array5) {
    if (array5.length > 200) {
      return array5.sort();
    }
    for (let i = 1;i < array5.length; i++) {
      const currentValue = array5[i];
      let position = i;
      while (position !== 0 && array5[position - 1] > currentValue) {
        array5[position] = array5[position - 1];
        position--;
      }
      array5[position] = currentValue;
    }
    return array5;
  };
  var isTypedArrayWithEntries = function(value15) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value15) !== undefined && value15.length !== 0;
  };
  var stringifyTypedArray = function(array5, separator, maximumBreadth) {
    if (array5.length < maximumBreadth) {
      maximumBreadth = array5.length;
    }
    const whitespace = separator === "," ? "" : " ";
    let res = `"0":${whitespace}${array5[0]}`;
    for (let i = 1;i < maximumBreadth; i++) {
      res += `${separator}"${i}":${whitespace}${array5[i]}`;
    }
    return res;
  };
  var getCircularValueOption = function(options2) {
    if (hasOwnProperty.call(options2, "circularValue")) {
      const circularValue = options2.circularValue;
      if (typeof circularValue === "string") {
        return `"${circularValue}"`;
      }
      if (circularValue == null) {
        return circularValue;
      }
      if (circularValue === Error || circularValue === TypeError) {
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      }
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  };
  var getBooleanOption = function(options2, key) {
    let value15;
    if (hasOwnProperty.call(options2, key)) {
      value15 = options2[key];
      if (typeof value15 !== "boolean") {
        throw new TypeError(`The "${key}" argument must be of type boolean`);
      }
    }
    return value15 === undefined ? true : value15;
  };
  var getPositiveIntegerOption = function(options2, key) {
    let value15;
    if (hasOwnProperty.call(options2, key)) {
      value15 = options2[key];
      if (typeof value15 !== "number") {
        throw new TypeError(`The "${key}" argument must be of type number`);
      }
      if (!Number.isInteger(value15)) {
        throw new TypeError(`The "${key}" argument must be an integer`);
      }
      if (value15 < 1) {
        throw new RangeError(`The "${key}" argument must be >= 1`);
      }
    }
    return value15 === undefined ? Infinity : value15;
  };
  var getItemCount = function(number7) {
    if (number7 === 1) {
      return "1 item";
    }
    return `${number7} items`;
  };
  var getUniqueReplacerSet = function(replacerArray) {
    const replacerSet = new Set;
    for (const value15 of replacerArray) {
      if (typeof value15 === "string" || typeof value15 === "number") {
        replacerSet.add(String(value15));
      }
    }
    return replacerSet;
  };
  var getStrictOption = function(options2) {
    if (hasOwnProperty.call(options2, "strict")) {
      const value15 = options2.strict;
      if (typeof value15 !== "boolean") {
        throw new TypeError('The "strict" argument must be of type boolean');
      }
      if (value15) {
        return (value16) => {
          let message = `Object can not safely be stringified. Received type ${typeof value16}`;
          if (typeof value16 !== "function")
            message += ` (${value16.toString()})`;
          throw new Error(message);
        };
      }
    }
  };
  var configure = function(options2) {
    options2 = { ...options2 };
    const fail = getStrictOption(options2);
    if (fail) {
      if (options2.bigint === undefined) {
        options2.bigint = false;
      }
      if (!("circularValue" in options2)) {
        options2.circularValue = Error;
      }
    }
    const circularValue = getCircularValueOption(options2);
    const bigint6 = getBooleanOption(options2, "bigint");
    const deterministic = getBooleanOption(options2, "deterministic");
    const maximumDepth = getPositiveIntegerOption(options2, "maximumDepth");
    const maximumBreadth = getPositiveIntegerOption(options2, "maximumBreadth");
    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
      let value15 = parent[key];
      if (typeof value15 === "object" && value15 !== null && typeof value15.toJSON === "function") {
        value15 = value15.toJSON(key);
      }
      value15 = replacer.call(parent, key, value15);
      switch (typeof value15) {
        case "string":
          return strEscape(value15);
        case "object": {
          if (value15 === null) {
            return "null";
          }
          if (stack.indexOf(value15) !== -1) {
            return circularValue;
          }
          let res = "";
          let join3 = ",";
          const originalIndentation = indentation;
          if (Array.isArray(value15)) {
            if (value15.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value15);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join3 = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value15.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyFnReplacer(String(i), value15, stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join3;
            }
            const tmp = stringifyFnReplacer(String(i), value15, stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value15.length - 1 > maximumBreadth) {
              const removedKeys = value15.length - maximumBreadth - 1;
              res += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value15);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let whitespace = "";
          let separator = "";
          if (spacer !== "") {
            indentation += spacer;
            join3 = `,\n${indentation}`;
            whitespace = " ";
          }
          const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (deterministic && !isTypedArrayWithEntries(value15)) {
            keys = insertSort(keys);
          }
          stack.push(value15);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyFnReplacer(key2, value15, stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join3;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
            separator = join3;
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value15) ? String(value15) : fail ? fail(value15) : "null";
        case "boolean":
          return value15 === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint6) {
            return String(value15);
          }
        default:
          return fail ? fail(value15) : undefined;
      }
    }
    function stringifyArrayReplacer(key, value15, stack, replacer, spacer, indentation) {
      if (typeof value15 === "object" && value15 !== null && typeof value15.toJSON === "function") {
        value15 = value15.toJSON(key);
      }
      switch (typeof value15) {
        case "string":
          return strEscape(value15);
        case "object": {
          if (value15 === null) {
            return "null";
          }
          if (stack.indexOf(value15) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          let res = "";
          let join3 = ",";
          if (Array.isArray(value15)) {
            if (value15.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value15);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join3 = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value15.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyArrayReplacer(String(i), value15[i], stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join3;
            }
            const tmp = stringifyArrayReplacer(String(i), value15[i], stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value15.length - 1 > maximumBreadth) {
              const removedKeys = value15.length - maximumBreadth - 1;
              res += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          stack.push(value15);
          let whitespace = "";
          if (spacer !== "") {
            indentation += spacer;
            join3 = `,\n${indentation}`;
            whitespace = " ";
          }
          let separator = "";
          for (const key2 of replacer) {
            const tmp = stringifyArrayReplacer(key2, value15[key2], stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join3;
            }
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value15) ? String(value15) : fail ? fail(value15) : "null";
        case "boolean":
          return value15 === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint6) {
            return String(value15);
          }
        default:
          return fail ? fail(value15) : undefined;
      }
    }
    function stringifyIndent(key, value15, stack, spacer, indentation) {
      switch (typeof value15) {
        case "string":
          return strEscape(value15);
        case "object": {
          if (value15 === null) {
            return "null";
          }
          if (typeof value15.toJSON === "function") {
            value15 = value15.toJSON(key);
            if (typeof value15 !== "object") {
              return stringifyIndent(key, value15, stack, spacer, indentation);
            }
            if (value15 === null) {
              return "null";
            }
          }
          if (stack.indexOf(value15) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          if (Array.isArray(value15)) {
            if (value15.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value15);
            indentation += spacer;
            let res2 = `\n${indentation}`;
            const join4 = `,\n${indentation}`;
            const maximumValuesToStringify = Math.min(value15.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyIndent(String(i), value15[i], stack, spacer, indentation);
              res2 += tmp2 !== undefined ? tmp2 : "null";
              res2 += join4;
            }
            const tmp = stringifyIndent(String(i), value15[i], stack, spacer, indentation);
            res2 += tmp !== undefined ? tmp : "null";
            if (value15.length - 1 > maximumBreadth) {
              const removedKeys = value15.length - maximumBreadth - 1;
              res2 += `${join4}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            res2 += `\n${originalIndentation}`;
            stack.pop();
            return `[${res2}]`;
          }
          let keys = Object.keys(value15);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          indentation += spacer;
          const join3 = `,\n${indentation}`;
          let res = "";
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value15)) {
            res += stringifyTypedArray(value15, join3, maximumBreadth);
            keys = keys.slice(value15.length);
            maximumPropertiesToStringify -= value15.length;
            separator = join3;
          }
          if (deterministic) {
            keys = insertSort(keys);
          }
          stack.push(value15);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyIndent(key2, value15[key2], stack, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}: ${tmp}`;
              separator = join3;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
            separator = join3;
          }
          if (separator !== "") {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value15) ? String(value15) : fail ? fail(value15) : "null";
        case "boolean":
          return value15 === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint6) {
            return String(value15);
          }
        default:
          return fail ? fail(value15) : undefined;
      }
    }
    function stringifySimple(key, value15, stack) {
      switch (typeof value15) {
        case "string":
          return strEscape(value15);
        case "object": {
          if (value15 === null) {
            return "null";
          }
          if (typeof value15.toJSON === "function") {
            value15 = value15.toJSON(key);
            if (typeof value15 !== "object") {
              return stringifySimple(key, value15, stack);
            }
            if (value15 === null) {
              return "null";
            }
          }
          if (stack.indexOf(value15) !== -1) {
            return circularValue;
          }
          let res = "";
          if (Array.isArray(value15)) {
            if (value15.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value15);
            const maximumValuesToStringify = Math.min(value15.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifySimple(String(i), value15[i], stack);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifySimple(String(i), value15[i], stack);
            res += tmp !== undefined ? tmp : "null";
            if (value15.length - 1 > maximumBreadth) {
              const removedKeys = value15.length - maximumBreadth - 1;
              res += `,"... ${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value15);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value15)) {
            res += stringifyTypedArray(value15, ",", maximumBreadth);
            keys = keys.slice(value15.length);
            maximumPropertiesToStringify -= value15.length;
            separator = ",";
          }
          if (deterministic) {
            keys = insertSort(keys);
          }
          stack.push(value15);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifySimple(key2, value15[key2], stack);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${tmp}`;
              separator = ",";
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value15) ? String(value15) : fail ? fail(value15) : "null";
        case "boolean":
          return value15 === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint6) {
            return String(value15);
          }
        default:
          return fail ? fail(value15) : undefined;
      }
    }
    function stringify2(value15, replacer, space) {
      if (arguments.length > 1) {
        let spacer = "";
        if (typeof space === "number") {
          spacer = " ".repeat(Math.min(space, 10));
        } else if (typeof space === "string") {
          spacer = space.slice(0, 10);
        }
        if (replacer != null) {
          if (typeof replacer === "function") {
            return stringifyFnReplacer("", { "": value15 }, [], replacer, spacer, "");
          }
          if (Array.isArray(replacer)) {
            return stringifyArrayReplacer("", value15, [], getUniqueReplacerSet(replacer), spacer, "");
          }
        }
        if (spacer.length !== 0) {
          return stringifyIndent("", value15, [], spacer, "");
        }
      }
      return stringifySimple("", value15, []);
    }
    return stringify2;
  };
  var { hasOwnProperty } = Object.prototype;
  var stringify = configure();
  stringify.configure = configure;
  stringify.stringify = stringify;
  stringify.default = stringify;
  exports.stringify = stringify;
  exports.configure = configure;
  module.exports = stringify;
  var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
  var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
});

// node_modules/@poppinss/utils/build/lodash/main.cjs
var require_main = __commonJS((exports, module) => {
  (function() {
    function t3(t4, e3, n2) {
      switch (n2.length) {
        case 0:
          return t4.call(e3);
        case 1:
          return t4.call(e3, n2[0]);
        case 2:
          return t4.call(e3, n2[0], n2[1]);
        case 3:
          return t4.call(e3, n2[0], n2[1], n2[2]);
      }
      return t4.apply(e3, n2);
    }
    function e2(t4, e3) {
      for (var n2 = -1, r3 = t4 == null ? 0 : t4.length;++n2 < r3 && e3(t4[n2], n2, t4) !== false; )
        ;
    }
    function n(t4, e3) {
      for (var n2 = -1, r3 = t4 == null ? 0 : t4.length, u2 = 0, o2 = [];++n2 < r3; ) {
        var c2 = t4[n2];
        e3(c2, n2, t4) && (o2[u2++] = c2);
      }
      return o2;
    }
    function r2(t4, e3) {
      for (var n2 = -1, r3 = t4 == null ? 0 : t4.length, u2 = Array(r3);++n2 < r3; )
        u2[n2] = e3(t4[n2], n2, t4);
      return u2;
    }
    function u(t4, e3) {
      for (var n2 = -1, r3 = e3.length, u2 = t4.length;++n2 < r3; )
        t4[u2 + n2] = e3[n2];
      return t4;
    }
    function o(t4) {
      return function(e3) {
        return t4(e3);
      };
    }
    function c(t4) {
      var e3 = Object;
      return function(n2) {
        return t4(e3(n2));
      };
    }
    function i() {
    }
    function f(t4) {
      var e3 = -1, n2 = t4 == null ? 0 : t4.length;
      for (this.clear();++e3 < n2; ) {
        var r3 = t4[e3];
        this.set(r3[0], r3[1]);
      }
    }
    function a2(t4) {
      var e3 = -1, n2 = t4 == null ? 0 : t4.length;
      for (this.clear();++e3 < n2; ) {
        var r3 = t4[e3];
        this.set(r3[0], r3[1]);
      }
    }
    function l(t4) {
      var e3 = -1, n2 = t4 == null ? 0 : t4.length;
      for (this.clear();++e3 < n2; ) {
        var r3 = t4[e3];
        this.set(r3[0], r3[1]);
      }
    }
    function s(t4) {
      this.size = (this.__data__ = new a2(t4)).size;
    }
    function b(t4, e3) {
      var n2 = Ye(t4), r3 = !n2 && Xe(t4), u2 = !n2 && !r3 && Ze(t4), o2 = !n2 && !r3 && !u2 && nn(t4);
      if (n2 = n2 || r3 || u2 || o2) {
        for (var r3 = t4.length, c2 = String, i2 = -1, f2 = Array(r3);++i2 < r3; )
          f2[i2] = c2(i2);
        r3 = f2;
      } else
        r3 = [];
      var a3, c2 = r3.length;
      for (a3 in t4)
        !e3 && !fe.call(t4, a3) || n2 && (a3 == "length" || u2 && (a3 == "offset" || a3 == "parent") || o2 && (a3 == "buffer" || a3 == "byteLength" || a3 == "byteOffset") || ut(a3, c2)) || r3.push(a3);
      return r3;
    }
    function p(t4, e3, n2) {
      (n2 === Mt || bt(t4[e3], n2)) && (n2 !== Mt || (e3 in t4)) || d(t4, e3, n2);
    }
    function h3(t4, e3, n2) {
      var r3 = t4[e3];
      fe.call(t4, e3) && bt(r3, n2) && (n2 !== Mt || (e3 in t4)) || d(t4, e3, n2);
    }
    function y(t4, e3) {
      for (var n2 = t4.length;n2--; )
        if (bt(t4[n2][0], e3))
          return n2;
      return -1;
    }
    function j(t4, e3) {
      return t4 && W(e3, St(e3), t4);
    }
    function _(t4, e3) {
      return t4 && W(e3, zt(e3), t4);
    }
    function d(t4, e3, n2) {
      e3 == "__proto__" && we ? we(t4, e3, { configurable: true, enumerable: true, value: n2, writable: true }) : t4[e3] = n2;
    }
    function g(t4, n2, r3, u2, o2, c2) {
      var i2, f2 = 1 & n2, a3 = 2 & n2, l2 = 4 & n2;
      if (r3 && (i2 = o2 ? r3(t4, u2, o2, c2) : r3(t4)), i2 !== Mt)
        return i2;
      if (!_t(t4))
        return t4;
      if (u2 = Ye(t4)) {
        if (i2 = tt(t4), !f2)
          return V(t4, i2);
      } else {
        var b2 = Je(t4), p2 = b2 == "[object Function]" || b2 == "[object GeneratorFunction]";
        if (Ze(t4))
          return R(t4, f2);
        if (b2 == "[object Object]" || b2 == "[object Arguments]" || p2 && !o2) {
          if (i2 = a3 || p2 ? {} : et(t4), !f2)
            return a3 ? G(t4, _(i2, t4)) : N(t4, j(i2, t4));
        } else {
          if (!Gt[b2])
            return o2 ? t4 : {};
          i2 = nt(t4, b2, f2);
        }
      }
      if (c2 || (c2 = new s), o2 = c2.get(t4))
        return o2;
      if (c2.set(t4, i2), en(t4))
        return t4.forEach(function(e3) {
          i2.add(g(e3, n2, r3, e3, t4, c2));
        }), i2;
      if (tn(t4))
        return t4.forEach(function(e3, u3) {
          i2.set(u3, g(e3, n2, r3, u3, t4, c2));
        }), i2;
      var a3 = l2 ? a3 ? Q : K : a3 ? zt : St, y2 = u2 ? Mt : a3(t4);
      return e2(y2 || t4, function(e3, u3) {
        y2 && (u3 = e3, e3 = t4[u3]), h3(i2, u3, g(e3, n2, r3, u3, t4, c2));
      }), i2;
    }
    function v(t4, e3, n2, r3, o2) {
      var c2 = -1, i2 = t4.length;
      for (n2 || (n2 = rt), o2 || (o2 = []);++c2 < i2; ) {
        var f2 = t4[c2];
        0 < e3 && n2(f2) ? 1 < e3 ? v(f2, e3 - 1, n2, r3, o2) : u(o2, f2) : r3 || (o2[o2.length] = f2);
      }
      return o2;
    }
    function A(t4, e3) {
      e3 = C(e3, t4);
      for (var n2 = 0, r3 = e3.length;t4 != null && n2 < r3; )
        t4 = t4[it(e3[n2++])];
      return n2 && n2 == r3 ? t4 : Mt;
    }
    function m(t4, e3, n2) {
      return e3 = e3(t4), Ye(t4) ? e3 : u(e3, n2(t4));
    }
    function w(t4) {
      if (t4 == null)
        t4 = t4 === Mt ? "[object Undefined]" : "[object Null]";
      else if (me && me in Object(t4)) {
        var e3 = fe.call(t4, me), n2 = t4[me];
        try {
          t4[me] = Mt;
          var r3 = true;
        } catch (t5) {
        }
        var u2 = le.call(t4);
        r3 && (e3 ? t4[me] = n2 : delete t4[me]), t4 = u2;
      } else
        t4 = le.call(t4);
      return t4;
    }
    function O(t4, e3) {
      return t4 != null && fe.call(t4, e3);
    }
    function S(t4, e3) {
      return t4 != null && e3 in Object(t4);
    }
    function z2(t4) {
      return dt(t4) && w(t4) == "[object Arguments]";
    }
    function x(t4) {
      return dt(t4) && Je(t4) == "[object Map]";
    }
    function k(t4) {
      return dt(t4) && Je(t4) == "[object Set]";
    }
    function F(t4) {
      return dt(t4) && jt(t4.length) && !!Nt[w(t4)];
    }
    function I(t4) {
      if (!ot(t4))
        return ze(t4);
      var e3, n2 = [];
      for (e3 in Object(t4))
        fe.call(t4, e3) && e3 != "constructor" && n2.push(e3);
      return n2;
    }
    function M(t4, e3, n2, r3, u2) {
      t4 !== e3 && Ne(e3, function(o2, c2) {
        if (_t(o2)) {
          u2 || (u2 = new s);
          var i2 = u2, f2 = c2 == "__proto__" ? Mt : t4[c2], a3 = c2 == "__proto__" ? Mt : e3[c2], l2 = i2.get(a3);
          if (l2)
            p(t4, c2, l2);
          else {
            var l2 = r3 ? r3(f2, a3, c2 + "", t4, e3, i2) : Mt, b2 = l2 === Mt;
            if (b2) {
              var h4 = Ye(a3), y2 = !h4 && Ze(a3), j2 = !h4 && !y2 && nn(a3), l2 = a3;
              h4 || y2 || j2 ? Ye(f2) ? l2 = f2 : ht(f2) ? l2 = V(f2) : y2 ? (b2 = false, l2 = R(a3, true)) : j2 ? (b2 = false, l2 = T(a3, true)) : l2 = [] : gt(a3) || Xe(a3) ? (l2 = f2, Xe(f2) ? l2 = mt(f2) : (!_t(f2) || n2 && yt(f2)) && (l2 = et(a3))) : b2 = false;
            }
            b2 && (i2.set(a3, l2), M(l2, a3, n2, r3, i2), i2.delete(a3)), p(t4, c2, l2);
          }
        } else
          i2 = r3 ? r3(c2 == "__proto__" ? Mt : t4[c2], o2, c2 + "", t4, e3, u2) : Mt, i2 === Mt && (i2 = o2), p(t4, c2, i2);
      }, zt);
    }
    function E(t4, e3) {
      return U(t4, e3, function(e4, n2) {
        return Ot(t4, n2);
      });
    }
    function U(t4, e3, n2) {
      for (var r3 = -1, u2 = e3.length, o2 = {};++r3 < u2; ) {
        var c2 = e3[r3], i2 = A(t4, c2);
        n2(i2, c2) && D(o2, C(c2, t4), i2);
      }
      return o2;
    }
    function P(t4) {
      return Ke(ct(t4, undefined, kt), t4 + "");
    }
    function D(t4, e3, n2) {
      if (!_t(t4))
        return t4;
      e3 = C(e3, t4);
      for (var r3 = -1, u2 = e3.length, o2 = u2 - 1, c2 = t4;c2 != null && ++r3 < u2; ) {
        var i2 = it(e3[r3]), f2 = n2;
        if (r3 != o2) {
          var a3 = c2[i2], f2 = Mt;
          f2 === Mt && (f2 = _t(a3) ? a3 : ut(e3[r3 + 1]) ? [] : {});
        }
        h3(c2, i2, f2), c2 = c2[i2];
      }
      return t4;
    }
    function $(t4) {
      if (typeof t4 == "string")
        return t4;
      if (Ye(t4))
        return r2(t4, $) + "";
      if (At(t4))
        return Ve ? Ve.call(t4) : "";
      var e3 = t4 + "";
      return e3 == "0" && 1 / t4 == -Et ? "-0" : e3;
    }
    function B(t4, e3) {
      e3 = C(e3, t4);
      var n2;
      if (2 > e3.length)
        n2 = t4;
      else {
        n2 = e3;
        var r3 = 0, u2 = -1, o2 = -1, c2 = n2.length;
        for (0 > r3 && (r3 = -r3 > c2 ? 0 : c2 + r3), u2 = u2 > c2 ? c2 : u2, 0 > u2 && (u2 += c2), c2 = r3 > u2 ? 0 : u2 - r3 >>> 0, r3 >>>= 0, u2 = Array(c2);++o2 < c2; )
          u2[o2] = n2[o2 + r3];
        n2 = A(t4, u2);
      }
      return t4 = n2, t4 == null || delete t4[it(lt(e3))];
    }
    function C(t4, e3) {
      var n2;
      return Ye(t4) ? n2 = t4 : (Ye(t4) ? n2 = false : (n2 = typeof t4, n2 = !(n2 != "number" && n2 != "symbol" && n2 != "boolean" && t4 != null && !At(t4)) || (Pt.test(t4) || !Ut.test(t4) || e3 != null && (t4 in Object(e3)))), n2 = n2 ? [t4] : Qe(wt(t4))), n2;
    }
    function R(t4, e3) {
      if (e3)
        return t4.slice();
      var n2 = t4.length, n2 = je ? je(n2) : new t4.constructor(n2);
      return t4.copy(n2), n2;
    }
    function L(t4) {
      var e3 = new t4.constructor(t4.byteLength);
      return new ye(e3).set(new ye(t4)), e3;
    }
    function T(t4, e3) {
      return new t4.constructor(e3 ? L(t4.buffer) : t4.buffer, t4.byteOffset, t4.length);
    }
    function V(t4, e3) {
      var n2 = -1, r3 = t4.length;
      for (e3 || (e3 = Array(r3));++n2 < r3; )
        e3[n2] = t4[n2];
      return e3;
    }
    function W(t4, e3, n2) {
      var r3 = !n2;
      n2 || (n2 = {});
      for (var u2 = -1, o2 = e3.length;++u2 < o2; ) {
        var c2 = e3[u2], i2 = Mt;
        i2 === Mt && (i2 = t4[c2]), r3 ? d(n2, c2, i2) : h3(n2, c2, i2);
      }
      return n2;
    }
    function N(t4, e3) {
      return W(t4, qe(t4), e3);
    }
    function G(t4, e3) {
      return W(t4, He(t4), e3);
    }
    function q(t4) {
      return P(function(e3, n2) {
        var r3, u2 = -1, o2 = n2.length, c2 = 1 < o2 ? n2[o2 - 1] : Mt, i2 = 2 < o2 ? n2[2] : Mt, c2 = 3 < t4.length && typeof c2 == "function" ? (o2--, c2) : Mt;
        if (r3 = i2) {
          r3 = n2[0];
          var f2 = n2[1];
          if (_t(i2)) {
            var a3 = typeof f2;
            r3 = !!(a3 == "number" ? pt(i2) && ut(f2, i2.length) : a3 == "string" && (f2 in i2)) && bt(i2[f2], r3);
          } else
            r3 = false;
        }
        for (r3 && (c2 = 3 > o2 ? Mt : c2, o2 = 1), e3 = Object(e3);++u2 < o2; )
          (i2 = n2[u2]) && t4(e3, i2, u2, c2);
        return e3;
      });
    }
    function H(t4) {
      return gt(t4) ? Mt : t4;
    }
    function J(t4) {
      return Ke(ct(t4, Mt, at), t4 + "");
    }
    function K(t4) {
      return m(t4, St, qe);
    }
    function Q(t4) {
      return m(t4, zt, He);
    }
    function X(t4, e3) {
      var n2 = t4.__data__, r3 = typeof e3;
      return (r3 == "string" || r3 == "number" || r3 == "symbol" || r3 == "boolean" ? e3 !== "__proto__" : e3 === null) ? n2[typeof e3 == "string" ? "string" : "hash"] : n2.map;
    }
    function Y(t4, e3) {
      var n2 = t4 == null ? Mt : t4[e3];
      return (!_t(n2) || ae && ae in n2 ? 0 : (yt(n2) ? be : Ct).test(ft(n2))) ? n2 : Mt;
    }
    function Z(t4, e3, n2) {
      e3 = C(e3, t4);
      for (var r3 = -1, u2 = e3.length, o2 = false;++r3 < u2; ) {
        var c2 = it(e3[r3]);
        if (!(o2 = t4 != null && n2(t4, c2)))
          break;
        t4 = t4[c2];
      }
      return o2 || ++r3 != u2 ? o2 : (u2 = t4 == null ? 0 : t4.length, !!u2 && jt(u2) && ut(c2, u2) && (Ye(t4) || Xe(t4)));
    }
    function tt(t4) {
      var e3 = t4.length, n2 = new t4.constructor(e3);
      return e3 && typeof t4[0] == "string" && fe.call(t4, "index") && (n2.index = t4.index, n2.input = t4.input), n2;
    }
    function et(t4) {
      return typeof t4.constructor != "function" || ot(t4) ? {} : We(_e(t4));
    }
    function nt(t4, e3, n2) {
      var r3 = t4.constructor;
      switch (e3) {
        case "[object ArrayBuffer]":
          return L(t4);
        case "[object Boolean]":
        case "[object Date]":
          return new r3(+t4);
        case "[object DataView]":
          return e3 = n2 ? L(t4.buffer) : t4.buffer, new t4.constructor(e3, t4.byteOffset, t4.byteLength);
        case "[object Float32Array]":
        case "[object Float64Array]":
        case "[object Int8Array]":
        case "[object Int16Array]":
        case "[object Int32Array]":
        case "[object Uint8Array]":
        case "[object Uint8ClampedArray]":
        case "[object Uint16Array]":
        case "[object Uint32Array]":
          return T(t4, n2);
        case "[object Map]":
          return new r3;
        case "[object Number]":
        case "[object String]":
          return new r3(t4);
        case "[object RegExp]":
          return e3 = new t4.constructor(t4.source, Bt.exec(t4)), e3.lastIndex = t4.lastIndex, e3;
        case "[object Set]":
          return new r3;
        case "[object Symbol]":
          return Te ? Object(Te.call(t4)) : {};
      }
    }
    function rt(t4) {
      return Ye(t4) || Xe(t4) || !!(Ae && t4 && t4[Ae]);
    }
    function ut(t4, e3) {
      var n2 = typeof t4;
      return e3 = e3 == null ? 9007199254740991 : e3, !!e3 && (n2 == "number" || n2 != "symbol" && Rt.test(t4)) && -1 < t4 && t4 % 1 == 0 && t4 < e3;
    }
    function ot(t4) {
      var e3 = t4 && t4.constructor;
      return t4 === (typeof e3 == "function" && e3.prototype || oe);
    }
    function ct(e3, n2, r3) {
      return n2 = xe(n2 === Mt ? e3.length - 1 : n2, 0), function() {
        for (var u2 = arguments, o2 = -1, c2 = xe(u2.length - n2, 0), i2 = Array(c2);++o2 < c2; )
          i2[o2] = u2[n2 + o2];
        for (o2 = -1, c2 = Array(n2 + 1);++o2 < n2; )
          c2[o2] = u2[o2];
        return c2[n2] = r3(i2), t3(e3, this, c2);
      };
    }
    function it(t4) {
      if (typeof t4 == "string" || At(t4))
        return t4;
      var e3 = t4 + "";
      return e3 == "0" && 1 / t4 == -Et ? "-0" : e3;
    }
    function ft(t4) {
      if (t4 != null) {
        try {
          return ie.call(t4);
        } catch (t5) {
        }
        return t4 + "";
      }
      return "";
    }
    function at(t4) {
      return (t4 == null ? 0 : t4.length) ? v(t4, 1) : [];
    }
    function lt(t4) {
      var e3 = t4 == null ? 0 : t4.length;
      return e3 ? t4[e3 - 1] : Mt;
    }
    function st(t4, e3) {
      function n2() {
        var r3 = arguments, u2 = e3 ? e3.apply(this, r3) : r3[0], o2 = n2.cache;
        return o2.has(u2) ? o2.get(u2) : (r3 = t4.apply(this, r3), n2.cache = o2.set(u2, r3) || o2, r3);
      }
      if (typeof t4 != "function" || e3 != null && typeof e3 != "function")
        throw new TypeError("Expected a function");
      return n2.cache = new (st.Cache || l), n2;
    }
    function bt(t4, e3) {
      return t4 === e3 || t4 !== t4 && e3 !== e3;
    }
    function pt(t4) {
      return t4 != null && jt(t4.length) && !yt(t4);
    }
    function ht(t4) {
      return dt(t4) && pt(t4);
    }
    function yt(t4) {
      return !!_t(t4) && (t4 = w(t4), t4 == "[object Function]" || t4 == "[object GeneratorFunction]" || t4 == "[object AsyncFunction]" || t4 == "[object Proxy]");
    }
    function jt(t4) {
      return typeof t4 == "number" && -1 < t4 && t4 % 1 == 0 && 9007199254740991 >= t4;
    }
    function _t(t4) {
      var e3 = typeof t4;
      return t4 != null && (e3 == "object" || e3 == "function");
    }
    function dt(t4) {
      return t4 != null && typeof t4 == "object";
    }
    function gt(t4) {
      return !(!dt(t4) || w(t4) != "[object Object]") && (t4 = _e(t4), t4 === null || (t4 = fe.call(t4, "constructor") && t4.constructor, typeof t4 == "function" && t4 instanceof t4 && ie.call(t4) == se));
    }
    function vt(t4) {
      return typeof t4 == "string" || !Ye(t4) && dt(t4) && w(t4) == "[object String]";
    }
    function At(t4) {
      return typeof t4 == "symbol" || dt(t4) && w(t4) == "[object Symbol]";
    }
    function mt(t4) {
      return W(t4, zt(t4));
    }
    function wt(t4) {
      return t4 == null ? "" : $(t4);
    }
    function Ot(t4, e3) {
      return t4 != null && Z(t4, e3, S);
    }
    function St(t4) {
      return pt(t4) ? b(t4) : I(t4);
    }
    function zt(t4) {
      if (pt(t4))
        t4 = b(t4, true);
      else if (_t(t4)) {
        var e3, n2 = ot(t4), r3 = [];
        for (e3 in t4)
          (e3 != "constructor" || !n2 && fe.call(t4, e3)) && r3.push(e3);
        t4 = r3;
      } else {
        if (e3 = [], t4 != null)
          for (n2 in Object(t4))
            e3.push(n2);
        t4 = e3;
      }
      return t4;
    }
    function xt(t4) {
      return function() {
        return t4;
      };
    }
    function kt(t4) {
      return t4;
    }
    function Ft() {
      return [];
    }
    function It() {
      return false;
    }
    var Mt, Et = 1 / 0, Ut = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Pt = /^\w*$/, Dt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, $t = /\\(\\)?/g, Bt = /\w*$/, Ct = /^\[object .+?Constructor\]$/, Rt = /^(?:0|[1-9]\d*)$/, Lt = "[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*", Tt = "(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])", Vt = RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|" + Tt + Lt, "g"), Wt = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"), Nt = {};
    Nt["[object Float32Array]"] = Nt["[object Float64Array]"] = Nt["[object Int8Array]"] = Nt["[object Int16Array]"] = Nt["[object Int32Array]"] = Nt["[object Uint8Array]"] = Nt["[object Uint8ClampedArray]"] = Nt["[object Uint16Array]"] = Nt["[object Uint32Array]"] = true, Nt["[object Arguments]"] = Nt["[object Array]"] = Nt["[object ArrayBuffer]"] = Nt["[object Boolean]"] = Nt["[object DataView]"] = Nt["[object Date]"] = Nt["[object Error]"] = Nt["[object Function]"] = Nt["[object Map]"] = Nt["[object Number]"] = Nt["[object Object]"] = Nt["[object RegExp]"] = Nt["[object Set]"] = Nt["[object String]"] = Nt["[object WeakMap]"] = false;
    var Gt = {};
    Gt["[object Arguments]"] = Gt["[object Array]"] = Gt["[object ArrayBuffer]"] = Gt["[object DataView]"] = Gt["[object Boolean]"] = Gt["[object Date]"] = Gt["[object Float32Array]"] = Gt["[object Float64Array]"] = Gt["[object Int8Array]"] = Gt["[object Int16Array]"] = Gt["[object Int32Array]"] = Gt["[object Map]"] = Gt["[object Number]"] = Gt["[object Object]"] = Gt["[object RegExp]"] = Gt["[object Set]"] = Gt["[object String]"] = Gt["[object Symbol]"] = Gt["[object Uint8Array]"] = Gt["[object Uint8ClampedArray]"] = Gt["[object Uint16Array]"] = Gt["[object Uint32Array]"] = true, Gt["[object Error]"] = Gt["[object Function]"] = Gt["[object WeakMap]"] = false;
    var qt, Ht = typeof global == "object" && global && global.Object === Object && global, Jt = typeof self == "object" && self && self.Object === Object && self, Kt = Ht || Jt || Function("return this")(), Qt = typeof exports == "object" && exports && !exports.nodeType && exports, Xt = Qt && typeof module == "object" && module && !module.nodeType && module, Yt = Xt && Xt.exports === Qt, Zt = Yt && Ht.process;
    t: {
      try {
        qt = Zt && Zt.binding && Zt.binding("util");
        break t;
      } catch (t4) {
      }
      qt = undefined;
    }
    var te = qt && qt.isMap, ee = qt && qt.isSet, ne = qt && qt.isTypedArray, re = function(t4) {
      return function(e3) {
        return e3 == null ? Mt : e3[t4];
      };
    }("length"), ue = Array.prototype, oe = Object.prototype, ce = Kt["__core-js_shared__"], ie = Function.prototype.toString, fe = oe.hasOwnProperty, ae = function() {
      var t4 = /[^.]+$/.exec(ce && ce.keys && ce.keys.IE_PROTO || "");
      return t4 ? "Symbol(src)_1." + t4 : "";
    }(), le = oe.toString, se = ie.call(Object), be = RegExp("^" + ie.call(fe).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), pe = Yt ? Kt.Buffer : Mt, he = Kt.Symbol, ye = Kt.Uint8Array, je = pe ? pe.a : Mt, _e = c(Object.getPrototypeOf), de = Object.create, ge = oe.propertyIsEnumerable, ve = ue.splice, Ae = he ? he.isConcatSpreadable : Mt, me = he ? he.toStringTag : Mt, we = function() {
      try {
        var t4 = Y(Object, "defineProperty");
        return t4({}, "", {}), t4;
      } catch (t5) {
      }
    }(), Oe = Object.getOwnPropertySymbols, Se = pe ? pe.isBuffer : Mt, ze = c(Object.keys), xe = Math.max, ke = Date.now, Fe = Y(Kt, "DataView"), Ie = Y(Kt, "Map"), Me = Y(Kt, "Promise"), Ee = Y(Kt, "Set"), Ue = Y(Kt, "WeakMap"), Pe = Y(Object, "create"), De = ft(Fe), $e = ft(Ie), Be = ft(Me), Ce = ft(Ee), Re = ft(Ue), Le = he ? he.prototype : Mt, Te = Le ? Le.valueOf : Mt, Ve = Le ? Le.toString : Mt, We = function() {
      function t4() {
      }
      return function(e3) {
        return _t(e3) ? de ? de(e3) : (t4.prototype = e3, e3 = new t4, t4.prototype = Mt, e3) : {};
      };
    }();
    f.prototype.clear = function() {
      this.__data__ = Pe ? Pe(null) : {}, this.size = 0;
    }, f.prototype.delete = function(t4) {
      return t4 = this.has(t4) && delete this.__data__[t4], this.size -= t4 ? 1 : 0, t4;
    }, f.prototype.get = function(t4) {
      var e3 = this.__data__;
      return Pe ? (t4 = e3[t4], t4 === "__lodash_hash_undefined__" ? Mt : t4) : fe.call(e3, t4) ? e3[t4] : Mt;
    }, f.prototype.has = function(t4) {
      var e3 = this.__data__;
      return Pe ? e3[t4] !== Mt : fe.call(e3, t4);
    }, f.prototype.set = function(t4, e3) {
      var n2 = this.__data__;
      return this.size += this.has(t4) ? 0 : 1, n2[t4] = Pe && e3 === Mt ? "__lodash_hash_undefined__" : e3, this;
    }, a2.prototype.clear = function() {
      this.__data__ = [], this.size = 0;
    }, a2.prototype.delete = function(t4) {
      var e3 = this.__data__;
      return t4 = y(e3, t4), !(0 > t4) && (t4 == e3.length - 1 ? e3.pop() : ve.call(e3, t4, 1), --this.size, true);
    }, a2.prototype.get = function(t4) {
      var e3 = this.__data__;
      return t4 = y(e3, t4), 0 > t4 ? Mt : e3[t4][1];
    }, a2.prototype.has = function(t4) {
      return -1 < y(this.__data__, t4);
    }, a2.prototype.set = function(t4, e3) {
      var n2 = this.__data__, r3 = y(n2, t4);
      return 0 > r3 ? (++this.size, n2.push([t4, e3])) : n2[r3][1] = e3, this;
    }, l.prototype.clear = function() {
      this.size = 0, this.__data__ = {
        hash: new f,
        map: new (Ie || a2),
        string: new f
      };
    }, l.prototype.delete = function(t4) {
      return t4 = X(this, t4).delete(t4), this.size -= t4 ? 1 : 0, t4;
    }, l.prototype.get = function(t4) {
      return X(this, t4).get(t4);
    }, l.prototype.has = function(t4) {
      return X(this, t4).has(t4);
    }, l.prototype.set = function(t4, e3) {
      var n2 = X(this, t4), r3 = n2.size;
      return n2.set(t4, e3), this.size += n2.size == r3 ? 0 : 1, this;
    }, s.prototype.clear = function() {
      this.__data__ = new a2, this.size = 0;
    }, s.prototype.delete = function(t4) {
      var e3 = this.__data__;
      return t4 = e3.delete(t4), this.size = e3.size, t4;
    }, s.prototype.get = function(t4) {
      return this.__data__.get(t4);
    }, s.prototype.has = function(t4) {
      return this.__data__.has(t4);
    }, s.prototype.set = function(t4, e3) {
      var n2 = this.__data__;
      if (n2 instanceof a2) {
        var r3 = n2.__data__;
        if (!Ie || 199 > r3.length)
          return r3.push([t4, e3]), this.size = ++n2.size, this;
        n2 = this.__data__ = new l(r3);
      }
      return n2.set(t4, e3), this.size = n2.size, this;
    };
    var Ne = function(t4) {
      return function(e3, n2, r3) {
        var u2 = -1, o2 = Object(e3);
        r3 = r3(e3);
        for (var c2 = r3.length;c2--; ) {
          var i2 = r3[t4 ? c2 : ++u2];
          if (n2(o2[i2], i2, o2) === false)
            break;
        }
        return e3;
      };
    }(), Ge = we ? function(t4, e3) {
      return we(t4, "toString", {
        configurable: true,
        enumerable: false,
        value: xt(e3),
        writable: true
      });
    } : kt, qe = Oe ? function(t4) {
      return t4 == null ? [] : (t4 = Object(t4), n(Oe(t4), function(e3) {
        return ge.call(t4, e3);
      }));
    } : Ft, He = Oe ? function(t4) {
      for (var e3 = [];t4; )
        u(e3, qe(t4)), t4 = _e(t4);
      return e3;
    } : Ft, Je = w;
    (Fe && Je(new Fe(new ArrayBuffer(1))) != "[object DataView]" || Ie && Je(new Ie) != "[object Map]" || Me && Je(Me.resolve()) != "[object Promise]" || Ee && Je(new Ee) != "[object Set]" || Ue && Je(new Ue) != "[object WeakMap]") && (Je = function(t4) {
      var e3 = w(t4);
      if (t4 = (t4 = e3 == "[object Object]" ? t4.constructor : Mt) ? ft(t4) : "")
        switch (t4) {
          case De:
            return "[object DataView]";
          case $e:
            return "[object Map]";
          case Be:
            return "[object Promise]";
          case Ce:
            return "[object Set]";
          case Re:
            return "[object WeakMap]";
        }
      return e3;
    });
    var Ke = function(t4) {
      var e3 = 0, n2 = 0;
      return function() {
        var r3 = ke(), u2 = 16 - (r3 - n2);
        if (n2 = r3, 0 < u2) {
          if (800 <= ++e3)
            return arguments[0];
        } else
          e3 = 0;
        return t4.apply(Mt, arguments);
      };
    }(Ge), Qe = function(t4) {
      t4 = st(t4, function(t5) {
        return e3.size === 500 && e3.clear(), t5;
      });
      var e3 = t4.cache;
      return t4;
    }(function(t4) {
      var e3 = [];
      return t4.charCodeAt(0) === 46 && e3.push(""), t4.replace(Dt, function(t5, n2, r3, u2) {
        e3.push(r3 ? u2.replace($t, "$1") : n2 || t5);
      }), e3;
    });
    st.Cache = l;
    var Xe = z2(function() {
      return arguments;
    }()) ? z2 : function(t4) {
      return dt(t4) && fe.call(t4, "callee") && !ge.call(t4, "callee");
    }, Ye = Array.isArray, Ze = Se || It, tn = te ? o(te) : x, en = ee ? o(ee) : k, nn = ne ? o(ne) : F, rn = q(function(t4, e3, n2) {
      M(t4, e3, n2);
    }), un = q(function(t4, e3, n2, r3) {
      M(t4, e3, n2, r3);
    }), on = J(function(t4, e3) {
      var n2 = {};
      if (t4 == null)
        return n2;
      var u2 = false;
      e3 = r2(e3, function(e4) {
        return e4 = C(e4, t4), u2 || (u2 = 1 < e4.length), e4;
      }), W(t4, Q(t4), n2), u2 && (n2 = g(n2, 7, H));
      for (var o2 = e3.length;o2--; )
        B(n2, e3[o2]);
      return n2;
    }), cn = J(function(t4, e3) {
      return t4 == null ? {} : E(t4, e3);
    });
    i.constant = xt, i.flatten = at, i.keys = St, i.keysIn = zt, i.memoize = st, i.merge = rn, i.mergeWith = un, i.omit = on, i.pick = cn, i.set = function(t4, e3, n2) {
      return t4 == null ? t4 : D(t4, e3, n2);
    }, i.toPath = function(t4) {
      return Ye(t4) ? r2(t4, it) : At(t4) ? [t4] : V(Qe(wt(t4)));
    }, i.toPlainObject = mt, i.unset = function(t4, e3) {
      return t4 == null || B(t4, e3);
    }, i.clone = function(t4) {
      return g(t4, 4);
    }, i.cloneDeep = function(t4) {
      return g(t4, 5);
    }, i.eq = bt, i.get = function(t4, e3, n2) {
      return t4 = t4 == null ? Mt : A(t4, e3), t4 === Mt ? n2 : t4;
    }, i.has = function(t4, e3) {
      return t4 != null && Z(t4, e3, O);
    }, i.hasIn = Ot, i.identity = kt, i.isArguments = Xe, i.isArray = Ye, i.isArrayLike = pt, i.isArrayLikeObject = ht, i.isBuffer = Ze, i.isFunction = yt, i.isLength = jt, i.isMap = tn, i.isObject = _t, i.isObjectLike = dt, i.isPlainObject = gt, i.isSet = en, i.isString = vt, i.isSymbol = At, i.isTypedArray = nn, i.last = lt, i.stubArray = Ft, i.stubFalse = It, i.size = function(t4) {
      if (t4 == null)
        return 0;
      if (pt(t4)) {
        if (vt(t4))
          if (Wt.test(t4)) {
            for (var e3 = Vt.lastIndex = 0;Vt.test(t4); )
              ++e3;
            t4 = e3;
          } else
            t4 = re(t4);
        else
          t4 = t4.length;
        return t4;
      }
      return e3 = Je(t4), e3 == "[object Map]" || e3 == "[object Set]" ? t4.size : I(t4).length;
    }, i.toString = wt, i.VERSION = "4.17.5", typeof define == "function" && typeof define.amd == "object" && define.amd ? (Kt._ = i, define(function() {
      return i;
    })) : Xt ? ((Xt.exports = i)._ = i, Qt._ = i) : Kt._ = i;
  }).call(exports);
});

// node_modules/dotenv/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.4.1",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      "lint-readme": "standard-markdown",
      pretest: "npm run lint && npm run dts-check",
      test: "tap tests/*.js --100 -Rspec",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    funding: "https://github.com/motdotla/dotenv?sponsor=1",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@definitelytyped/dtslint": "^0.0.133",
      "@types/node": "^18.11.3",
      decache: "^4.6.1",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-markdown": "^7.1.0",
      "standard-version": "^9.5.0",
      tap: "^16.3.0",
      tar: "^6.1.11",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main2 = __commonJS((exports, module) => {
  var parse7 = function(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, "\n");
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value15 = match[2] || "";
      value15 = value15.trim();
      const maybeQuote = value15[0];
      value15 = value15.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value15 = value15.replace(/\\n/g, "\n");
        value15 = value15.replace(/\\r/g, "\r");
      }
      obj[key] = value15;
    }
    return obj;
  };
  var _parseVault = function(options2) {
    const vaultPath = _vaultPath(options2);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options2).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error23) {
        if (i + 1 >= length) {
          throw error23;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  };
  var _log = function(message) {
    console.log(`[dotenv@${version}][INFO] ${message}`);
  };
  var _warn = function(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  };
  var _debug = function(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  };
  var _dotenvKey = function(options2) {
    if (options2 && options2.DOTENV_KEY && options2.DOTENV_KEY.length > 0) {
      return options2.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  };
  var _instructions = function(result, dotenvKey) {
    let uri2;
    try {
      uri2 = new URL(dotenvKey);
    } catch (error23) {
      if (error23.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error23;
    }
    const key = uri2.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri2.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  };
  var _vaultPath = function(options2) {
    let possibleVaultPath = null;
    if (options2 && options2.path && options2.path.length > 0) {
      if (Array.isArray(options2.path)) {
        for (const filepath of options2.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options2.path.endsWith(".vault") ? options2.path : `${options2.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  };
  var _resolveHome = function(envPath) {
    return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
  };
  var _configVault = function(options2) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options2);
    let processEnv = process.env;
    if (options2 && options2.processEnv != null) {
      processEnv = options2.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options2);
    return { parsed };
  };
  var configDotenv = function(options2) {
    let dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options2 && options2.debug);
    if (options2) {
      if (options2.path != null) {
        let envPath = options2.path;
        if (Array.isArray(envPath)) {
          for (const filepath of options2.path) {
            if (fs.existsSync(filepath)) {
              envPath = filepath;
              break;
            }
          }
        }
        dotenvPath = _resolveHome(envPath);
      }
      if (options2.encoding != null) {
        encoding = options2.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
    }
    try {
      const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }));
      let processEnv = process.env;
      if (options2 && options2.processEnv != null) {
        processEnv = options2.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options2);
      return { parsed };
    } catch (e2) {
      if (debug) {
        _debug(`Failed to load ${dotenvPath} ${e2.message}`);
      }
      return { error: e2 };
    }
  };
  var config2 = function(options2) {
    if (_dotenvKey(options2).length === 0) {
      return DotenvModule.configDotenv(options2);
    }
    const vaultPath = _vaultPath(options2);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options2);
    }
    return DotenvModule._configVault(options2);
  };
  var decrypt = function(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error23) {
      const isRange = error23 instanceof RangeError;
      const invalidKeyLength = error23.message === "Invalid key length";
      const decryptionFailed = error23.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error23;
      }
    }
  };
  var populate = function(processEnv, parsed, options2 = {}) {
    const debug = Boolean(options2 && options2.debug);
    const override = Boolean(options2 && options2.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  };
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var os = import.meta.require("os");
  var crypto2 = import.meta.require("crypto");
  var packageJson = require_package();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config: config2,
    decrypt,
    parse: parse7,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// node_modules/eventemitter3/index.mjs
var import_ = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_.default;

// node_modules/@sinclair/typebox/build/import/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject(value) && !IsArray(value) && IsFunction(value.constructor) && value.constructor.name === "Object";
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return IsNumber(value) && Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// node_modules/@sinclair/typebox/build/import/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    const isNumber = IsNumber(value);
    return TypeSystemPolicy2.AllowNaN ? isNumber : isNumber && Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// node_modules/@sinclair/typebox/build/import/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => {
    {
      return Set2;
    }
  },
  Has: () => {
    {
      return Has;
    }
  },
  Get: () => {
    {
      return Get;
    }
  },
  Entries: () => {
    {
      return Entries;
    }
  },
  Delete: () => {
    {
      return Delete;
    }
  },
  Clear: () => {
    {
      return Clear;
    }
  }
});
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
var map = new Map;
// node_modules/@sinclair/typebox/build/import/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => {
    {
      return Set3;
    }
  },
  Has: () => {
    {
      return Has2;
    }
  },
  Get: () => {
    {
      return Get2;
    }
  },
  Entries: () => {
    {
      return Entries2;
    }
  },
  Delete: () => {
    {
      return Delete2;
    }
  },
  Clear: () => {
    {
      return Clear2;
    }
  }
});
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
var map2 = new Map;
// node_modules/@sinclair/typebox/build/import/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// node_modules/@sinclair/typebox/build/import/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// node_modules/@sinclair/typebox/build/import/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/import/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format, check) {
    if (exports_format.Has(format))
      throw new TypeSystemDuplicateFormat(format);
    exports_format.Set(format, check);
    return format;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// node_modules/@sinclair/typebox/build/import/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// node_modules/@sinclair/typebox/build/import/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => {
    {
      return IsUndefined2;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array2;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol2;
    }
  },
  IsString: () => {
    {
      return IsString2;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp;
    }
  },
  IsObject: () => {
    {
      return IsObject2;
    }
  },
  IsNumber: () => {
    {
      return IsNumber2;
    }
  },
  IsNull: () => {
    {
      return IsNull2;
    }
  },
  IsIterator: () => {
    {
      return IsIterator2;
    }
  },
  IsFunction: () => {
    {
      return IsFunction2;
    }
  },
  IsDate: () => {
    {
      return IsDate2;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean2;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt2;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator2;
    }
  },
  IsArray: () => {
    {
      return IsArray2;
    }
  }
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/import/type/clone/value.mjs
var ArrayType = function(value) {
  return value.map((value2) => Visit(value2));
};
var DateType = function(value) {
  return new Date(value.getTime());
};
var Uint8ArrayType = function(value) {
  return new Uint8Array(value);
};
var RegExpType = function(value) {
  return new RegExp(value.source, value.flags);
};
var ObjectType = function(value) {
  const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
  const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
  return { ...clonedProperties, ...clonedSymbols };
};
var Visit = function(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
};
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/import/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// node_modules/@sinclair/typebox/build/import/type/discard/discard.mjs
var DiscardKey = function(value2, key) {
  const { [key]: _, ...rest } = value2;
  return rest;
};
function Discard(value2, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value2);
}
// node_modules/@sinclair/typebox/build/import/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/import/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/import/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/import/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/import/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// node_modules/@sinclair/typebox/build/import/type/guard/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  TypeGuardUnknownTypeError: () => {
    {
      return TypeGuardUnknownTypeError;
    }
  },
  IsVoid: () => {
    {
      return IsVoid;
    }
  },
  IsUnsafe: () => {
    {
      return IsUnsafe;
    }
  },
  IsUnknown: () => {
    {
      return IsUnknown;
    }
  },
  IsUnionLiteral: () => {
    {
      return IsUnionLiteral;
    }
  },
  IsUnion: () => {
    {
      return IsUnion;
    }
  },
  IsUndefined: () => {
    {
      return IsUndefined3;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array3;
    }
  },
  IsTuple: () => {
    {
      return IsTuple;
    }
  },
  IsTransform: () => {
    {
      return IsTransform;
    }
  },
  IsThis: () => {
    {
      return IsThis;
    }
  },
  IsTemplateLiteral: () => {
    {
      return IsTemplateLiteral;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol3;
    }
  },
  IsString: () => {
    {
      return IsString3;
    }
  },
  IsSchema: () => {
    {
      return IsSchema;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp2;
    }
  },
  IsRef: () => {
    {
      return IsRef;
    }
  },
  IsRecursive: () => {
    {
      return IsRecursive;
    }
  },
  IsRecord: () => {
    {
      return IsRecord;
    }
  },
  IsReadonly: () => {
    {
      return IsReadonly;
    }
  },
  IsProperties: () => {
    {
      return IsProperties;
    }
  },
  IsPromise: () => {
    {
      return IsPromise2;
    }
  },
  IsOptional: () => {
    {
      return IsOptional;
    }
  },
  IsObject: () => {
    {
      return IsObject3;
    }
  },
  IsNumber: () => {
    {
      return IsNumber3;
    }
  },
  IsNull: () => {
    {
      return IsNull3;
    }
  },
  IsNot: () => {
    {
      return IsNot;
    }
  },
  IsNever: () => {
    {
      return IsNever;
    }
  },
  IsMappedResult: () => {
    {
      return IsMappedResult;
    }
  },
  IsMappedKey: () => {
    {
      return IsMappedKey;
    }
  },
  IsLiteralValue: () => {
    {
      return IsLiteralValue;
    }
  },
  IsLiteralString: () => {
    {
      return IsLiteralString;
    }
  },
  IsLiteralNumber: () => {
    {
      return IsLiteralNumber;
    }
  },
  IsLiteralBoolean: () => {
    {
      return IsLiteralBoolean;
    }
  },
  IsLiteral: () => {
    {
      return IsLiteral;
    }
  },
  IsKindOf: () => {
    {
      return IsKindOf;
    }
  },
  IsKind: () => {
    {
      return IsKind;
    }
  },
  IsIterator: () => {
    {
      return IsIterator3;
    }
  },
  IsIntersect: () => {
    {
      return IsIntersect;
    }
  },
  IsInteger: () => {
    {
      return IsInteger2;
    }
  },
  IsFunction: () => {
    {
      return IsFunction3;
    }
  },
  IsDate: () => {
    {
      return IsDate3;
    }
  },
  IsConstructor: () => {
    {
      return IsConstructor;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean3;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt3;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator3;
    }
  },
  IsArray: () => {
    {
      return IsArray3;
    }
  },
  IsAny: () => {
    {
      return IsAny;
    }
  }
});
var IsPattern = function(value2) {
  try {
    new RegExp(value2);
    return true;
  } catch {
    return false;
  }
};
var IsControlCharacterFree = function(value2) {
  if (!IsString2(value2))
    return false;
  for (let i = 0;i < value2.length; i++) {
    const code = value2.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
};
var IsAdditionalProperties = function(value2) {
  return IsOptionalBoolean(value2) || IsSchema(value2);
};
var IsOptionalBigInt = function(value2) {
  return IsUndefined2(value2) || IsBigInt2(value2);
};
var IsOptionalNumber = function(value2) {
  return IsUndefined2(value2) || IsNumber2(value2);
};
var IsOptionalBoolean = function(value2) {
  return IsUndefined2(value2) || IsBoolean2(value2);
};
var IsOptionalString = function(value2) {
  return IsUndefined2(value2) || IsString2(value2);
};
var IsOptionalPattern = function(value2) {
  return IsUndefined2(value2) || IsString2(value2) && IsControlCharacterFree(value2) && IsPattern(value2);
};
var IsOptionalFormat = function(value2) {
  return IsUndefined2(value2) || IsString2(value2) && IsControlCharacterFree(value2);
};
var IsOptionalSchema = function(value2) {
  return IsUndefined2(value2) || IsSchema(value2);
};
function IsReadonly(value2) {
  return IsObject2(value2) && value2[ReadonlyKind] === "Readonly";
}
function IsOptional(value2) {
  return IsObject2(value2) && value2[OptionalKind] === "Optional";
}
function IsAny(value2) {
  return IsKindOf(value2, "Any") && IsOptionalString(value2.$id);
}
function IsArray3(value2) {
  return IsKindOf(value2, "Array") && value2.type === "array" && IsOptionalString(value2.$id) && IsSchema(value2.items) && IsOptionalNumber(value2.minItems) && IsOptionalNumber(value2.maxItems) && IsOptionalBoolean(value2.uniqueItems) && IsOptionalSchema(value2.contains) && IsOptionalNumber(value2.minContains) && IsOptionalNumber(value2.maxContains);
}
function IsAsyncIterator3(value2) {
  return IsKindOf(value2, "AsyncIterator") && value2.type === "AsyncIterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
}
function IsBigInt3(value2) {
  return IsKindOf(value2, "BigInt") && value2.type === "bigint" && IsOptionalString(value2.$id) && IsOptionalBigInt(value2.exclusiveMaximum) && IsOptionalBigInt(value2.exclusiveMinimum) && IsOptionalBigInt(value2.maximum) && IsOptionalBigInt(value2.minimum) && IsOptionalBigInt(value2.multipleOf);
}
function IsBoolean3(value2) {
  return IsKindOf(value2, "Boolean") && value2.type === "boolean" && IsOptionalString(value2.$id);
}
function IsConstructor(value2) {
  return IsKindOf(value2, "Constructor") && value2.type === "Constructor" && IsOptionalString(value2.$id) && IsArray2(value2.parameters) && value2.parameters.every((schema) => IsSchema(schema)) && IsSchema(value2.returns);
}
function IsDate3(value2) {
  return IsKindOf(value2, "Date") && value2.type === "Date" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximumTimestamp) && IsOptionalNumber(value2.exclusiveMinimumTimestamp) && IsOptionalNumber(value2.maximumTimestamp) && IsOptionalNumber(value2.minimumTimestamp) && IsOptionalNumber(value2.multipleOfTimestamp);
}
function IsFunction3(value2) {
  return IsKindOf(value2, "Function") && value2.type === "Function" && IsOptionalString(value2.$id) && IsArray2(value2.parameters) && value2.parameters.every((schema) => IsSchema(schema)) && IsSchema(value2.returns);
}
function IsInteger2(value2) {
  return IsKindOf(value2, "Integer") && value2.type === "integer" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
}
function IsProperties(value2) {
  return IsObject2(value2) && Object.entries(value2).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema));
}
function IsIntersect(value2) {
  return IsKindOf(value2, "Intersect") && (IsString2(value2.type) && value2.type !== "object" ? false : true) && IsArray2(value2.allOf) && value2.allOf.every((schema) => IsSchema(schema) && !IsTransform(schema)) && IsOptionalString(value2.type) && (IsOptionalBoolean(value2.unevaluatedProperties) || IsOptionalSchema(value2.unevaluatedProperties)) && IsOptionalString(value2.$id);
}
function IsIterator3(value2) {
  return IsKindOf(value2, "Iterator") && value2.type === "Iterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
}
function IsKindOf(value2, kind) {
  return IsObject2(value2) && Kind in value2 && value2[Kind] === kind;
}
function IsLiteralString(value2) {
  return IsLiteral(value2) && IsString2(value2.const);
}
function IsLiteralNumber(value2) {
  return IsLiteral(value2) && IsNumber2(value2.const);
}
function IsLiteralBoolean(value2) {
  return IsLiteral(value2) && IsBoolean2(value2.const);
}
function IsLiteral(value2) {
  return IsKindOf(value2, "Literal") && IsOptionalString(value2.$id) && IsLiteralValue(value2.const);
}
function IsLiteralValue(value2) {
  return IsBoolean2(value2) || IsNumber2(value2) || IsString2(value2);
}
function IsMappedKey(value2) {
  return IsKindOf(value2, "MappedKey") && IsArray2(value2.keys) && value2.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult(value2) {
  return IsKindOf(value2, "MappedResult") && IsProperties(value2.properties);
}
function IsNever(value2) {
  return IsKindOf(value2, "Never") && IsObject2(value2.not) && Object.getOwnPropertyNames(value2.not).length === 0;
}
function IsNot(value2) {
  return IsKindOf(value2, "Not") && IsSchema(value2.not);
}
function IsNull3(value2) {
  return IsKindOf(value2, "Null") && value2.type === "null" && IsOptionalString(value2.$id);
}
function IsNumber3(value2) {
  return IsKindOf(value2, "Number") && value2.type === "number" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
}
function IsObject3(value2) {
  return IsKindOf(value2, "Object") && value2.type === "object" && IsOptionalString(value2.$id) && IsProperties(value2.properties) && IsAdditionalProperties(value2.additionalProperties) && IsOptionalNumber(value2.minProperties) && IsOptionalNumber(value2.maxProperties);
}
function IsPromise2(value2) {
  return IsKindOf(value2, "Promise") && value2.type === "Promise" && IsOptionalString(value2.$id) && IsSchema(value2.item);
}
function IsRecord(value2) {
  return IsKindOf(value2, "Record") && value2.type === "object" && IsOptionalString(value2.$id) && IsAdditionalProperties(value2.additionalProperties) && IsObject2(value2.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema(schema.patternProperties[keys[0]]);
  })(value2);
}
function IsRecursive(value2) {
  return IsObject2(value2) && Hint in value2 && value2[Hint] === "Recursive";
}
function IsRef(value2) {
  return IsKindOf(value2, "Ref") && IsOptionalString(value2.$id) && IsString2(value2.$ref);
}
function IsRegExp2(value2) {
  return IsKindOf(value2, "RegExp") && IsOptionalString(value2.$id) && IsString2(value2.source) && IsString2(value2.flags) && IsOptionalNumber(value2.maxLength) && IsOptionalNumber(value2.minLength);
}
function IsString3(value2) {
  return IsKindOf(value2, "String") && value2.type === "string" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minLength) && IsOptionalNumber(value2.maxLength) && IsOptionalPattern(value2.pattern) && IsOptionalFormat(value2.format);
}
function IsSymbol3(value2) {
  return IsKindOf(value2, "Symbol") && value2.type === "symbol" && IsOptionalString(value2.$id);
}
function IsTemplateLiteral(value2) {
  return IsKindOf(value2, "TemplateLiteral") && value2.type === "string" && IsString2(value2.pattern) && value2.pattern[0] === "^" && value2.pattern[value2.pattern.length - 1] === "$";
}
function IsThis(value2) {
  return IsKindOf(value2, "This") && IsOptionalString(value2.$id) && IsString2(value2.$ref);
}
function IsTransform(value2) {
  return IsObject2(value2) && TransformKind in value2;
}
function IsTuple(value2) {
  return IsKindOf(value2, "Tuple") && value2.type === "array" && IsOptionalString(value2.$id) && IsNumber2(value2.minItems) && IsNumber2(value2.maxItems) && value2.minItems === value2.maxItems && (IsUndefined2(value2.items) && IsUndefined2(value2.additionalItems) && value2.minItems === 0 || IsArray2(value2.items) && value2.items.every((schema) => IsSchema(schema)));
}
function IsUndefined3(value2) {
  return IsKindOf(value2, "Undefined") && value2.type === "undefined" && IsOptionalString(value2.$id);
}
function IsUnionLiteral(value2) {
  return IsUnion(value2) && value2.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion(value2) {
  return IsKindOf(value2, "Union") && IsOptionalString(value2.$id) && IsObject2(value2) && IsArray2(value2.anyOf) && value2.anyOf.every((schema) => IsSchema(schema));
}
function IsUint8Array3(value2) {
  return IsKindOf(value2, "Uint8Array") && value2.type === "Uint8Array" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minByteLength) && IsOptionalNumber(value2.maxByteLength);
}
function IsUnknown(value2) {
  return IsKindOf(value2, "Unknown") && IsOptionalString(value2.$id);
}
function IsUnsafe(value2) {
  return IsKindOf(value2, "Unsafe");
}
function IsVoid(value2) {
  return IsKindOf(value2, "Void") && value2.type === "void" && IsOptionalString(value2.$id);
}
function IsKind(value2) {
  return IsObject2(value2) && Kind in value2 && IsString2(value2[Kind]) && !KnownTypes.includes(value2[Kind]);
}
function IsSchema(value2) {
  return IsObject2(value2) && (IsAny(value2) || IsArray3(value2) || IsBoolean3(value2) || IsBigInt3(value2) || IsAsyncIterator3(value2) || IsConstructor(value2) || IsDate3(value2) || IsFunction3(value2) || IsInteger2(value2) || IsIntersect(value2) || IsIterator3(value2) || IsLiteral(value2) || IsMappedKey(value2) || IsMappedResult(value2) || IsNever(value2) || IsNot(value2) || IsNull3(value2) || IsNumber3(value2) || IsObject3(value2) || IsPromise2(value2) || IsRecord(value2) || IsRef(value2) || IsRegExp2(value2) || IsString3(value2) || IsSymbol3(value2) || IsTemplateLiteral(value2) || IsThis(value2) || IsTuple(value2) || IsUndefined3(value2) || IsUnion(value2) || IsUint8Array3(value2) || IsUnknown(value2) || IsUnsafe(value2) || IsVoid(value2) || IsKind(value2));
}

class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];

// node_modules/@sinclair/typebox/build/import/type/optional/optional.mjs
var RemoveOptional = function(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
};
var AddOptional = function(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
};
var OptionalWithFlag = function(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
};
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/import/type/optional/optional-from-mapped-result.mjs
var FromProperties = function(P, F) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Optional(P[K2], F) };
  }, {});
};
var FromMappedResult = function(R, F) {
  return FromProperties(R.properties, F);
};
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/import/type/intersect/intersect-evaluated.mjs
var IsIntersectOptional = function(T) {
  return T.every((L) => IsOptional(L));
};
var RemoveOptionalFromType = function(T) {
  return Discard(T, [OptionalKind]);
};
var RemoveOptionalFromRest = function(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
};
var ResolveIntersect = function(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
};
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/import/type/union/union-evaluated.mjs
var IsUnionOptional = function(T) {
  return T.some((L) => IsOptional(L));
};
var RemoveOptionalFromRest2 = function(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
};
var RemoveOptionalFromType2 = function(T) {
  return Discard(T, [OptionalKind]);
};
var ResolveUnion = function(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
};
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/parse.mjs
var Unescape = function(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
};
var IsNonEscaped = function(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
};
var IsOpenParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
};
var IsCloseParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
};
var IsSeparator = function(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
};
var IsGroup = function(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
};
var InGroup = function(pattern) {
  return pattern.slice(1, pattern.length - 1);
};
var IsPrecedenceOr = function(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
};
var IsPrecedenceAnd = function(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
};
var Or = function(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
};
var And = function(pattern) {
  function Group(value2, index) {
    if (!IsOpenParen(value2, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value2.length; scan++) {
      if (IsOpenParen(value2, scan))
        count += 1;
      if (IsCloseParen(value2, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
};
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

class TemplateLiteralParserError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/import/type/template-literal/finite.mjs
var IsNumberExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
};
var IsBooleanExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
};
var IsStringExpression = function(expression) {
  return expression.type === "const" && expression.const === ".*";
};
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

class TemplateLiteralFiniteError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/generate.mjs
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

class TemplateLiteralGenerateError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/literal/literal.mjs
function Literal(value2, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value2,
    type: typeof value2
  };
}
// node_modules/@sinclair/typebox/build/import/type/boolean/boolean.mjs
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// node_modules/@sinclair/typebox/build/import/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// node_modules/@sinclair/typebox/build/import/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// node_modules/@sinclair/typebox/build/import/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal3) => Literal(literal3.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// node_modules/@sinclair/typebox/build/import/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternBooleanExact = `^${PatternBoolean}\$`;
var PatternNumberExact = `^${PatternNumber}\$`;
var PatternStringExact = `^${PatternString}\$`;
// node_modules/@sinclair/typebox/build/import/type/template-literal/pattern.mjs
var Escape = function(value2) {
  return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var Visit2 = function(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
};
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

class TemplateLiteralPatternError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern2 = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern: pattern2 };
}
// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-property-keys.mjs
var FromTemplateLiteral = function(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
};
var FromUnion2 = function(T) {
  return T.reduce((Acc, L) => {
    return [...Acc, ...IndexPropertyKeys(L)];
  }, []);
};
var FromLiteral = function(T) {
  return [T.toString()];
};
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-result.mjs
var FromProperties2 = function(T, P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Index(T, IndexPropertyKeys(P[K2]), options) };
  }, {});
};
var FromMappedResult2 = function(T, R, options) {
  return FromProperties2(T, R.properties, options);
};
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed.mjs
var FromRest = function(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
};
var FromIntersectRest = function(T) {
  return T.filter((L) => !IsNever(L));
};
var FromIntersect = function(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
};
var FromUnionRest = function(T) {
  return T.some((L) => IsNever(L)) ? [] : T;
};
var FromUnion3 = function(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
};
var FromTuple = function(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
};
var FromArray = function(T, K) {
  return K === "[number]" ? T : Never();
};
var FromProperty = function(T, K) {
  return K in T ? T[K] : Never();
};
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
var FromSchema = function(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
};
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-key.mjs
var MappedIndexPropertyKey = function(T, K, options) {
  return { [K]: Index(T, [K], options) };
};
var MappedIndexPropertyKeys = function(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
};
var MappedIndexProperties = function(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
};
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/import/type/object/object.mjs
var _Object = function(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: CloneType(properties[key]) }), {});
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
};
var Object2 = _Object;
// node_modules/@sinclair/typebox/build/import/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// node_modules/@sinclair/typebox/build/import/type/readonly/readonly.mjs
var RemoveReadonly = function(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
};
var AddReadonly = function(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
};
var ReadonlyWithFlag = function(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
};
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/import/type/readonly/readonly-from-mapped-result.mjs
var FromProperties3 = function(K, F) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Readonly(K[K2], F) };
  }, {});
};
var FromMappedResult3 = function(R, F) {
  return FromProperties3(R.properties, F);
};
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// node_modules/@sinclair/typebox/build/import/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
var SetIntersectManyResolve = function(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
};
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  return T.reduce((Acc, L) => [...Acc, ...L], []);
}
// node_modules/@sinclair/typebox/build/import/type/mapped/mapped.mjs
var FromMappedResult4 = function(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
};
var MappedKeyToKnownMappedResultProperties = function(K) {
  return { [K]: Literal(K) };
};
var MappedKeyToUnknownMappedResultProperties = function(P) {
  return P.reduce((Acc, L) => {
    return { ...Acc, [L]: Literal(L) };
  }, {});
};
var MappedKeyToMappedResultProperties = function(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
};
var FromMappedKey = function(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
};
var FromRest2 = function(K, T) {
  return T.map((L) => FromSchemaType(K, L));
};
var FromProperties4 = function(K, T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K2) => {
    return { ...Acc, [K2]: FromSchemaType(K, T[K2]) };
  }, {});
};
var FromSchemaType = function(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
};
function MappedFunctionReturnType(K, T, Acc = {}) {
  return K.reduce((Acc2, L) => {
    return { ...Acc2, [L]: FromSchemaType(L, T) };
  }, {});
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// node_modules/@sinclair/typebox/build/import/type/keyof/keyof-property-keys.mjs
var FromRest3 = function(T) {
  return T.reduce((Acc, L) => {
    return [...Acc, KeyOfPropertyKeys(L)];
  }, []);
};
var FromIntersect2 = function(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
};
var FromUnion4 = function(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
};
var FromTuple2 = function(T) {
  return T.map((_, I) => I.toString());
};
var FromArray2 = function(_) {
  return ["[number]"];
};
var FromProperties5 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T);
};
var FromPatternProperties = function(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
};
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern3 = keys.map((key) => `(${key})`);
  return `^(${pattern3.join("|")})\$`;
}
var includePatternProperties = false;

// node_modules/@sinclair/typebox/build/import/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// node_modules/@sinclair/typebox/build/import/type/keyof/keyof-from-mapped-result.mjs
var FromProperties6 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: KeyOf(K[K2], options) };
  }, {});
};
var FromMappedResult5 = function(R, options) {
  return FromProperties6(R.properties, options);
};
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/extends/extends-undefined.mjs
var Intersect2 = function(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
};
var Union2 = function(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
};
var Not = function(schema) {
  return !ExtendsUndefinedCheck(schema.not);
};
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/import/errors/function.mjs
function DefaultErrorFunction(error8) {
  switch (error8.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error8.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error8.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error8.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error8.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error8.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error8.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error8.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error8.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error8.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error8.schema.const === "string" ? `'${error8.schema.const}'` : error8.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error8.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error8.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error8.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error8.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error8.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error8.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error8.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error8.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error8.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error8.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error8.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
function GetErrorFunction() {
  return errorFunction;
}
var errorFunction = DefaultErrorFunction;

// node_modules/@sinclair/typebox/build/import/value/deref/deref.mjs
function Deref(schema, references) {
  const index = references.findIndex((target) => target.$id === schema.$ref);
  if (index === -1)
    throw new TypeDereferenceError(schema);
  return references[index];
}

class TypeDereferenceError extends TypeBoxError {
  schema;
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$id}'`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/hash/hash.mjs
function* NumberToBytes(value3) {
  const byteCount = value3 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value3) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value3 >> 8 * (byteCount - 1 - i) & 255;
  }
}
var ArrayType2 = function(value3) {
  FNV1A64(ByteMarker.Array);
  for (const item of value3) {
    Visit3(item);
  }
};
var BooleanType = function(value3) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value3 ? 1 : 0);
};
var BigIntType = function(value3) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var DateType2 = function(value3) {
  FNV1A64(ByteMarker.Date);
  Visit3(value3.getTime());
};
var NullType = function(value3) {
  FNV1A64(ByteMarker.Null);
};
var NumberType = function(value3) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var ObjectType2 = function(value3) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.keys(value3).sort()) {
    Visit3(key);
    Visit3(value3[key]);
  }
};
var StringType = function(value3) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value3.length; i++) {
    for (const byte of NumberToBytes(value3.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
};
var SymbolType = function(value3) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value3.description);
};
var Uint8ArrayType2 = function(value3) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value3.length; i++) {
    FNV1A64(value3[i]);
  }
};
var UndefinedType = function(value3) {
  return FNV1A64(ByteMarker.Undefined);
};
var Visit3 = function(value3) {
  if (IsArray(value3))
    return ArrayType2(value3);
  if (IsBoolean(value3))
    return BooleanType(value3);
  if (IsBigInt(value3))
    return BigIntType(value3);
  if (IsDate(value3))
    return DateType2(value3);
  if (IsNull(value3))
    return NullType(value3);
  if (IsNumber(value3))
    return NumberType(value3);
  if (IsStandardObject(value3))
    return ObjectType2(value3);
  if (IsString(value3))
    return StringType(value3);
  if (IsSymbol(value3))
    return SymbolType(value3);
  if (IsUint8Array(value3))
    return Uint8ArrayType2(value3);
  if (IsUndefined(value3))
    return UndefinedType(value3);
  throw new ValueHashError(value3);
};
var FNV1A64 = function(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
};
function Hash(value3) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value3);
  return Accumulator;
}

class ValueHashError extends TypeBoxError {
  value;
  constructor(value3) {
    super(`Unable to hash value`);
    this.value = value3;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
// node_modules/@sinclair/typebox/build/import/errors/errors.mjs
var EscapeKey = function(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
};
var IsDefined = function(value3) {
  return value3 !== undefined;
};
var Create = function(errorType, schema, path, value3) {
  return { type: errorType, schema, path, value: value3, message: GetErrorFunction()({ errorType, path, schema, value: value3 }) };
};
function* FromAny(schema, references, path, value3) {
}
function* FromArray3(schema, references, path, value3) {
  if (!IsArray(value3)) {
    return yield Create(ValueErrorType.Array, schema, path, value3);
  }
  if (IsDefined(schema.minItems) && !(value3.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value3);
  }
  if (IsDefined(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value3);
  }
  for (let i = 0;i < value3.length; i++) {
    yield* Visit4(schema.items, references, `${path}/${i}`, value3[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value3);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4, index) => Visit4(containsSchema, references, `${path}${index}`, value4).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value3);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value3);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value3);
  }
}
function* FromAsyncIterator(schema, references, path, value3) {
  if (!IsAsyncIterator(value3))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value3);
}
function* FromBigInt(schema, references, path, value3) {
  if (!IsBigInt(value3))
    return yield Create(ValueErrorType.BigInt, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value3);
  }
}
function* FromBoolean(schema, references, path, value3) {
  if (!IsBoolean(value3))
    yield Create(ValueErrorType.Boolean, schema, path, value3);
}
function* FromConstructor(schema, references, path, value3) {
  yield* Visit4(schema.returns, references, path, value3.prototype);
}
function* FromDate(schema, references, path, value3) {
  if (!IsDate(value3))
    return yield Create(ValueErrorType.Date, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value3);
  }
}
function* FromFunction(schema, references, path, value3) {
  if (!IsFunction(value3))
    yield Create(ValueErrorType.Function, schema, path, value3);
}
function* FromInteger(schema, references, path, value3) {
  if (!IsInteger(value3))
    return yield Create(ValueErrorType.Integer, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value3);
  }
}
function* FromIntersect3(schema, references, path, value3) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path, value3).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path, value3);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value3);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value3[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path, value3) {
  if (!IsIterator(value3))
    yield Create(ValueErrorType.Iterator, schema, path, value3);
}
function* FromLiteral2(schema, references, path, value3) {
  if (!(value3 === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value3);
}
function* FromNever(schema, references, path, value3) {
  yield Create(ValueErrorType.Never, schema, path, value3);
}
function* FromNot(schema, references, path, value3) {
  if (Visit4(schema.not, references, path, value3).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value3);
}
function* FromNull(schema, references, path, value3) {
  if (!IsNull(value3))
    yield Create(ValueErrorType.Null, schema, path, value3);
}
function* FromNumber(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return yield Create(ValueErrorType.Number, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value3);
  }
}
function* FromObject(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value3);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value3)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey)) {
        yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path, value3) {
  if (!IsPromise(value3))
    yield Create(ValueErrorType.Promise, schema, path, value3);
}
function* FromRecord(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value3)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromRegExp(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value3)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value3);
  }
}
function* FromString(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value3);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value3);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value3)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value3);
      }
    }
  }
}
function* FromSymbol(schema, references, path, value3) {
  if (!IsSymbol(value3))
    yield Create(ValueErrorType.Symbol, schema, path, value3);
}
function* FromTemplateLiteral2(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value3)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value3);
  }
}
function* FromThis(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromTuple3(schema, references, path, value3) {
  if (!IsArray(value3))
    return yield Create(ValueErrorType.Tuple, schema, path, value3);
  if (schema.items === undefined && !(value3.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!(value3.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path}/${i}`, value3[i]);
  }
}
function* FromUndefined(schema, references, path, value3) {
  if (!IsUndefined(value3))
    yield Create(ValueErrorType.Undefined, schema, path, value3);
}
function* FromUnion5(schema, references, path, value3) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors2 = [...Visit4(subschema, references, path, value3)];
    if (errors2.length === 0)
      return;
    count += errors2.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path, value3);
  }
}
function* FromUint8Array(schema, references, path, value3) {
  if (!IsUint8Array(value3))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value3);
  if (IsDefined(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value3);
  }
  if (IsDefined(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value3);
  }
}
function* FromUnknown(schema, references, path, value3) {
}
function* FromVoid(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsVoidLike(value3))
    yield Create(ValueErrorType.Void, schema, path, value3);
}
function* FromKind(schema, references, path, value3) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value3))
    yield Create(ValueErrorType.Kind, schema, path, value3);
}
function* Visit4(schema, references, path, value3) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value3);
    case "Array":
      return yield* FromArray3(schema_, references_, path, value3);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value3);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value3);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value3);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value3);
    case "Date":
      return yield* FromDate(schema_, references_, path, value3);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value3);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value3);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path, value3);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value3);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path, value3);
    case "Never":
      return yield* FromNever(schema_, references_, path, value3);
    case "Not":
      return yield* FromNot(schema_, references_, path, value3);
    case "Null":
      return yield* FromNull(schema_, references_, path, value3);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value3);
    case "Object":
      return yield* FromObject(schema_, references_, path, value3);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value3);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value3);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value3);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value3);
    case "String":
      return yield* FromString(schema_, references_, path, value3);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value3);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path, value3);
    case "This":
      return yield* FromThis(schema_, references_, path, value3);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path, value3);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value3);
    case "Union":
      return yield* FromUnion5(schema_, references_, path, value3);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value3);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value3);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value3);
  }
}
function Errors(...args) {
  const iterator3 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator3);
}
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class ValueErrorIterator {
  iterator;
  constructor(iterator3) {
    this.iterator = iterator3;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
// node_modules/@sinclair/typebox/build/import/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// node_modules/@sinclair/typebox/build/import/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// node_modules/@sinclair/typebox/build/import/type/extends/extends-check.mjs
var IntoBooleanResult = function(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
};
var Throw = function(message) {
  throw new ExtendsResolverError(message);
};
var IsStructuralRight = function(right) {
  return exports_type2.IsNever(right) || exports_type2.IsIntersect(right) || exports_type2.IsUnion(right) || exports_type2.IsUnknown(right) || exports_type2.IsAny(right);
};
var StructuralRight = function(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
};
var FromAnyRight = function(left, right) {
  return ExtendsResult.True;
};
var FromAny2 = function(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) && right.anyOf.some((schema) => exports_type2.IsAny(schema) || exports_type2.IsUnknown(schema)) ? ExtendsResult.True : exports_type2.IsUnion(right) ? ExtendsResult.Union : exports_type2.IsUnknown(right) ? ExtendsResult.True : exports_type2.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
};
var FromArrayRight = function(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromArray4 = function(left, right) {
  return exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromAsyncIterator2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromBigInt2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBooleanRight = function(left, right) {
  return exports_type2.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type2.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBoolean2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromConstructor2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
};
var FromDate2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromFunction2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
};
var FromIntegerRight = function(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromInteger2 = function(left, right) {
  return exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
};
var FromIntersectRight = function(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIntersect4 = function(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIterator2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromLiteral3 = function(left, right) {
  return exports_type2.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
};
var FromNeverRight = function(left, right) {
  return ExtendsResult.False;
};
var FromNever2 = function(left, right) {
  return ExtendsResult.True;
};
var UnwrapTNot = function(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type2.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
};
var FromNot2 = function(left, right) {
  return exports_type2.IsNot(left) ? Visit5(UnwrapTNot(left), right) : exports_type2.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
};
var FromNull2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumberRight = function(left, right) {
  return exports_type2.IsLiteralNumber(left) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumber2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
};
var IsObjectPropertyCount = function(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
};
var IsObjectStringLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectSymbolLike = function(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type2.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type2.IsString(schema.properties.description.anyOf[0]) && exports_type2.IsUndefined(schema.properties.description.anyOf[1]) || exports_type2.IsString(schema.properties.description.anyOf[1]) && exports_type2.IsUndefined(schema.properties.description.anyOf[0]));
};
var IsObjectNumberLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBooleanLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBigIntLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectDateLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectUint8ArrayLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectFunctionLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectConstructorLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectArrayLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectPromiseLike = function(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
};
var Property = function(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type2.IsOptional(left) && !exports_type2.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
};
var FromObjectRight = function(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) || exports_type2.IsLiteralString(left) && IsObjectStringLike(right) || exports_type2.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type2.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type2.IsString(left) && IsObjectStringLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsNumber(left) && IsObjectNumberLike(right) || exports_type2.IsInteger(left) && IsObjectNumberLike(right) || exports_type2.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type2.IsDate(left) && IsObjectDateLike(right) || exports_type2.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type2.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type2.IsRecord(left) && exports_type2.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type2.IsRecord(left) && exports_type2.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
};
var FromObject2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : !exports_type2.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
};
var FromPromise2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type2.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
};
var RecordKey = function(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
};
var RecordValue = function(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
};
var FromRecordRight = function(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type2.IsLiteralString(left) && exports_type2.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type2.IsUint8Array(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsString(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsArray(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
};
var FromRecord2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
};
var FromRegExp2 = function(left, right) {
  const L = exports_type2.IsRegExp(left) ? String2() : left;
  const R = exports_type2.IsRegExp(right) ? String2() : right;
  return Visit5(L, R);
};
var FromStringRight = function(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type2.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromString2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromSymbol2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromTemplateLiteral3 = function(left, right) {
  return exports_type2.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : exports_type2.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
};
var IsArrayOfTuple = function(left, right) {
  return exports_type2.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
};
var FromTupleRight = function(left, right) {
  return exports_type2.IsNever(left) ? ExtendsResult.True : exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
};
var FromTuple4 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type2.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type2.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit5(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUint8Array2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUndefined2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsVoid(right) ? FromVoidRight(left, right) : exports_type2.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnionRight = function(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnion6 = function(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnknownRight = function(left, right) {
  return ExtendsResult.True;
};
var FromUnknown2 = function(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type2.IsArray(right) ? FromArrayRight(left, right) : exports_type2.IsTuple(right) ? FromTupleRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoidRight = function(left, right) {
  return exports_type2.IsUndefined(left) ? ExtendsResult.True : exports_type2.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoid2 = function(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
};
var Visit5 = function(left, right) {
  return exports_type2.IsTemplateLiteral(left) || exports_type2.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : exports_type2.IsRegExp(left) || exports_type2.IsRegExp(right) ? FromRegExp2(left, right) : exports_type2.IsNot(left) || exports_type2.IsNot(right) ? FromNot2(left, right) : exports_type2.IsAny(left) ? FromAny2(left, right) : exports_type2.IsArray(left) ? FromArray4(left, right) : exports_type2.IsBigInt(left) ? FromBigInt2(left, right) : exports_type2.IsBoolean(left) ? FromBoolean2(left, right) : exports_type2.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : exports_type2.IsConstructor(left) ? FromConstructor2(left, right) : exports_type2.IsDate(left) ? FromDate2(left, right) : exports_type2.IsFunction(left) ? FromFunction2(left, right) : exports_type2.IsInteger(left) ? FromInteger2(left, right) : exports_type2.IsIntersect(left) ? FromIntersect4(left, right) : exports_type2.IsIterator(left) ? FromIterator2(left, right) : exports_type2.IsLiteral(left) ? FromLiteral3(left, right) : exports_type2.IsNever(left) ? FromNever2(left, right) : exports_type2.IsNull(left) ? FromNull2(left, right) : exports_type2.IsNumber(left) ? FromNumber2(left, right) : exports_type2.IsObject(left) ? FromObject2(left, right) : exports_type2.IsRecord(left) ? FromRecord2(left, right) : exports_type2.IsString(left) ? FromString2(left, right) : exports_type2.IsSymbol(left) ? FromSymbol2(left, right) : exports_type2.IsTuple(left) ? FromTuple4(left, right) : exports_type2.IsPromise(left) ? FromPromise2(left, right) : exports_type2.IsUint8Array(left) ? FromUint8Array2(left, right) : exports_type2.IsUndefined(left) ? FromUndefined2(left, right) : exports_type2.IsUnion(left) ? FromUnion6(left, right) : exports_type2.IsUnknown(left) ? FromUnknown2(left, right) : exports_type2.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
};
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}

class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
// node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-result.mjs
var FromProperties7 = function(P, Right, True, False, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extends(P[K2], Right, True, False, options) };
  }, {});
};
var FromMappedResult6 = function(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
};
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/extends/extends.mjs
var ExtendsResolve = function(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
};
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-key.mjs
var FromPropertyKey = function(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
};
var FromPropertyKeys = function(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
};
var FromMappedKey2 = function(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
};
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/value/check/check.mjs
var IsAnyOrUnknown = function(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
};
var IsDefined2 = function(value3) {
  return value3 !== undefined;
};
var FromAny3 = function(schema, references, value3) {
  return true;
};
var FromArray5 = function(schema, references, value3) {
  if (!IsArray(value3))
    return false;
  if (IsDefined2(schema.minItems) && !(value3.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    return false;
  }
  if (!value3.every((value4) => Visit6(schema.items, references, value4))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4) => Visit6(containsSchema, references, value4) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
};
var FromAsyncIterator3 = function(schema, references, value3) {
  return IsAsyncIterator(value3);
};
var FromBigInt3 = function(schema, references, value3) {
  if (!IsBigInt(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
};
var FromBoolean3 = function(schema, references, value3) {
  return IsBoolean(value3);
};
var FromConstructor3 = function(schema, references, value3) {
  return Visit6(schema.returns, references, value3.prototype);
};
var FromDate3 = function(schema, references, value3) {
  if (!IsDate(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
};
var FromFunction3 = function(schema, references, value3) {
  return IsFunction(value3);
};
var FromInteger3 = function(schema, references, value3) {
  if (!IsInteger(value3)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromIntersect5 = function(schema, references, value3) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value3));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value3[key]));
    return check1 && check2;
  } else {
    return check1;
  }
};
var FromIterator3 = function(schema, references, value3) {
  return IsIterator(value3);
};
var FromLiteral4 = function(schema, references, value3) {
  return value3 === schema.const;
};
var FromNever3 = function(schema, references, value3) {
  return false;
};
var FromNot3 = function(schema, references, value3) {
  return !Visit6(schema.not, references, value3);
};
var FromNull3 = function(schema, references, value3) {
  return IsNull(value3);
};
var FromNumber3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromObject3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value3[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value3)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey) && !Visit6(property, references, value3[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value3);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value3);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value3[key]));
  } else {
    return true;
  }
};
var FromPromise3 = function(schema, references, value3) {
  return IsPromise(value3);
};
var FromRecord3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value3).every(([key, value4]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value4) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value3).every(([key, value4]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value4) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value3).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
};
var FromRef2 = function(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
};
var FromRegExp3 = function(schema, references, value3) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  return regex.test(value3);
};
var FromString3 = function(schema, references, value3) {
  if (!IsString(value3)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value3);
  }
  return true;
};
var FromSymbol3 = function(schema, references, value3) {
  return IsSymbol(value3);
};
var FromTemplateLiteral4 = function(schema, references, value3) {
  return IsString(value3) && new RegExp(schema.pattern).test(value3);
};
var FromThis2 = function(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
};
var FromTuple5 = function(schema, references, value3) {
  if (!IsArray(value3)) {
    return false;
  }
  if (schema.items === undefined && !(value3.length === 0)) {
    return false;
  }
  if (!(value3.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value3[i]))
      return false;
  }
  return true;
};
var FromUndefined3 = function(schema, references, value3) {
  return IsUndefined(value3);
};
var FromUnion7 = function(schema, references, value3) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value3));
};
var FromUint8Array3 = function(schema, references, value3) {
  if (!IsUint8Array(value3)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    return false;
  }
  return true;
};
var FromUnknown3 = function(schema, references, value3) {
  return true;
};
var FromVoid3 = function(schema, references, value3) {
  return TypeSystemPolicy.IsVoidLike(value3);
};
var FromKind2 = function(schema, references, value3) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value3);
};
var Visit6 = function(schema, references, value3) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value3);
    case "Array":
      return FromArray5(schema_, references_, value3);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value3);
    case "BigInt":
      return FromBigInt3(schema_, references_, value3);
    case "Boolean":
      return FromBoolean3(schema_, references_, value3);
    case "Constructor":
      return FromConstructor3(schema_, references_, value3);
    case "Date":
      return FromDate3(schema_, references_, value3);
    case "Function":
      return FromFunction3(schema_, references_, value3);
    case "Integer":
      return FromInteger3(schema_, references_, value3);
    case "Intersect":
      return FromIntersect5(schema_, references_, value3);
    case "Iterator":
      return FromIterator3(schema_, references_, value3);
    case "Literal":
      return FromLiteral4(schema_, references_, value3);
    case "Never":
      return FromNever3(schema_, references_, value3);
    case "Not":
      return FromNot3(schema_, references_, value3);
    case "Null":
      return FromNull3(schema_, references_, value3);
    case "Number":
      return FromNumber3(schema_, references_, value3);
    case "Object":
      return FromObject3(schema_, references_, value3);
    case "Promise":
      return FromPromise3(schema_, references_, value3);
    case "Record":
      return FromRecord3(schema_, references_, value3);
    case "Ref":
      return FromRef2(schema_, references_, value3);
    case "RegExp":
      return FromRegExp3(schema_, references_, value3);
    case "String":
      return FromString3(schema_, references_, value3);
    case "Symbol":
      return FromSymbol3(schema_, references_, value3);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value3);
    case "This":
      return FromThis2(schema_, references_, value3);
    case "Tuple":
      return FromTuple5(schema_, references_, value3);
    case "Undefined":
      return FromUndefined3(schema_, references_, value3);
    case "Union":
      return FromUnion7(schema_, references_, value3);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value3);
    case "Unknown":
      return FromUnknown3(schema_, references_, value3);
    case "Void":
      return FromVoid3(schema_, references_, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value3);
  }
};
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}

class ValueCheckUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/clone/clone.mjs
var ObjectType3 = function(value3) {
  const keys = [...Object.getOwnPropertyNames(value3), ...Object.getOwnPropertySymbols(value3)];
  return keys.reduce((acc, key) => ({ ...acc, [key]: Clone2(value3[key]) }), {});
};
var ArrayType3 = function(value3) {
  return value3.map((element) => Clone2(element));
};
var TypedArrayType = function(value3) {
  return value3.slice();
};
var DateType3 = function(value3) {
  return new Date(value3.toISOString());
};
var ValueType = function(value3) {
  return value3;
};
function Clone2(value3) {
  if (IsArray(value3))
    return ArrayType3(value3);
  if (IsDate(value3))
    return DateType3(value3);
  if (IsStandardObject(value3))
    return ObjectType3(value3);
  if (IsTypedArray(value3))
    return TypedArrayType(value3);
  if (IsValueType(value3))
    return ValueType(value3);
  throw new Error("ValueClone: Unable to clone value");
}
// node_modules/@sinclair/typebox/build/import/value/create/create.mjs
var FromDefault = function(value3) {
  return typeof value3 === "function" ? value3 : Clone2(value3);
};
var FromAny4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromArray6 = function(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
};
var FromAsyncIterator4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
};
var FromBigInt4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
};
var FromBoolean4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
};
var FromConstructor4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = Visit7(schema.returns, references);
    if (typeof value3 === "object" && !Array.isArray(value3)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value3)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
};
var FromDate4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
};
var FromFunction4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
};
var FromInteger4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromIntersect6 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value3))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value3;
  }
};
var FromIterator4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
};
var FromLiteral5 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
};
var FromNever4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
};
var FromNot4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
};
var FromNull4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
};
var FromNumber4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromObject4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    return FromDefault(schema.default) || Object.entries(schema.properties).reduce((acc, [key, schema2]) => {
      return required.has(key) ? { ...acc, [key]: Visit7(schema2, references) } : { ...acc };
    }, {});
  }
};
var FromPromise4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
};
var FromRecord4 = function(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    return propertyKeys.reduce((acc, key) => {
      return { ...acc, [key]: Visit7(valueSchema, references) };
    }, {});
  } else {
    return {};
  }
};
var FromRef3 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromRegExp4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
};
var FromString4 = function(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
};
var FromSymbol4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
};
var FromTemplateLiteral5 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
};
var FromThis3 = function(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromTuple6 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
};
var FromUndefined4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromUnion8 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
};
var FromUint8Array4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
};
var FromUnknown4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromVoid4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromKind3 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
};
var Visit7 = function(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
};
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

class ValueCreateError extends TypeBoxError {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
// node_modules/@sinclair/typebox/build/import/value/cast/cast.mjs
var ScoreUnion = function(schema, references, value3) {
  if (schema[Kind] === "Object" && typeof value3 === "object" && !IsNull(value3)) {
    const object3 = schema;
    const keys = Object.getOwnPropertyNames(value3);
    const entries = Object.entries(object3.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal7 = schema2[Kind] === "Literal" && schema2.const === value3[key] ? max : 0;
      const checks = Check(schema2, references, value3[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal7 + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value3) ? 1 : 0;
  }
};
var SelectUnion = function(union9, references, value3) {
  let [select, best] = [union9.anyOf[0], 0];
  for (const schema of union9.anyOf) {
    const score = ScoreUnion(schema, references, value3);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
};
var CastUnion = function(union9, references, value3) {
  if ("default" in union9) {
    return typeof value3 === "function" ? union9.default : Clone2(union9.default);
  } else {
    const schema = SelectUnion(union9, references, value3);
    return Cast(schema, references, value3);
  }
};
var DefaultClone = function(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : Create2(schema, references);
};
var Default = function(schema, references, value3) {
  return Check(schema, references, value3) ? value3 : Create2(schema, references);
};
var FromArray7 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  const created = IsArray(value3) ? Clone2(value3) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value4) => Visit8(schema.items, references, value4));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
};
var FromConstructor5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value3.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value3.prototype[key]);
  }
  return result;
};
var FromIntersect7 = function(schema, references, value3) {
  const created = Create2(schema, references);
  const mapped9 = IsStandardObject(created) && IsStandardObject(value3) ? { ...created, ...value3 } : value3;
  return Check(schema, references, mapped9) ? mapped9 : Create2(schema, references);
};
var FromNever5 = function(schema, references, value3) {
  throw new ValueCastError(schema, "Never types cannot be cast");
};
var FromObject5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return value3;
  if (value3 === null || typeof value3 !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value3[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value3[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value3)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value3[propertyName]);
    }
  }
  return result;
};
var FromRecord5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (value3 === null || typeof value3 !== "object" || Array.isArray(value3) || value3 instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
};
var FromRef4 = function(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
};
var FromThis4 = function(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
};
var FromTuple7 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (!IsArray(value3))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value3[index]));
};
var FromUnion9 = function(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : CastUnion(schema, references, value3);
};
var Visit8 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value3);
    case "Constructor":
      return FromConstructor5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect7(schema_, references_, value3);
    case "Never":
      return FromNever5(schema_, references_, value3);
    case "Object":
      return FromObject5(schema_, references_, value3);
    case "Record":
      return FromRecord5(schema_, references_, value3);
    case "Ref":
      return FromRef4(schema_, references_, value3);
    case "This":
      return FromThis4(schema_, references_, value3);
    case "Tuple":
      return FromTuple7(schema_, references_, value3);
    case "Union":
      return FromUnion9(schema_, references_, value3);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value3);
    default:
      return Default(schema_, references_, value3);
  }
};
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}

class ValueCastError extends TypeBoxError {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/clean/clean.mjs
var IsCheckable = function(schema) {
  return IsSchema(schema) && schema[Kind] !== "Unsafe";
};
var FromArray8 = function(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  return value3.map((value4) => Visit9(schema.items, references, value4));
};
var FromIntersect8 = function(schema, references, value3) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value3)));
  const composite = intersections.reduce((acc, value4) => IsObject(value4) ? { ...acc, ...value4 } : value4, {});
  if (!IsObject(value3) || !IsObject(composite) || !IsSchema(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value3[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value3[key]);
    }
  }
  return composite;
};
var FromObject6 = function(schema, references, value3) {
  if (!IsObject(value3) || IsArray(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (key in schema.properties) {
      value3[key] = Visit9(schema.properties[key], references, value3[key]);
      continue;
    }
    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
};
var FromRecord6 = function(schema, references, value3) {
  if (!IsObject(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.keys(value3);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value3[key] = Visit9(propertySchema, references, value3[key]);
      continue;
    }
    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
};
var FromRef5 = function(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
};
var FromThis5 = function(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
};
var FromTuple8 = function(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value3.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value3[i] = Visit9(schema.items[i], references, value3[i]);
  }
  return value3.length > length ? value3.slice(0, length) : value3;
};
var FromUnion10 = function(schema, references, value3) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, value3)) {
      return Visit9(inner, references, value3);
    }
  }
  return value3;
};
var Visit9 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value3);
    case "Intersect":
      return FromIntersect8(schema_, references_, value3);
    case "Object":
      return FromObject6(schema_, references_, value3);
    case "Record":
      return FromRecord6(schema_, references_, value3);
    case "Ref":
      return FromRef5(schema_, references_, value3);
    case "This":
      return FromThis5(schema_, references_, value3);
    case "Tuple":
      return FromTuple8(schema_, references_, value3);
    case "Union":
      return FromUnion10(schema_, references_, value3);
    default:
      return value3;
  }
};
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/value/convert/convert.mjs
var IsStringNumeric = function(value3) {
  return IsString(value3) && !isNaN(value3) && !isNaN(parseFloat(value3));
};
var IsValueToString = function(value3) {
  return IsBigInt(value3) || IsBoolean(value3) || IsNumber(value3);
};
var IsValueTrue = function(value3) {
  return value3 === true || IsNumber(value3) && value3 === 1 || IsBigInt(value3) && value3 === BigInt("1") || IsString(value3) && (value3.toLowerCase() === "true" || value3 === "1");
};
var IsValueFalse = function(value3) {
  return value3 === false || IsNumber(value3) && (value3 === 0 || Object.is(value3, -0)) || IsBigInt(value3) && value3 === BigInt("0") || IsString(value3) && (value3.toLowerCase() === "false" || value3 === "0" || value3 === "-0");
};
var IsTimeStringWithTimeZone = function(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
};
var IsTimeStringWithoutTimeZone = function(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
};
var IsDateTimeStringWithTimeZone = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
};
var IsDateTimeStringWithoutTimeZone = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
};
var IsDateString = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value3);
};
var TryConvertLiteralString = function(value3, target) {
  const conversion = TryConvertString(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteralNumber = function(value3, target) {
  const conversion = TryConvertNumber(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteralBoolean = function(value3, target) {
  const conversion = TryConvertBoolean(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteral = function(schema, value3) {
  return IsString(schema.const) ? TryConvertLiteralString(value3, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value3, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value3, schema.const) : Clone2(value3);
};
var TryConvertBoolean = function(value3) {
  return IsValueTrue(value3) ? true : IsValueFalse(value3) ? false : value3;
};
var TryConvertBigInt = function(value3) {
  return IsStringNumeric(value3) ? BigInt(parseInt(value3)) : IsNumber(value3) ? BigInt(value3 | 0) : IsValueFalse(value3) ? BigInt(0) : IsValueTrue(value3) ? BigInt(1) : value3;
};
var TryConvertString = function(value3) {
  return IsValueToString(value3) ? value3.toString() : IsSymbol(value3) && value3.description !== undefined ? value3.description.toString() : value3;
};
var TryConvertNumber = function(value3) {
  return IsStringNumeric(value3) ? parseFloat(value3) : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
};
var TryConvertInteger = function(value3) {
  return IsStringNumeric(value3) ? parseInt(value3) : IsNumber(value3) ? value3 | 0 : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
};
var TryConvertNull = function(value3) {
  return IsString(value3) && value3.toLowerCase() === "null" ? null : value3;
};
var TryConvertUndefined = function(value3) {
  return IsString(value3) && value3 === "undefined" ? undefined : value3;
};
var TryConvertDate = function(value3) {
  return IsDate(value3) ? value3 : IsNumber(value3) ? new Date(value3) : IsValueTrue(value3) ? new Date(1) : IsValueFalse(value3) ? new Date(0) : IsStringNumeric(value3) ? new Date(parseInt(value3)) : IsTimeStringWithoutTimeZone(value3) ? new Date(`1970-01-01T${value3}.000Z`) : IsTimeStringWithTimeZone(value3) ? new Date(`1970-01-01T${value3}`) : IsDateTimeStringWithoutTimeZone(value3) ? new Date(`${value3}.000Z`) : IsDateTimeStringWithTimeZone(value3) ? new Date(value3) : IsDateString(value3) ? new Date(`${value3}T00:00:00.000Z`) : value3;
};
var Default2 = function(value3) {
  return value3;
};
var FromArray9 = function(schema, references, value3) {
  if (IsArray(value3)) {
    return value3.map((value4) => Visit10(schema.items, references, value4));
  }
  return value3;
};
var FromBigInt5 = function(schema, references, value3) {
  return TryConvertBigInt(value3);
};
var FromBoolean5 = function(schema, references, value3) {
  return TryConvertBoolean(value3);
};
var FromDate5 = function(schema, references, value3) {
  return TryConvertDate(value3);
};
var FromInteger5 = function(schema, references, value3) {
  return TryConvertInteger(value3);
};
var FromIntersect9 = function(schema, references, value3) {
  return schema.allOf.reduce((value4, schema2) => Visit10(schema2, references, value4), value3);
};
var FromLiteral6 = function(schema, references, value3) {
  return TryConvertLiteral(schema, value3);
};
var FromNull5 = function(schema, references, value3) {
  return TryConvertNull(value3);
};
var FromNumber5 = function(schema, references, value3) {
  return TryConvertNumber(value3);
};
var FromObject7 = function(schema, references, value3) {
  const isConvertable = IsObject(value3);
  if (!isConvertable)
    return value3;
  return Object.getOwnPropertyNames(schema.properties).reduce((value4, key) => {
    return !IsUndefined(value4[key]) ? { ...value4, [key]: Visit10(schema.properties[key], references, value4[key]) } : { ...value4 };
  }, value3);
};
var FromRecord7 = function(schema, references, value3) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
};
var FromRef6 = function(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
};
var FromString5 = function(schema, references, value3) {
  return TryConvertString(value3);
};
var FromSymbol5 = function(schema, references, value3) {
  return IsString(value3) || IsNumber(value3) ? Symbol(value3) : value3;
};
var FromThis6 = function(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
};
var FromTuple9 = function(schema, references, value3) {
  const isConvertable = IsArray(value3) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value3;
  return value3.map((value4, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value4) : value4;
  });
};
var FromUndefined5 = function(schema, references, value3) {
  return TryConvertUndefined(value3);
};
var FromUnion11 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value3);
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value3;
};
var Visit10 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value3);
    case "BigInt":
      return FromBigInt5(schema_, references_, value3);
    case "Boolean":
      return FromBoolean5(schema_, references_, value3);
    case "Date":
      return FromDate5(schema_, references_, value3);
    case "Integer":
      return FromInteger5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect9(schema_, references_, value3);
    case "Literal":
      return FromLiteral6(schema_, references_, value3);
    case "Null":
      return FromNull5(schema_, references_, value3);
    case "Number":
      return FromNumber5(schema_, references_, value3);
    case "Object":
      return FromObject7(schema_, references_, value3);
    case "Record":
      return FromRecord7(schema_, references_, value3);
    case "Ref":
      return FromRef6(schema_, references_, value3);
    case "String":
      return FromString5(schema_, references_, value3);
    case "Symbol":
      return FromSymbol5(schema_, references_, value3);
    case "This":
      return FromThis6(schema_, references_, value3);
    case "Tuple":
      return FromTuple9(schema_, references_, value3);
    case "Undefined":
      return FromUndefined5(schema_, references_, value3);
    case "Union":
      return FromUnion11(schema_, references_, value3);
    default:
      return Default2(value3);
  }
};
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/value/default/default.mjs
var ValueOrDefault = function(schema, value3) {
  return value3 === undefined && "default" in schema ? Clone2(schema.default) : value3;
};
var IsCheckable2 = function(schema) {
  return IsSchema(schema) && schema[Kind] !== "Unsafe";
};
var IsDefaultSchema = function(value3) {
  return IsSchema(value3) && "default" in value3;
};
var FromArray10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
};
var FromIntersect10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
};
var FromObject8 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRecord8 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRef7 = function(schema, references, value3) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value3));
};
var FromThis7 = function(schema, references, value3) {
  return Visit11(Deref(schema, references), references, value3);
};
var FromTuple10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
};
var FromUnion12 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
};
var Visit11 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value3);
    case "Intersect":
      return FromIntersect10(schema_, references_, value3);
    case "Object":
      return FromObject8(schema_, references_, value3);
    case "Record":
      return FromRecord8(schema_, references_, value3);
    case "Ref":
      return FromRef7(schema_, references_, value3);
    case "This":
      return FromThis7(schema_, references_, value3);
    case "Tuple":
      return FromTuple10(schema_, references_, value3);
    case "Union":
      return FromUnion12(schema_, references_, value3);
    default:
      return ValueOrDefault(schema_, value3);
  }
};
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => {
    {
      return ValuePointerRootSetError;
    }
  },
  ValuePointerRootDeleteError: () => {
    {
      return ValuePointerRootDeleteError;
    }
  },
  Set: () => {
    {
      return Set4;
    }
  },
  Has: () => {
    {
      return Has3;
    }
  },
  Get: () => {
    {
      return Get3;
    }
  },
  Format: () => {
    {
      return Format;
    }
  },
  Delete: () => {
    {
      return Delete3;
    }
  }
});
var Escape2 = function(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
};
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value3, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value3, pointer, update);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value3, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value3, pointer);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value3, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value3, pointer) {
  if (pointer === "")
    return value3;
  let current = value3;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}

class ValuePointerRootSetError extends TypeBoxError {
  value;
  path;
  update;
  constructor(value3, path, update) {
    super("Cannot set root value");
    this.value = value3;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  value;
  path;
  constructor(value3, path) {
    super("Cannot delete root value");
    this.value = value3;
    this.path = path;
  }
}
// node_modules/@sinclair/typebox/build/import/value/delta/delta.mjs
var CreateUpdate = function(path, value3) {
  return { type: "update", path, value: value3 };
};
var CreateInsert = function(path, value3) {
  return { type: "insert", path, value: value3 };
};
var CreateDelete = function(path) {
  return { type: "delete", path };
};
function* ObjectType4(path, current, next) {
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit12(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
var IsRootUpdate = function(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
};
var IsIdentity = function(edits) {
  return edits.length === 0;
};
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone8 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone8, edit.path);
        break;
      }
    }
  }
  return clone8;
}
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  value;
  constructor(value3, message) {
    super(message);
    this.value = value3;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  value;
  constructor(value3) {
    super(value3, "Cannot diff objects with symbol keys");
    this.value = value3;
  }
}
// node_modules/@sinclair/typebox/build/import/value/equal/equal.mjs
var ObjectType5 = function(left, right) {
  if (!IsStandardObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
};
var DateType4 = function(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
};
var ArrayType5 = function(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
};
var TypedArrayType3 = function(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
};
var ValueType3 = function(left, right) {
  return left === right;
};
function Equal(left, right) {
  if (IsStandardObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// node_modules/@sinclair/typebox/build/import/value/mutate/mutate.mjs
var ObjectType6 = function(root, path, current, next) {
  if (!IsStandardObject(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.keys(current);
    const nextKeys = Object.keys(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
};
var ArrayType6 = function(root, path, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
};
var TypedArrayType4 = function(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
};
var ValueType4 = function(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
};
var Visit13 = function(root, path, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path, current, next);
  if (IsStandardObject(next))
    return ObjectType6(root, path, current, next);
  if (IsValueType(next))
    return ValueType4(root, path, current, next);
};
var IsNonMutableValue = function(value3) {
  return IsTypedArray(value3) || IsValueType(value3);
};
var IsMismatchedValue = function(current, next) {
  return IsStandardObject(current) && IsArray(next) || IsArray(current) && IsStandardObject(next);
};
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/decode.mjs
var Default4 = function(schema, path, value3) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value3) : value3;
  } catch (error19) {
    throw new TransformDecodeError(schema, path, value3, error19);
  }
};
var FromArray11 = function(schema, references, path, value3) {
  return IsArray(value3) ? Default4(schema, path, value3.map((value4, index) => Visit14(schema.items, references, `${path}/${index}`, value4))) : Default4(schema, path, value3);
};
var FromIntersect11 = function(schema, references, path, value3) {
  if (!IsStandardObject(value3) || IsValueType(value3))
    return Default4(schema, path, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit14(Index(schema, [key]), references, `${path}/${key}`, value4[key]) } : value4;
  }, value3);
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default4(unevaluatedProperties, `${path}/${key}`, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, path, unknownProperties);
};
var FromNot5 = function(schema, references, path, value3) {
  return Default4(schema, path, Visit14(schema.not, references, path, value3));
};
var FromObject9 = function(schema, references, path, value3) {
  if (!IsStandardObject(value3))
    return Default4(schema, path, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit14(schema.properties[key], references, `${path}/${key}`, value4[key]) } : value4;
  }, value3);
  if (!IsSchema(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default4(additionalProperties, `${path}/${key}`, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, path, unknownProperties);
};
var FromRecord9 = function(schema, references, path, value3) {
  if (!IsStandardObject(value3))
    return Default4(schema, path, value3);
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = Object.getOwnPropertyNames(value3).reduce((value4, key) => {
    return knownKeys.test(key) ? { ...value4, [key]: Visit14(schema.patternProperties[pattern3], references, `${path}/${key}`, value4[key]) } : value4;
  }, value3);
  if (!IsSchema(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.test(key) ? { ...value4, [key]: Default4(additionalProperties, `${path}/${key}`, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, path, unknownProperties);
};
var FromRef8 = function(schema, references, path, value3) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value3));
};
var FromThis8 = function(schema, references, path, value3) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value3));
};
var FromTuple11 = function(schema, references, path, value3) {
  return IsArray(value3) && IsArray(schema.items) ? Default4(schema, path, schema.items.map((schema2, index) => Visit14(schema2, references, `${path}/${index}`, value3[index]))) : Default4(schema, path, value3);
};
var FromUnion13 = function(schema, references, path, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const decoded = Visit14(subschema, references, path, value3);
    return Default4(schema, path, decoded);
  }
  return Default4(schema, path, value3);
};
var Visit14 = function(schema, references, path, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, path, value3);
    case "Intersect":
      return FromIntersect11(schema_, references_, path, value3);
    case "Not":
      return FromNot5(schema_, references_, path, value3);
    case "Object":
      return FromObject9(schema_, references_, path, value3);
    case "Record":
      return FromRecord9(schema_, references_, path, value3);
    case "Ref":
      return FromRef8(schema_, references_, path, value3);
    case "Symbol":
      return Default4(schema_, path, value3);
    case "This":
      return FromThis8(schema_, references_, path, value3);
    case "Tuple":
      return FromTuple11(schema_, references_, path, value3);
    case "Union":
      return FromUnion13(schema_, references_, path, value3);
    default:
      return Default4(schema_, path, value3);
  }
};
function TransformDecode(schema, references, value3) {
  return Visit14(schema, references, "", value3);
}

class TransformDecodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(schema, value3, error19) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value3;
    this.error = error19;
  }
}

class TransformDecodeError extends TypeBoxError {
  schema;
  path;
  value;
  error;
  constructor(schema, path, value3, error19) {
    super(error19 instanceof Error ? error19.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value3;
    this.error = error19;
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/encode.mjs
var Default5 = function(schema, path, value3) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value3) : value3;
  } catch (error20) {
    throw new TransformEncodeError(schema, path, value3, error20);
  }
};
var FromArray12 = function(schema, references, path, value3) {
  const defaulted = Default5(schema, path, value3);
  return IsArray(defaulted) ? defaulted.map((value4, index) => Visit15(schema.items, references, `${path}/${index}`, value4)) : defaulted;
};
var FromIntersect12 = function(schema, references, path, value3) {
  const defaulted = Default5(schema, path, value3);
  if (!IsStandardObject(value3) || IsValueType(value3))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in defaulted ? { ...value4, [key]: Visit15(Index(schema, [key]), references, `${path}/${key}`, value4[key]) } : value4;
  }, defaulted);
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default5(unevaluatedProperties, `${path}/${key}`, value4[key]) } : value4;
  }, knownProperties);
};
var FromNot6 = function(schema, references, path, value3) {
  return Default5(schema.not, path, Default5(schema, path, value3));
};
var FromObject10 = function(schema, references, path, value3) {
  const defaulted = Default5(schema, path, value3);
  if (!IsStandardObject(value3))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit15(schema.properties[key], references, `${path}/${key}`, value4[key]) } : value4;
  }, defaulted);
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default5(additionalProperties, `${path}/${key}`, value4[key]) } : value4;
  }, knownProperties);
};
var FromRecord10 = function(schema, references, path, value3) {
  const defaulted = Default5(schema, path, value3);
  if (!IsStandardObject(value3))
    return defaulted;
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = Object.getOwnPropertyNames(value3).reduce((value4, key) => {
    return knownKeys.test(key) ? { ...value4, [key]: Visit15(schema.patternProperties[pattern3], references, `${path}/${key}`, value4[key]) } : value4;
  }, defaulted);
  if (!IsSchema(schema.additionalProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.test(key) ? { ...value4, [key]: Default5(additionalProperties, `${path}/${key}`, value4[key]) } : value4;
  }, knownProperties);
};
var FromRef9 = function(schema, references, path, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value3);
  return Default5(schema, path, resolved);
};
var FromThis9 = function(schema, references, path, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value3);
  return Default5(schema, path, resolved);
};
var FromTuple12 = function(schema, references, path, value3) {
  const value1 = Default5(schema, path, value3);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, `${path}/${index}`, value1[index])) : [];
};
var FromUnion14 = function(schema, references, path, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const value1 = Visit15(subschema, references, path, value3);
    return Default5(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, path, value3);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, path, value1);
  }
  return Default5(schema, path, value3);
};
var Visit15 = function(schema, references, path, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, path, value3);
    case "Intersect":
      return FromIntersect12(schema_, references_, path, value3);
    case "Not":
      return FromNot6(schema_, references_, path, value3);
    case "Object":
      return FromObject10(schema_, references_, path, value3);
    case "Record":
      return FromRecord10(schema_, references_, path, value3);
    case "Ref":
      return FromRef9(schema_, references_, path, value3);
    case "This":
      return FromThis9(schema_, references_, path, value3);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value3);
    case "Union":
      return FromUnion14(schema_, references_, path, value3);
    default:
      return Default5(schema_, path, value3);
  }
};
function TransformEncode(schema, references, value3) {
  return Visit15(schema, references, "", value3);
}

class TransformEncodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(schema, value3, error20) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value3;
    this.error = error20;
  }
}

class TransformEncodeError extends TypeBoxError {
  schema;
  path;
  value;
  error;
  constructor(schema, path, value3, error20) {
    super(`${error20 instanceof Error ? error20.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value3;
    this.error = error20;
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/has.mjs
var FromArray13 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromAsyncIterator5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromConstructor6 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
};
var FromFunction5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
};
var FromIntersect13 = function(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
};
var FromIterator5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromNot7 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.not, references);
};
var FromObject11 = function(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
};
var FromPromise5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.item, references);
};
var FromRecord11 = function(schema, references) {
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern3];
  return IsTransform(schema) || Visit16(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
};
var FromRef10 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit16(Deref(schema, references), references);
};
var FromThis10 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit16(Deref(schema, references), references);
};
var FromTuple13 = function(schema, references) {
  return IsTransform(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
};
var FromUnion15 = function(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
};
var Visit16 = function(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform(schema);
  }
};
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
var visited = new Set;
// node_modules/@sinclair/typebox/build/import/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => {
    {
      return Patch2;
    }
  },
  Mutate: () => {
    {
      return Mutate2;
    }
  },
  Hash: () => {
    {
      return Hash2;
    }
  },
  Errors: () => {
    {
      return Errors2;
    }
  },
  Equal: () => {
    {
      return Equal2;
    }
  },
  Encode: () => {
    {
      return Encode;
    }
  },
  Diff: () => {
    {
      return Diff2;
    }
  },
  Default: () => {
    {
      return Default6;
    }
  },
  Decode: () => {
    {
      return Decode;
    }
  },
  Create: () => {
    {
      return Create3;
    }
  },
  Convert: () => {
    {
      return Convert2;
    }
  },
  Clone: () => {
    {
      return Clone3;
    }
  },
  Clean: () => {
    {
      return Clean2;
    }
  },
  Check: () => {
    {
      return Check2;
    }
  },
  Cast: () => {
    {
      return Cast2;
    }
  }
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value3) {
  return Clone2(value3);
}
function Decode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value3))
    throw new TransformDecodeCheckError(schema, value3, Errors2(schema, references, value3).First());
  return TransformDecode(schema, references, value3);
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = TransformEncode(schema, references, value3);
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors2(schema, references, encoded).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value3) {
  return Hash(value3);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// node_modules/@sinclair/typebox/build/import/type/awaited/awaited.mjs
var FromRest4 = function(T) {
  return T.map((L) => AwaitedResolve(L));
};
var FromIntersect14 = function(T) {
  return Intersect(FromRest4(T));
};
var FromUnion16 = function(T) {
  return Union(FromRest4(T));
};
var FromPromise6 = function(T) {
  return AwaitedResolve(T);
};
var AwaitedResolve = function(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
};
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// node_modules/@sinclair/typebox/build/import/type/composite/composite.mjs
var CompositeKeys = function(T) {
  return T.reduce((Acc, L) => {
    return SetDistinct([...Acc, ...KeyOfPropertyKeys(L)]);
  }, []);
};
var FilterNever = function(T) {
  return T.filter((L) => !IsNever(L));
};
var CompositeProperty = function(T, K) {
  return T.reduce((Acc, L) => {
    return FilterNever([...Acc, ...IndexFromPropertyKeys(L, [K])]);
  }, []);
};
var CompositeProperties = function(T, K) {
  return K.reduce((Acc, L) => {
    return { ...Acc, [L]: IntersectEvaluated(CompositeProperty(T, L)) };
  }, {});
};
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// node_modules/@sinclair/typebox/build/import/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// node_modules/@sinclair/typebox/build/import/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// node_modules/@sinclair/typebox/build/import/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// node_modules/@sinclair/typebox/build/import/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// node_modules/@sinclair/typebox/build/import/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// node_modules/@sinclair/typebox/build/import/type/const/const.mjs
var FromArray14 = function(T) {
  return T.map((L) => FromValue(L, false));
};
var FromProperties8 = function(value5) {
  return globalThis.Object.getOwnPropertyNames(value5).reduce((acc, key) => {
    return { ...acc, [key]: Readonly(FromValue(value5[key], false)) };
  }, {});
};
var ConditionalReadonly = function(T, root) {
  return root === true ? T : Readonly(T);
};
var FromValue = function(value5, root) {
  return IsAsyncIterator2(value5) ? ConditionalReadonly(Any(), root) : IsIterator2(value5) ? ConditionalReadonly(Any(), root) : IsArray2(value5) ? Readonly(Tuple(FromArray14(value5))) : IsUint8Array2(value5) ? Uint8Array2() : IsDate2(value5) ? Date2() : IsObject2(value5) ? ConditionalReadonly(Object2(FromProperties8(value5)), root) : IsFunction2(value5) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value5) ? Undefined() : IsNull2(value5) ? Null() : IsSymbol2(value5) ? Symbol2() : IsBigInt2(value5) ? BigInt2() : IsNumber2(value5) ? Literal(value5) : IsBoolean2(value5) ? Literal(value5) : IsString2(value5) ? Literal(value5) : Object2({});
};
function Const(T, options = {}) {
  return CloneType(FromValue(T, true), options);
}
// node_modules/@sinclair/typebox/build/import/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/import/type/deref/deref.mjs
var FromRest5 = function(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
};
var FromProperties9 = function(properties, references) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((acc, key) => {
    return { ...acc, [key]: Deref2(properties[key], references) };
  }, {});
};
var FromConstructor7 = function(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
};
var FromFunction6 = function(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
};
var FromIntersect15 = function(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
};
var FromUnion17 = function(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
};
var FromTuple14 = function(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
};
var FromArray15 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromObject12 = function(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
};
var FromPromise7 = function(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
};
var FromAsyncIterator6 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromIterator6 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromRef11 = function(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema.$ref}`);
  const discard8 = Discard(target, ["$id"]);
  return Deref2(discard8, references);
};
var DerefResolve = function(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
};
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// node_modules/@sinclair/typebox/build/import/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value7) => Literal(value7));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude.mjs
var ExcludeRest = function(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
};
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-mapped-result.mjs
var FromProperties10 = function(P, U) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Exclude(P[K2], U) };
  }, {});
};
var FromMappedResult7 = function(R, T) {
  return FromProperties10(R.properties, T);
};
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract.mjs
var ExtractRest = function(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
};
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract-from-mapped-result.mjs
var FromProperties11 = function(P, T) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extract(P[K2], T) };
  }, {});
};
var FromMappedResult8 = function(R, T) {
  return FromProperties11(R.properties, T);
};
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/import/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic-from-mapped-key.mjs
var MappedIntrinsicPropertyKey = function(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
};
var MappedIntrinsicPropertyKeys = function(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
};
var MappedIntrinsicProperties = function(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
};
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic.mjs
var ApplyUncapitalize = function(value7) {
  const [first, rest] = [value7.slice(0, 1), value7.slice(1)];
  return [first.toLowerCase(), rest].join("");
};
var ApplyCapitalize = function(value7) {
  const [first, rest] = [value7.slice(0, 1), value7.slice(1)];
  return [first.toUpperCase(), rest].join("");
};
var ApplyUppercase = function(value7) {
  return value7.toUpperCase();
};
var ApplyLowercase = function(value7) {
  return value7.toLowerCase();
};
var FromTemplateLiteral6 = function(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite3 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite3)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value7) => Literal(value7));
  const mapped12 = FromRest6(literals, mode);
  const union15 = Union(mapped12);
  return TemplateLiteral([union15], options);
};
var FromLiteralValue = function(value7, mode) {
  return typeof value7 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value7) : mode === "Capitalize" ? ApplyCapitalize(value7) : mode === "Uppercase" ? ApplyUppercase(value7) : mode === "Lowercase" ? ApplyLowercase(value7) : value7 : value7.toString();
};
var FromRest6 = function(T, M) {
  return T.map((L) => Intrinsic(L, M));
};
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// node_modules/@sinclair/typebox/build/import/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-result.mjs
var FromProperties12 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Omit(P[K2], K, options) };
  }, {});
};
var FromMappedResult9 = function(R, K, options) {
  return FromProperties12(R.properties, K, options);
};
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit.mjs
var FromIntersect16 = function(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
};
var FromUnion18 = function(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
};
var FromProperty2 = function(T, K) {
  const { [K]: _, ...R } = T;
  return R;
};
var FromProperties13 = function(T, K) {
  return K.reduce((T2, K2) => {
    return FromProperty2(T2, K2);
  }, T);
};
var OmitResolve = function(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
};
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-key.mjs
var FromPropertyKey2 = function(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
};
var FromPropertyKeys2 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
};
var FromMappedKey3 = function(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
};
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/import/type/partial/partial.mjs
var FromRest7 = function(T) {
  return T.map((L) => PartialResolve(L));
};
var FromProperties14 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Optional(T[K]) };
  }, {});
};
var PartialResolve = function(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
};
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/partial/partial-from-mapped-result.mjs
var FromProperties15 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Partial(K[K2], options) };
  }, {});
};
var FromMappedResult10 = function(R, options) {
  return FromProperties15(R.properties, options);
};
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-result.mjs
var FromProperties16 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Pick(P[K2], K, options) };
  }, {});
};
var FromMappedResult11 = function(R, K, options) {
  return FromProperties16(R.properties, K, options);
};
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick.mjs
var FromIntersect17 = function(T, K) {
  return T.map((T2) => PickResolve(T2, K));
};
var FromUnion19 = function(T, K) {
  return T.map((T2) => PickResolve(T2, K));
};
var FromProperties17 = function(T, K) {
  return K.reduce((Acc, K2) => {
    return K2 in T ? { ...Acc, [K2]: T[K2] } : Acc;
  }, {});
};
var PickResolve = function(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
};
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-key.mjs
var FromPropertyKey3 = function(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
};
var FromPropertyKeys3 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
};
var FromMappedKey4 = function(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
};
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// node_modules/@sinclair/typebox/build/import/type/record/record.mjs
var RecordCreateFromPattern = function(pattern3, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern3]: CloneType(T) }
  };
};
var RecordCreateFromKeys = function(K, T, options) {
  const P = K.reduce((Acc, K2) => ({ ...Acc, [K2]: CloneType(T) }), {});
  return Object2(P, { ...options, [Hint]: "Record" });
};
var FromTemplateLiteralKey = function(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
};
var FromUnionKey = function(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
};
var FromLiteralKey = function(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
};
var FromRegExpKey = function(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
};
var FromStringKey = function(K, T, options) {
  const pattern3 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern3, T, options);
};
var FromIntegerKey = function(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
};
var FromNumberKey = function(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
};
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : Never(options);
}
// node_modules/@sinclair/typebox/build/import/type/recursive/recursive.mjs
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
var Ordinal = 0;
// node_modules/@sinclair/typebox/build/import/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// node_modules/@sinclair/typebox/build/import/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// node_modules/@sinclair/typebox/build/import/type/required/required.mjs
var FromRest8 = function(T) {
  return T.map((L) => RequiredResolve(L));
};
var FromProperties18 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Discard(T[K], [OptionalKind]) };
  }, {});
};
var RequiredResolve = function(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
};
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// node_modules/@sinclair/typebox/build/import/type/required/required-from-mapped-result.mjs
var FromProperties19 = function(P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Required(P[K2], options) };
  }, {});
};
var FromMappedResult12 = function(R, options) {
  return FromProperties19(R.properties, options);
};
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/rest/rest.mjs
var RestResolve = function(T) {
  return IsIntersect(T) ? [...T.allOf] : IsUnion(T) ? [...T.anyOf] : IsTuple(T) ? [...T.items ?? []] : [];
};
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// node_modules/@sinclair/typebox/build/import/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/import/type/strict/strict.mjs
function Strict(schema2) {
  return JSON.parse(JSON.stringify(schema2));
}
// node_modules/@sinclair/typebox/build/import/type/transform/transform.mjs
function Transform(schema2) {
  return new TransformDecodeBuilder(schema2);
}

class TransformDecodeBuilder {
  schema;
  constructor(schema2) {
    this.schema = schema2;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  schema;
  decode;
  constructor(schema2, decode2) {
    this.schema = schema2;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema2) {
    const Encode2 = (value11) => schema2[TransformKind].Encode(encode2(value11));
    const Decode2 = (value11) => this.decode(schema2[TransformKind].Decode(value11));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema2) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema2 = CloneType(this.schema);
    return IsTransform(schema2) ? this.EncodeTransform(encode2, schema2) : this.EncodeSchema(encode2, schema2);
  }
}
// node_modules/@sinclair/typebox/build/import/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// node_modules/@sinclair/typebox/build/import/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => {
    {
      return Void;
    }
  },
  Uppercase: () => {
    {
      return Uppercase;
    }
  },
  Unsafe: () => {
    {
      return Unsafe;
    }
  },
  Unknown: () => {
    {
      return Unknown;
    }
  },
  Union: () => {
    {
      return Union;
    }
  },
  Undefined: () => {
    {
      return Undefined;
    }
  },
  Uncapitalize: () => {
    {
      return Uncapitalize;
    }
  },
  Uint8Array: () => {
    {
      return Uint8Array2;
    }
  },
  Tuple: () => {
    {
      return Tuple;
    }
  },
  Transform: () => {
    {
      return Transform;
    }
  },
  TemplateLiteral: () => {
    {
      return TemplateLiteral;
    }
  },
  Symbol: () => {
    {
      return Symbol2;
    }
  },
  String: () => {
    {
      return String2;
    }
  },
  Strict: () => {
    {
      return Strict;
    }
  },
  ReturnType: () => {
    {
      return ReturnType;
    }
  },
  Rest: () => {
    {
      return Rest;
    }
  },
  Required: () => {
    {
      return Required;
    }
  },
  RegExp: () => {
    {
      return RegExp2;
    }
  },
  Ref: () => {
    {
      return Ref;
    }
  },
  Recursive: () => {
    {
      return Recursive;
    }
  },
  Record: () => {
    {
      return Record;
    }
  },
  ReadonlyOptional: () => {
    {
      return ReadonlyOptional;
    }
  },
  Readonly: () => {
    {
      return Readonly;
    }
  },
  Promise: () => {
    {
      return Promise2;
    }
  },
  Pick: () => {
    {
      return Pick;
    }
  },
  Partial: () => {
    {
      return Partial;
    }
  },
  Parameters: () => {
    {
      return Parameters;
    }
  },
  Optional: () => {
    {
      return Optional;
    }
  },
  Omit: () => {
    {
      return Omit;
    }
  },
  Object: () => {
    {
      return Object2;
    }
  },
  Number: () => {
    {
      return Number2;
    }
  },
  Null: () => {
    {
      return Null;
    }
  },
  Not: () => {
    {
      return Not2;
    }
  },
  Never: () => {
    {
      return Never;
    }
  },
  Mapped: () => {
    {
      return Mapped;
    }
  },
  Lowercase: () => {
    {
      return Lowercase;
    }
  },
  Literal: () => {
    {
      return Literal;
    }
  },
  KeyOf: () => {
    {
      return KeyOf;
    }
  },
  Iterator: () => {
    {
      return Iterator;
    }
  },
  Intersect: () => {
    {
      return Intersect;
    }
  },
  Integer: () => {
    {
      return Integer;
    }
  },
  InstanceType: () => {
    {
      return InstanceType;
    }
  },
  Index: () => {
    {
      return Index;
    }
  },
  Function: () => {
    {
      return Function2;
    }
  },
  Extract: () => {
    {
      return Extract;
    }
  },
  Extends: () => {
    {
      return Extends;
    }
  },
  Exclude: () => {
    {
      return Exclude;
    }
  },
  Enum: () => {
    {
      return Enum;
    }
  },
  Deref: () => {
    {
      return Deref2;
    }
  },
  Date: () => {
    {
      return Date2;
    }
  },
  ConstructorParameters: () => {
    {
      return ConstructorParameters;
    }
  },
  Constructor: () => {
    {
      return Constructor;
    }
  },
  Const: () => {
    {
      return Const;
    }
  },
  Composite: () => {
    {
      return Composite;
    }
  },
  Capitalize: () => {
    {
      return Capitalize;
    }
  },
  Boolean: () => {
    {
      return Boolean2;
    }
  },
  BigInt: () => {
    {
      return BigInt2;
    }
  },
  Awaited: () => {
    {
      return Awaited;
    }
  },
  AsyncIterator: () => {
    {
      return AsyncIterator;
    }
  },
  Array: () => {
    {
      return Array2;
    }
  },
  Any: () => {
    {
      return Any;
    }
  }
});

// node_modules/@sinclair/typebox/build/import/type/type/index.mjs
var Type = exports_type3;
// node_modules/@sinclair/typebox/build/import/compiler/compiler.mjs
class TypeCheck {
  schema;
  references;
  checkFunc;
  code;
  hasTransform;
  constructor(schema3, references, checkFunc, code) {
    this.schema = schema3;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema3, references);
  }
  Code() {
    return this.code;
  }
  Errors(value11) {
    return Errors(this.schema, this.references, value11);
  }
  Check(value11) {
    return this.checkFunc(value11);
  }
  Decode(value11) {
    if (!this.checkFunc(value11))
      throw new TransformDecodeCheckError(this.schema, value11, this.Errors(value11).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value11) : value11;
  }
  Encode(value11) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value11) : value11;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value11, this.Errors(value11).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value11) {
    if (value11.length === 0)
      return false;
    return Character.IsNumeric(value11.charCodeAt(0));
  }
  function IsAccessor(value11) {
    if (IsFirstCharacterNumeric(value11))
      return false;
    for (let i = 0;i < value11.length; i++) {
      const code = value11.charCodeAt(i);
      const check11 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check11)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object13, key) {
    return IsAccessor(key) ? `${object13}.${key}` : `${object13}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema3) {
    super("Unknown type");
    this.schema = schema3;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  schema;
  constructor(schema3) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema3;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value11, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value11} ? ${expression} : true)` : `(${MemberExpression.Encode(value11, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value11) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value11} === 'object' && ${value11} !== null && !Array.isArray(${value11}))` : `(typeof ${value11} === 'object' && ${value11} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value11) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value11} === 'object' && ${value11} !== null && !Array.isArray(${value11}) && !(${value11} instanceof Date) && !(${value11} instanceof Uint8Array))` : `(typeof ${value11} === 'object' && ${value11} !== null && !(${value11} instanceof Date) && !(${value11} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value11) {
    return !TypeSystemPolicy.AllowNaN ? `(typeof ${value11} === 'number' && Number.isFinite(${value11}))` : `typeof ${value11} === 'number'`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value11) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value11} === undefined || ${value11} === null)` : `${value11} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema3) {
    return schema3[Kind] === "Any" || schema3[Kind] === "Unknown";
  }
  function* FromAny5(schema3, references, value11) {
    yield "true";
  }
  function* FromArray16(schema3, references, value11) {
    yield `Array.isArray(${value11})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema3.maxItems))
      yield `${value11}.length <= ${schema3.maxItems}`;
    if (IsNumber(schema3.minItems))
      yield `${value11}.length >= ${schema3.minItems}`;
    const elementExpression = CreateExpression(schema3.items, references, "value");
    yield `${value11}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema(schema3.contains) || IsNumber(schema3.minContains) || IsNumber(schema3.maxContains)) {
      const containsSchema = IsSchema(schema3.contains) ? schema3.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema3.minContains) ? [`(count >= ${schema3.minContains})`] : [];
      const checkMaxContains = IsNumber(schema3.maxContains) ? [`(count <= ${schema3.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check11 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check11}})(${value11})`;
    }
    if (schema3.uniqueItems === true) {
      const check11 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check11} }`;
      yield `((${parameter}) => { ${block} )(${value11})`;
    }
  }
  function* FromAsyncIterator7(schema3, references, value11) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value11})`;
  }
  function* FromBigInt6(schema3, references, value11) {
    yield `(typeof ${value11} === 'bigint')`;
    if (IsBigInt(schema3.exclusiveMaximum))
      yield `${value11} < BigInt(${schema3.exclusiveMaximum})`;
    if (IsBigInt(schema3.exclusiveMinimum))
      yield `${value11} > BigInt(${schema3.exclusiveMinimum})`;
    if (IsBigInt(schema3.maximum))
      yield `${value11} <= BigInt(${schema3.maximum})`;
    if (IsBigInt(schema3.minimum))
      yield `${value11} >= BigInt(${schema3.minimum})`;
    if (IsBigInt(schema3.multipleOf))
      yield `(${value11} % BigInt(${schema3.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema3, references, value11) {
    yield `(typeof ${value11} === 'boolean')`;
  }
  function* FromConstructor8(schema3, references, value11) {
    yield* Visit17(schema3.returns, references, `${value11}.prototype`);
  }
  function* FromDate6(schema3, references, value11) {
    yield `(${value11} instanceof Date) && Number.isFinite(${value11}.getTime())`;
    if (IsNumber(schema3.exclusiveMaximumTimestamp))
      yield `${value11}.getTime() < ${schema3.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema3.exclusiveMinimumTimestamp))
      yield `${value11}.getTime() > ${schema3.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema3.maximumTimestamp))
      yield `${value11}.getTime() <= ${schema3.maximumTimestamp}`;
    if (IsNumber(schema3.minimumTimestamp))
      yield `${value11}.getTime() >= ${schema3.minimumTimestamp}`;
    if (IsNumber(schema3.multipleOfTimestamp))
      yield `(${value11}.getTime() % ${schema3.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema3, references, value11) {
    yield `(typeof ${value11} === 'function')`;
  }
  function* FromInteger6(schema3, references, value11) {
    yield `(typeof ${value11} === 'number' && Number.isInteger(${value11}))`;
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value11} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value11} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value11} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value11} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value11} % ${schema3.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema3, references, value11) {
    const check1 = schema3.allOf.map((schema4) => CreateExpression(schema4, references, value11)).join(" && ");
    if (schema3.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value11}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema(schema3.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value11}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema3.unevaluatedProperties, references, `${value11}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema3, references, value11) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value11})`;
  }
  function* FromLiteral7(schema3, references, value11) {
    if (typeof schema3.const === "number" || typeof schema3.const === "boolean") {
      yield `(${value11} === ${schema3.const})`;
    } else {
      yield `(${value11} === '${LiteralString.Escape(schema3.const)}')`;
    }
  }
  function* FromNever6(schema3, references, value11) {
    yield `false`;
  }
  function* FromNot8(schema3, references, value11) {
    const expression = CreateExpression(schema3.not, references, value11);
    yield `(!${expression})`;
  }
  function* FromNull6(schema3, references, value11) {
    yield `(${value11} === null)`;
  }
  function* FromNumber6(schema3, references, value11) {
    yield Policy.IsNumberLike(value11);
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value11} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value11} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value11} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value11} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value11} % ${schema3.multipleOf}) === 0`;
  }
  function* FromObject13(schema3, references, value11) {
    yield Policy.IsObjectLike(value11);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value11}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value11}).length <= ${schema3.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema3.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value11, knownKey);
      const property = schema3.properties[knownKey];
      if (schema3.required && schema3.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value11})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value11, knownKey, expression);
      }
    }
    if (schema3.additionalProperties === false) {
      if (schema3.required && schema3.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value11}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value11}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema3.additionalProperties === "object") {
      const expression = CreateExpression(schema3.additionalProperties, references, `${value11}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value11}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema3, references, value11) {
    yield `(typeof value === 'object' && typeof ${value11}.then === 'function')`;
  }
  function* FromRecord12(schema3, references, value11) {
    yield Policy.IsRecordLike(value11);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value11}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value11}).length <= ${schema3.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema(schema3.additionalProperties) ? CreateExpression(schema3.additionalProperties, references, value11) : schema3.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value11}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema3, references, value11) {
    const target = Deref(schema3, references);
    if (state.functions.has(schema3.$ref))
      return yield `${CreateFunctionName(schema3.$ref)}(${value11})`;
    yield* Visit17(target, references, value11);
  }
  function* FromRegExp5(schema3, references, value11) {
    const variable = CreateVariable(`${new RegExp(schema3.source, schema3.flags)};`);
    yield `(typeof ${value11} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value11}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value11}.length >= ${schema3.minLength}`;
    yield `${variable}.test(${value11})`;
  }
  function* FromString6(schema3, references, value11) {
    yield `(typeof ${value11} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value11}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value11}.length >= ${schema3.minLength}`;
    if (schema3.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
      yield `${variable}.test(${value11})`;
    }
    if (schema3.format !== undefined) {
      yield `format('${schema3.format}', ${value11})`;
    }
  }
  function* FromSymbol6(schema3, references, value11) {
    yield `(typeof ${value11} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema3, references, value11) {
    yield `(typeof ${value11} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
    yield `${variable}.test(${value11})`;
  }
  function* FromThis11(schema3, references, value11) {
    yield `${CreateFunctionName(schema3.$ref)}(${value11})`;
  }
  function* FromTuple15(schema3, references, value11) {
    yield `Array.isArray(${value11})`;
    if (schema3.items === undefined)
      return yield `${value11}.length === 0`;
    yield `(${value11}.length === ${schema3.maxItems})`;
    for (let i = 0;i < schema3.items.length; i++) {
      const expression = CreateExpression(schema3.items[i], references, `${value11}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema3, references, value11) {
    yield `${value11} === undefined`;
  }
  function* FromUnion20(schema3, references, value11) {
    const expressions = schema3.anyOf.map((schema4) => CreateExpression(schema4, references, value11));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema3, references, value11) {
    yield `${value11} instanceof Uint8Array`;
    if (IsNumber(schema3.maxByteLength))
      yield `(${value11}.length <= ${schema3.maxByteLength})`;
    if (IsNumber(schema3.minByteLength))
      yield `(${value11}.length >= ${schema3.minByteLength})`;
  }
  function* FromUnknown5(schema3, references, value11) {
    yield "true";
  }
  function* FromVoid5(schema3, references, value11) {
    yield Policy.IsVoidLike(value11);
  }
  function* FromKind4(schema3, references, value11) {
    const instance = state.instances.size;
    state.instances.set(instance, schema3);
    yield `kind('${schema3[Kind]}', ${instance}, ${value11})`;
  }
  function* Visit17(schema3, references, value11, useHoisting = true) {
    const references_ = IsString(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    if (useHoisting && IsString(schema3.$id)) {
      const functionName = CreateFunctionName(schema3.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value11})`;
      } else {
        const functionCode = CreateFunction(functionName, schema3, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value11})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value11);
      case "Array":
        return yield* FromArray16(schema_, references_, value11);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value11);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value11);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value11);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value11);
      case "Date":
        return yield* FromDate6(schema_, references_, value11);
      case "Function":
        return yield* FromFunction7(schema_, references_, value11);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value11);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value11);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value11);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value11);
      case "Never":
        return yield* FromNever6(schema_, references_, value11);
      case "Not":
        return yield* FromNot8(schema_, references_, value11);
      case "Null":
        return yield* FromNull6(schema_, references_, value11);
      case "Number":
        return yield* FromNumber6(schema_, references_, value11);
      case "Object":
        return yield* FromObject13(schema_, references_, value11);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value11);
      case "Record":
        return yield* FromRecord12(schema_, references_, value11);
      case "Ref":
        return yield* FromRef12(schema_, references_, value11);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value11);
      case "String":
        return yield* FromString6(schema_, references_, value11);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value11);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value11);
      case "This":
        return yield* FromThis11(schema_, references_, value11);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value11);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value11);
      case "Union":
        return yield* FromUnion20(schema_, references_, value11);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value11);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value11);
      case "Void":
        return yield* FromVoid5(schema_, references_, value11);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema3);
        return yield* FromKind4(schema_, references_, value11);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema3, references, value11, useHoisting = true) {
    return `(${[...Visit17(schema3, references, value11, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema3, references, value11, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema3, references, value11, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type74) {
    const annotation = state.language === "typescript" ? `: ${type74}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type74) {
    return state.language === "typescript" ? `: ${type74}` : "";
  }
  function Build(schema3, references, options) {
    const functionCode = CreateFunction("check", schema3, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema3.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema3.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema3, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema(schema3))
      throw new TypeCompilerTypeGuardError(schema3);
    for (const schema4 of references)
      if (!IsSchema(schema4))
        throw new TypeCompilerTypeGuardError(schema4);
    return Build(schema3, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema3, references = []) {
    const generatedCode = Code(schema3, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value11) {
      if (!exports_type.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind);
      const schema4 = instances.get(instance);
      return checkFunc(schema4, value11);
    }
    function formatRegistryFunction(format, value11) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value11);
    }
    function hashFunction(value11) {
      return Hash(value11);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema3, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// node_modules/cookie/index.js
var parse4 = function(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options || {};
  var dec = opt.decode || decode2;
  var index = 0;
  while (index < str.length) {
    var eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key = str.slice(index, eqIdx).trim();
    if (obj[key] === undefined) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode(val, dec);
    }
    index = endIdx + 1;
  }
  return obj;
};
var serialize = function(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode2;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  var value11 = enc(val);
  if (value11 && !fieldContentRegExp.test(value11)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name + "=" + value11;
  if (opt.maxAge != null) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.partitioned) {
    str += "; Partitioned";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
var decode2 = function(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
};
var encode2 = function(val) {
  return encodeURIComponent(val);
};
var isDate = function(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
};
var tryDecode = function(str, decode3) {
  try {
    return decode3(str);
  } catch (e) {
    return str;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var $parse = parse4;
var $serialize = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

// node_modules/elysia/dist/index.mjs
var import_fast_decode_uri_component = __toESM(require_fast_decode_uri_component(), 1);
var removeTrailingEquals = function(digest) {
  let trimmedDigest = digest;
  while (trimmedDigest.endsWith("=")) {
    trimmedDigest = trimmedDigest.slice(0, -1);
  }
  return trimmedDigest;
};
var import_fast_querystring = __toESM(require_lib(), 1);
var import_fast_decode_uri_component2 = __toESM(require_fast_decode_uri_component(), 1);
var import_fast_querystring2 = __toESM(require_lib(), 1);
var isLeapYear = function(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
var date5 = function(str) {
  const matches = DATE.exec(str);
  if (!matches)
    return false;
  const year = +matches[1];
  const month = +matches[2];
  const day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
};
var getTime = function(strictTimeZone) {
  return function time(str) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hr = +matches[1];
    const min = +matches[2];
    const sec = +matches[3];
    const tz = matches[4];
    const tzSign = matches[5] === "-" ? -1 : 1;
    const tzH = +(matches[6] || 0);
    const tzM = +(matches[7] || 0);
    if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
      return false;
    if (hr <= 23 && min <= 59 && sec < 60)
      return true;
    const utcMin = min - tzM * tzSign;
    const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
  };
};
var getDateTime = function(strictTimeZone) {
  const time = getTime(strictTimeZone);
  return function date_time(str) {
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date5(dateTime[0]) && time(dateTime[1]);
  };
};
var uri = function(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
};
var byte = function(str) {
  BYTE.lastIndex = 0;
  return BYTE.test(str);
};
var validateInt32 = function(value15) {
  return Number.isInteger(value15) && value15 <= MAX_INT32 && value15 >= MIN_INT32;
};
var validateInt64 = function(value15) {
  return Number.isInteger(value15);
};
var validateNumber = function() {
  return true;
};
var regex = function(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    new RegExp(str);
    return true;
  } catch (e2) {
    return false;
  }
};
var e = (e2, t3) => ({ part: e2, store: null, inert: t3 !== undefined ? new Map(t3.map((e3) => [e3.part.charCodeAt(0), e3])) : null, params: null, wildcardStore: null });
var t = (e2, t3) => ({ ...e2, part: t3 });
var r = (e2) => ({ paramName: e2, store: null, inert: null });
var Memoirist = class _Memoirist {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add(a2, l, i) {
    let s;
    if (typeof l != "string")
      throw TypeError("Route path must be a string");
    l === "" ? l = "/" : l[0] !== "/" && (l = `/${l}`), this.history.push([a2, l, i]);
    let n = l[l.length - 1] === "*";
    n && (l = l.slice(0, -1));
    let o = l.split(_Memoirist.regex.static), u = l.match(_Memoirist.regex.params) || [];
    o[o.length - 1] === "" && o.pop(), s = this.root[a2] ? this.root[a2] : this.root[a2] = e("/");
    let p = 0;
    for (let a3 = 0;a3 < o.length; ++a3) {
      let i2 = o[a3];
      if (a3 > 0) {
        let t3 = u[p++].slice(1);
        if (s.params === null)
          s.params = r(t3);
        else if (s.params.paramName !== t3)
          throw Error(`Cannot create route "${l}" with parameter "${t3}" because a route already exists with a different parameter name ("${s.params.paramName}") in the same location`);
        let a4 = s.params;
        if (a4.inert === null) {
          s = a4.inert = e(i2);
          continue;
        }
        s = a4.inert;
      }
      for (let r2 = 0;; ) {
        if (r2 === i2.length) {
          if (r2 < s.part.length) {
            let a4 = t(s, s.part.slice(r2));
            Object.assign(s, e(i2, [a4]));
          }
          break;
        }
        if (r2 === s.part.length) {
          if (s.inert === null)
            s.inert = new Map;
          else if (s.inert.has(i2.charCodeAt(r2))) {
            s = s.inert.get(i2.charCodeAt(r2)), i2 = i2.slice(r2), r2 = 0;
            continue;
          }
          let t3 = e(i2.slice(r2));
          s.inert.set(i2.charCodeAt(r2), t3), s = t3;
          break;
        }
        if (i2[r2] !== s.part[r2]) {
          let a4 = t(s, s.part.slice(r2)), l2 = e(i2.slice(r2));
          Object.assign(s, e(s.part.slice(0, r2), [a4, l2])), s = l2;
          break;
        }
        ++r2;
      }
    }
    if (p < u.length) {
      let e2 = u[p], t3 = e2.slice(1);
      if (s.params === null)
        s.params = r(t3);
      else if (s.params.paramName !== t3)
        throw Error(`Cannot create route "${l}" with parameter "${t3}" because a route already exists with a different parameter name ("${s.params.paramName}") in the same location`);
      return s.params.store === null && (s.params.store = i), s.params.store;
    }
    return n ? (s.wildcardStore === null && (s.wildcardStore = i), s.wildcardStore) : (s.store === null && (s.store = i), s.store);
  }
  find(e2, t3) {
    let r2 = this.root[e2];
    return r2 ? a(t3, t3.length, r2, 0) : null;
  }
};
var a = (e2, t3, r2, l) => {
  let i = r2?.part, s = l + i.length;
  if (i.length > 1) {
    if (s > t3)
      return null;
    if (i.length < 15) {
      for (let t4 = 1, r3 = l + 1;t4 < i.length; ++t4, ++r3)
        if (i.charCodeAt(t4) !== e2.charCodeAt(r3))
          return null;
    } else if (e2.substring(l, s) !== i)
      return null;
  }
  if (s === t3)
    return r2.store !== null ? { store: r2.store, params: {} } : r2.wildcardStore !== null ? { store: r2.wildcardStore, params: { "*": "" } } : null;
  if (r2.inert !== null) {
    let l2 = r2.inert.get(e2.charCodeAt(s));
    if (l2 !== undefined) {
      let r3 = a(e2, t3, l2, s);
      if (r3 !== null)
        return r3;
    }
  }
  if (r2.params !== null) {
    let l2 = r2.params, i2 = e2.indexOf("/", s);
    if (i2 !== s) {
      if (i2 === -1 || i2 >= t3) {
        if (l2.store !== null) {
          let r3 = {};
          return r3[l2.paramName] = e2.substring(s, t3), { store: l2.store, params: r3 };
        }
      } else if (l2.inert !== null) {
        let r3 = a(e2, t3, l2.inert, i2);
        if (r3 !== null)
          return r3.params[l2.paramName] = e2.substring(s, i2), r3;
      }
    }
  }
  return r2.wildcardStore !== null ? { store: r2.wildcardStore, params: { "*": e2.substring(s, t3) } } : null;
};
var resolver = () => {
  let resolve;
  const promise5 = new Promise((r2) => {
    resolve = r2;
  });
  return [promise5, resolve];
};
var createSignal = () => {
  const [start, resolveStart] = resolver();
  const [end, resolveEnd] = resolver();
  const children = [];
  const resolvers = [];
  return {
    signal: start,
    consume: (trace) => {
      switch (trace.type) {
        case "begin":
          if (trace.unit && children.length === 0)
            for (let i = 0;i < trace.unit; i++) {
              const [start2, resolveStart2] = resolver();
              const [end2, resolveEnd2] = resolver();
              children.push(start2);
              resolvers.push([
                (trace2) => {
                  resolveStart2({
                    children: [],
                    end: end2,
                    name: trace2.name ?? "",
                    skip: false,
                    time: trace2.time
                  });
                },
                (time) => {
                  resolveEnd2(time);
                }
              ]);
            }
          resolveStart({
            children,
            end,
            name: trace.name ?? "",
            skip: false,
            time: trace.time
          });
          break;
        case "end":
          resolveEnd(trace.time);
          break;
      }
    },
    consumeChild(trace) {
      switch (trace.type) {
        case "begin":
          if (!resolvers[0])
            return;
          const [resolveStart2] = resolvers[0];
          resolveStart2({
            children: [],
            end,
            name: trace.name ?? "",
            skip: false,
            time: trace.time
          });
          break;
        case "end":
          const child = resolvers.shift();
          if (!child)
            return;
          child[1](trace.time);
      }
    },
    resolve() {
      resolveStart({
        children: [],
        end: new Promise((resolve) => resolve(0)),
        name: "",
        skip: true,
        time: 0
      });
      for (const [resolveStart2, resolveEnd2] of resolvers) {
        resolveStart2({
          children: [],
          end: new Promise((resolve) => resolve(0)),
          name: "",
          skip: true,
          time: 0
        });
        resolveEnd2(0);
      }
      resolveEnd(0);
    }
  };
};
var createTraceListener = (getReporter, totalListener, handler) => {
  if (typeof handler === "object")
    handler = handler.fn;
  return async function trace(trace) {
    if (trace.event !== "request" || trace.type !== "begin")
      return;
    const id = trace.id;
    const reporter = getReporter();
    const request = createSignal();
    const parse22 = createSignal();
    const transform7 = createSignal();
    const beforeHandle = createSignal();
    const handle = createSignal();
    const afterHandle = createSignal();
    const error22 = createSignal();
    const response = createSignal();
    request.consume(trace);
    const reducer = (event) => {
      if (event.id === id)
        switch (event.event) {
          case "request":
            request.consume(event);
            break;
          case "request.unit":
            request.consumeChild(event);
            break;
          case "parse":
            parse22.consume(event);
            break;
          case "parse.unit":
            parse22.consumeChild(event);
            break;
          case "transform":
            transform7.consume(event);
            break;
          case "transform.unit":
            transform7.consumeChild(event);
            break;
          case "beforeHandle":
            beforeHandle.consume(event);
            break;
          case "beforeHandle.unit":
            beforeHandle.consumeChild(event);
            break;
          case "handle":
            handle.consume(event);
            break;
          case "afterHandle":
            afterHandle.consume(event);
            break;
          case "afterHandle.unit":
            afterHandle.consumeChild(event);
            break;
          case "error":
            error22.consume(event);
            break;
          case "error.unit":
            error22.consumeChild(event);
            break;
          case "response":
            if (event.type === "begin") {
              request.resolve();
              parse22.resolve();
              transform7.resolve();
              beforeHandle.resolve();
              handle.resolve();
              afterHandle.resolve();
              error22.resolve();
            } else
              reporter.off("event", reducer);
            response.consume(event);
            break;
          case "response.unit":
            response.consumeChild(event);
            break;
          case "exit":
            request.resolve();
            parse22.resolve();
            transform7.resolve();
            beforeHandle.resolve();
            handle.resolve();
            afterHandle.resolve();
            error22.resolve();
            break;
        }
    };
    reporter.on("event", reducer);
    await handler({
      id,
      context: trace.ctx,
      set: trace.ctx?.set,
      store: trace.ctx?.store,
      time: trace.time,
      request: request.signal,
      parse: parse22.signal,
      transform: transform7.signal,
      beforeHandle: beforeHandle.signal,
      handle: handle.signal,
      afterHandle: afterHandle.signal,
      error: error22.signal,
      response: response.signal
    });
    reporter.emit(`res${id}.${totalListener}`, undefined);
  };
};
var separateFunction = (code) => {
  if (code.startsWith("async"))
    code = code.slice(6);
  let index = -1;
  if (code.charCodeAt(0) === 40) {
    index = code.indexOf(") => {\n");
    if (index !== -1)
      return [code.slice(1, index), code.slice(index + 5)];
    index = code.indexOf(") => ");
    if (index !== -1)
      return [code.slice(1, index), code.slice(index + 5)];
  }
  if (code.startsWith("function")) {
    index = code.indexOf("(");
    const end = code.indexOf(")");
    return [code.slice(index + 1, end), code.slice(end + 2)];
  }
  const start = code.indexOf("(");
  if (start !== -1) {
    const [parameter, body] = code.split("\n", 2);
    const end = parameter.lastIndexOf(")") + 1;
    return [parameter.slice(start, end), "{" + body];
  }
  return code.split("\n", 2);
};
var bracketPairRange = (parameter) => {
  const start = parameter.indexOf("{");
  if (start === -1)
    return [-1, 0];
  let end = start + 1;
  let deep = 1;
  for (;end < parameter.length; end++) {
    const char = parameter.charCodeAt(end);
    if (char === 123)
      deep++;
    else if (char === 125)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [0, parameter.length];
  return [start, end + 1];
};
var bracketPairRangeReverse = (parameter) => {
  const end = parameter.lastIndexOf("}");
  if (end === -1)
    return [-1, 0];
  let start = end - 1;
  let deep = 1;
  for (;start >= 0; start--) {
    const char = parameter.charCodeAt(start);
    if (char === 125)
      deep++;
    else if (char === 123)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [-1, 0];
  return [start, end + 1];
};
var retrieveRootParamters = (parameter) => {
  if (parameter.charCodeAt(0) === 40)
    parameter = parameter.slice(1, -1);
  if (parameter.charCodeAt(0) === 123)
    parameter = parameter.slice(2, -2);
  while (true) {
    const [start, end] = bracketPairRange(parameter);
    if (start === -1)
      break;
    parameter = parameter.slice(0, start - 2) + parameter.slice(end + 1);
  }
  return parameter.replace(/:/g, "").trim();
};
var findParameterReference = (parameter, inference) => {
  const root = retrieveRootParamters(parameter);
  if (!inference.query && root.includes("query"))
    inference.query = true;
  if (!inference.headers && root.includes("headers"))
    inference.headers = true;
  if (!inference.body && root.includes("body"))
    inference.body = true;
  if (!inference.cookie && root.includes("cookie"))
    inference.cookie = true;
  if (!inference.set && root.includes("set"))
    inference.set = true;
  return root;
};
var findTraceParameterReference = (parameter, inference) => {
  const root = retrieveRootParamters(parameter);
  if (!inference.request && root.includes("request"))
    inference.request = true;
  if (!inference.parse && root.includes("parse"))
    inference.parse = true;
  if (!inference.transform && root.includes("transform"))
    inference.transform = true;
  if (!inference.handle && root.includes("handle"))
    inference.handle = true;
  if (!inference.beforeHandle && root.includes("beforeHandle"))
    inference.beforeHandle = true;
  if (!inference.afterHandle && root.includes("afterHandle"))
    inference.afterHandle = true;
  if (!inference.error && root.includes("error"))
    inference.error = true;
  if (!inference.context && root.includes("context"))
    inference.context = true;
  if (!inference.store && root.includes("store"))
    inference.store = true;
  if (!inference.set && root.includes("set"))
    inference.set = true;
  return root;
};
var findEndIndex = (type74, content, index) => {
  const newLineIndex = content.indexOf(type74 + "\n", index);
  const newTabIndex = content.indexOf(type74 + "	", index);
  const commaIndex = content.indexOf(type74 + ",", index);
  const semicolonIndex = content.indexOf(type74 + ";", index);
  const emptyIndex = content.indexOf(type74 + " ", index);
  return [newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex].filter((i) => i > 0).sort((a2, b) => a2 - b)[0] || -1;
};
var findEndQueryBracketIndex = (type74, content, index) => {
  const bracketEndIndex = content.indexOf(type74 + "]", index);
  const singleQuoteIndex = content.indexOf(type74 + "'", index);
  const doubleQuoteIndex = content.indexOf(type74 + '"', index);
  return [bracketEndIndex, singleQuoteIndex, doubleQuoteIndex].filter((i) => i > 0).sort((a2, b) => a2 - b)[0] || -1;
};
var findAlias = (type74, body, depth = 0) => {
  if (depth > 5)
    return [];
  const aliases = [];
  let content = body;
  while (true) {
    let index = findEndIndex(" = " + type74, content);
    if (index === -1) {
      const lastIndex = content.indexOf(" = " + type74);
      if (lastIndex + 3 + type74.length !== content.length)
        break;
      index = lastIndex;
    }
    const part = content.slice(0, index);
    let variable = part.slice(part.lastIndexOf(" ") + 1);
    if (variable === "}") {
      const [start, end] = bracketPairRangeReverse(part);
      aliases.push(content.slice(start, end));
      content = content.slice(index + 3 + type74.length);
      continue;
    }
    while (variable.charCodeAt(0) === 44)
      variable = variable.slice(1);
    while (variable.charCodeAt(0) === 9)
      variable = variable.slice(1);
    aliases.push(variable);
    content = content.slice(index + 3 + type74.length);
  }
  for (const alias of aliases) {
    if (alias.charCodeAt(0) === 123)
      continue;
    const deepAlias = findAlias(alias, body);
    if (deepAlias.length > 0)
      aliases.push(...deepAlias);
  }
  return aliases;
};
var accessor = (parent, prop) => [
  parent + "." + prop,
  parent + '["' + prop + '"]',
  parent + "['" + prop + "']"
];
var extractMainParameter = (parameter) => {
  if (!parameter)
    return;
  const hasComma = parameter.includes(",");
  if (!hasComma) {
    if (parameter.includes("..."))
      return parameter.slice(parameter.indexOf("...") + 3);
    return parameter;
  }
  const spreadIndex = parameter.indexOf("...");
  if (spreadIndex === -1)
    return;
  return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference = (code, aliases, inference) => {
  const access = (type74, alias) => code.includes(alias + "." + type74) || code.includes(alias + '["' + type74 + '"]') || code.includes(alias + "['" + type74 + "']");
  for (let alias of aliases) {
    if (!alias)
      continue;
    if (alias.charCodeAt(0) === 123) {
      alias = retrieveRootParamters(alias);
      if (!inference.query && alias.includes("query"))
        inference.query = true;
      if (!inference.headers && alias.includes("headers"))
        inference.headers = true;
      if (!inference.body && alias.includes("body"))
        inference.body = true;
      if (!inference.cookie && alias.includes("cookie"))
        inference.cookie = true;
      if (!inference.set && alias.includes("set"))
        inference.set = true;
      continue;
    }
    if (code.includes("(" + alias + ")")) {
      inference.query = true;
      inference.headers = true;
      inference.body = true;
      inference.cookie = true;
      inference.set = true;
      inference.queries = [];
      inference.unknownQueries = true;
      break;
    }
    if (!inference.query && access("query", alias))
      inference.query = true;
    if (code.includes("return " + alias) || accessor("return " + alias, "query").some((key) => code.includes(key))) {
      inference.query = true;
      inference.unknownQueries = true;
    }
    if (inference.query && !inference.unknownQueries)
      while (true) {
        let keyword = alias + ".";
        if (code.includes(keyword + "query"))
          keyword = alias + ".query";
        let isBracket = false;
        let start = code.indexOf(keyword);
        if (start === -1) {
          isBracket = true;
          start = code.indexOf(alias + '["');
        }
        if (start === -1) {
          isBracket = true;
          start = code.indexOf(alias + "['");
        }
        if (start === -1 && code.indexOf(alias + "[") !== -1) {
          inference.queries = [];
          inference.unknownQueries = true;
          break;
        }
        if (start !== -1) {
          let end = isBracket ? findEndQueryBracketIndex("", code, start + keyword.length + 1) : findEndIndex("", code, start + keyword.length + 1);
          if (end === -1)
            end = undefined;
          const index = start + alias.length + 1;
          code = code.slice(start + alias.length + 1);
          let query = code.slice(0, end ? end - index : end).trimEnd();
          while (start !== -1) {
            start = query.indexOf(".");
            if (start !== -1)
              query = query.slice(start + 1);
          }
          if (query.charCodeAt(query.length - 1) === 59)
            query = query.slice(0, -1);
          if (query.charCodeAt(query.length - 1) === 44)
            query = query.slice(0, -1);
          if (query.charCodeAt(query.length - 1) === 93)
            query = query.slice(0, -1);
          if (query.charCodeAt(query.length - 1) === 41)
            query = query.slice(0, -1);
          if (isBracket)
            query = query.replaceAll(/("|')/g, "");
          if (query && !inference.queries.includes(query)) {
            inference.queries.push(query);
            continue;
          }
        }
        break;
      }
    if (!inference.headers && access("headers", alias))
      inference.headers = true;
    if (!inference.body && access("body", alias))
      inference.body = true;
    if (!inference.cookie && access("cookie", alias))
      inference.cookie = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set)
      break;
  }
  return aliases;
};
var removeDefaultParameter = (parameter) => {
  while (true) {
    const index = parameter.indexOf("=");
    if (index === -1)
      break;
    const commaIndex = parameter.indexOf(",", index);
    const bracketIndex = parameter.indexOf("}", index);
    const end = [commaIndex, bracketIndex].filter((i) => i > 0).sort((a2, b) => a2 - b)[0] || -1;
    if (end === -1) {
      parameter = parameter.slice(0, index);
      break;
    }
    parameter = parameter.slice(0, index) + parameter.slice(end);
  }
  return parameter.split(",").map((i) => i.trim()).join(", ");
};
var validateInferencedQueries = (queries) => {
  for (const query of queries) {
    if (query.charCodeAt(0) === 123)
      return false;
    if (query.indexOf("'") !== -1)
      return false;
    if (query.indexOf('"') !== -1)
      return false;
    if (query.indexOf("\n") !== -1)
      return false;
    if (query.indexOf("	") !== -1)
      return false;
  }
  return true;
};
var inferTraceBodyReference = (code, aliases, inference) => {
  const access = (type74, alias) => code.includes(type74 + "." + alias) || code.includes(type74 + '["' + alias + '"]') || code.includes(type74 + "['" + alias + "']");
  for (let alias of aliases) {
    if (alias.charCodeAt(0) === 123) {
      alias = retrieveRootParamters(alias);
      if (!inference.request && alias.includes("request"))
        inference.request = true;
      if (!inference.parse && alias.includes("parse"))
        inference.parse = true;
      if (!inference.transform && alias.includes("transform"))
        inference.transform = true;
      if (!inference.handle && alias.includes("handle"))
        inference.handle = true;
      if (!inference.beforeHandle && alias.includes("beforeHandle"))
        inference.beforeHandle = true;
      if (!inference.afterHandle && alias.includes("afterHandle"))
        inference.afterHandle = true;
      if (!inference.error && alias.includes("error"))
        inference.error = true;
      if (!inference.context && alias.includes("context"))
        inference.context = true;
      if (!inference.store && alias.includes("store"))
        inference.store = true;
      if (!inference.set && alias.includes("set"))
        inference.set = true;
      continue;
    }
    if (code.includes("(" + alias + ")")) {
      inference.request = true;
      inference.parse = true;
      inference.transform = true;
      inference.handle = true;
      inference.beforeHandle = true;
      inference.afterHandle = true;
      inference.error = true;
      inference.context = true;
      inference.store = true;
      inference.set = true;
      break;
    }
    if (!inference.request && access("request", alias))
      inference.request = true;
    if (!inference.parse && access("parse", alias))
      inference.parse = true;
    if (!inference.transform && access("transform", alias))
      inference.transform = true;
    if (!inference.handle && access("handle", alias))
      inference.handle = true;
    if (!inference.beforeHandle && access("beforeHandle", alias))
      inference.beforeHandle = true;
    if (!inference.afterHandle && access("afterHandle", alias))
      inference.afterHandle = true;
    if (!inference.error && access("error", alias))
      inference.error = true;
    if (!inference.context && access("context", alias))
      inference.context = true;
    if (!inference.store && access("store", alias))
      inference.store = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (inference.request && inference.parse && inference.transform && inference.handle && inference.beforeHandle && inference.afterHandle && inference.error && inference.context && inference.store && inference.set)
      break;
  }
  return aliases;
};
var sucrose = (lifeCycle, inference = {
  queries: [],
  query: false,
  headers: false,
  body: false,
  cookie: false,
  set: false,
  unknownQueries: false
}) => {
  const events = [];
  if (lifeCycle.handler && typeof lifeCycle.handler === "function")
    events.push(lifeCycle.handler);
  if (lifeCycle.beforeHandle?.length)
    events.push(...lifeCycle.beforeHandle);
  if (lifeCycle.parse?.length)
    events.push(...lifeCycle.parse);
  if (lifeCycle.error?.length)
    events.push(...lifeCycle.error);
  if (lifeCycle.transform?.length)
    events.push(...lifeCycle.transform);
  if (lifeCycle.afterHandle?.length)
    events.push(...lifeCycle.afterHandle);
  if (lifeCycle.mapResponse?.length)
    events.push(...lifeCycle.mapResponse);
  if (lifeCycle.request?.length)
    events.push(...lifeCycle.request);
  if (lifeCycle.onResponse?.length)
    events.push(...lifeCycle.onResponse);
  for (const e2 of events) {
    if (!e2)
      continue;
    const event = "fn" in e2 ? e2.fn : e2;
    const [parameter, body] = separateFunction(event.toString());
    const rootParameters = findParameterReference(parameter, inference);
    const mainParameter = extractMainParameter(rootParameters);
    if (mainParameter) {
      const aliases = findAlias(mainParameter, body);
      aliases.splice(0, -1, mainParameter);
      inferBodyReference(body, aliases, inference);
    }
    const context = rootParameters || mainParameter;
    if (context && ["", "return "].some((type74) => accessor(type74 + context, "query").some((key) => body.includes(key)))) {
      inference.query = true;
      inference.unknownQueries = true;
    }
    if (inference.query) {
      inferBodyReference(body, ["query"], inference);
      const queryIndex = parameter.indexOf("query: {");
      if (queryIndex !== -1) {
        const part = parameter.slice(queryIndex + 7);
        const [start, end] = bracketPairRange(part);
        const queryBracket = removeDefaultParameter(part.slice(start, end));
        for (let query of queryBracket.slice(1, -1).split(",")) {
          const index = query.indexOf(":");
          if (index !== -1)
            query = query.slice(0, index);
          query = query.trim();
          if (query && !inference.queries.includes(query))
            inference.queries.push(query.trim());
        }
      }
    }
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set)
      break;
  }
  if (!validateInferencedQueries(inference.queries)) {
    inference.unknownQueries = true;
    inference.queries = [];
  }
  return inference;
};
var sucroseTrace = (traces, inference = {
  request: false,
  parse: false,
  transform: false,
  handle: false,
  beforeHandle: false,
  afterHandle: false,
  error: false,
  context: false,
  store: false,
  set: false
}) => {
  for (const handler of traces) {
    const [parameter, body] = separateFunction(handler.toString());
    const rootParameters = findTraceParameterReference(parameter, inference);
    const mainParameter = extractMainParameter(rootParameters);
    if (mainParameter) {
      const aliases = findAlias(mainParameter, body);
      aliases.splice(0, -1, mainParameter);
      inferTraceBodyReference(body, aliases, inference);
      continue;
    }
    if (inference.request && inference.parse && inference.transform && inference.handle && inference.beforeHandle && inference.afterHandle && inference.error && inference.context && inference.store && inference.set)
      break;
  }
  return inference;
};
var Cookie = class {
  constructor(name, jar, initial = {}) {
    this.name = name;
    this.jar = jar;
    this.initial = initial;
  }
  get cookie() {
    if (!(this.name in this.jar))
      return this.initial;
    return this.jar[this.name];
  }
  set cookie(jar) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = jar;
  }
  get value() {
    return this.cookie.value;
  }
  set value(value15) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name].value = value15;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires(expires) {
    this.cookie.expires = expires;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge(maxAge) {
    this.cookie.maxAge = maxAge;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain(domain) {
    this.cookie.domain = domain;
  }
  get path() {
    return this.cookie.path;
  }
  set path(path) {
    this.cookie.path = path;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure(secure) {
    this.cookie.secure = secure;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly(httpOnly) {
    this.cookie.httpOnly = httpOnly;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite(sameSite) {
    this.cookie.sameSite = sameSite;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority(priority) {
    this.cookie.priority = priority;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets(secrets) {
    this.cookie.secrets = secrets;
  }
  update(config2) {
    this.cookie = Object.assign(this.cookie, typeof config2 === "function" ? config2(this.cookie) : config2);
    return this;
  }
  set(config2) {
    this.cookie = Object.assign({
      ...this.initial,
      value: this.value
    }, typeof config2 === "function" ? config2(this.cookie) : config2);
    return this;
  }
  remove() {
    if (this.value === undefined)
      return;
    this.set({
      expires: new Date(0),
      maxAge: 0,
      value: ""
    });
    return this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
};
var createCookieJar = (set2, store, initial) => {
  if (!set2.cookie)
    set2.cookie = {};
  return new Proxy(store, {
    get(_, key) {
      if (key in store)
        return new Cookie(key, set2.cookie, Object.assign({}, initial ?? {}, store[key]));
      return new Cookie(key, set2.cookie, Object.assign({}, initial));
    }
  });
};
var parseCookie = async (set2, cookieString, {
  secrets,
  sign,
  ...initial
} = {}) => {
  if (!cookieString)
    return createCookieJar(set2, {}, initial);
  const isStringKey = typeof secrets === "string";
  if (sign && sign !== true && !Array.isArray(sign))
    sign = [sign];
  const jar = {};
  const cookies = $parse(cookieString);
  for (const [name, v] of Object.entries(cookies)) {
    let value15 = import_fast_decode_uri_component.default(v);
    if (sign === true || sign?.includes(name)) {
      if (!secrets)
        throw new Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        const temp = await unsignCookie(value15, secrets);
        if (temp === false)
          throw new InvalidCookieSignature(name);
        value15 = temp;
      } else {
        let decoded = true;
        for (let i = 0;i < secrets.length; i++) {
          const temp = await unsignCookie(value15, secrets[i]);
          if (temp !== false) {
            decoded = true;
            value15 = temp;
            break;
          }
        }
        if (!decoded)
          throw new InvalidCookieSignature(name);
      }
    }
    const start = value15.charCodeAt(0);
    if (start === 123 || start === 91)
      try {
        jar[name] = {
          value: JSON.parse(value15)
        };
        continue;
      } catch {
      }
    if (isNumericString(value15)) {
      jar[name] = {
        value: parseInt(value15)
      };
      continue;
    }
    if (value15 === "true") {
      jar[name] = {
        value: true
      };
      continue;
    }
    if (value15 === "false") {
      jar[name] = {
        value: false
      };
      continue;
    }
    jar[name] = {
      value: value15
    };
  }
  return createCookieJar(set2, jar, initial);
};
var hasHeaderShorthand = "toJSON" in new Headers;
var isNotEmpty = (obj) => {
  if (!obj)
    return false;
  for (const x in obj)
    return true;
  return false;
};
var handleFile = (response, set2) => {
  const size = response.size;
  if (!set2 && size || size && set2 && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416) {
    if (set2) {
      if (set2.headers instanceof Headers) {
        if (hasHeaderShorthand)
          set2.headers = set2.headers.toJSON();
        else
          for (const [key, value15] of set2.headers.entries())
            if (key in set2.headers)
              set2.headers[key] = value15;
      }
      return new Response(response, {
        status: set2.status,
        headers: Object.assign({
          "accept-ranges": "bytes",
          "content-range": `bytes 0-${size - 1}/${size}`
        }, set2.headers)
      });
    }
    return new Response(response, {
      headers: {
        "accept-ranges": "bytes",
        "content-range": `bytes 0-${size - 1}/${size}`
      }
    });
  }
  return new Response(response);
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers)
    return headers;
  headers.delete("Set-Cookie");
  for (let i = 0;i < setCookie.length; i++) {
    const index = setCookie[i].indexOf("=");
    headers.append("Set-Cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`);
  }
  return headers;
};
var serializeCookie = (cookies) => {
  if (!cookies || !isNotEmpty(cookies))
    return;
  const set2 = [];
  for (const [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    const value15 = property.value;
    if (value15 === undefined || value15 === null)
      continue;
    set2.push($serialize(key, typeof value15 === "object" ? JSON.stringify(value15) : value15 + "", property));
  }
  if (set2.length === 0)
    return;
  if (set2.length === 1)
    return set2[0];
  return set2;
};
var mapResponse = (response, set2, request) => {
  if (response?.$passthrough)
    response = response?.[response.$passthrough];
  if (response?.[ELYSIA_RESPONSE]) {
    set2.status = response[ELYSIA_RESPONSE];
    response = response.response;
  }
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.redirect || set2.cookie) {
    if (typeof set2.status === "string")
      set2.status = StatusMap[set2.status];
    if (set2.redirect) {
      set2.headers.Location = set2.redirect;
      if (!set2.status || set2.status < 300 || set2.status >= 400)
        set2.status = 302;
    }
    if (set2.cookie && isNotEmpty(set2.cookie))
      set2.headers["Set-Cookie"] = serializeCookie(set2.cookie);
    if (set2.headers["Set-Cookie"] && Array.isArray(set2.headers["Set-Cookie"]))
      set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["Set-Cookie"]);
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return Response.json(response, set2);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        request?.signal.addEventListener("abort", {
          handleEvent() {
            if (!request?.signal.aborted)
              response.cancel(request);
          }
        }, {
          once: true
        });
        return new Response(response, set2);
      case undefined:
        if (!response)
          return new Response("", set2);
        return Response.json(response, set2);
      case "Response":
        const inherits = { ...set2.headers };
        if (hasHeaderShorthand)
          set2.headers = response.headers.toJSON();
        else
          for (const [key, value15] of response.headers.entries())
            if (key in set2.headers)
              set2.headers[key] = value15;
        for (const key in inherits)
          response.headers.append(key, inherits[key]);
        return response;
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x) => mapResponse(x, set2));
      case "Function":
        return mapResponse(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response) {
          const inherits2 = Object.assign({}, set2.headers);
          if (hasHeaderShorthand)
            set2.headers = response.headers.toJSON();
          else
            for (const [key, value15] of response.headers.entries())
              if (key in set2.headers)
                set2.headers[key] = value15;
          for (const key in inherits2)
            response.headers.append(key, inherits2[key]);
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "ReadableStream":
        request?.signal.addEventListener("abort", {
          handleEvent() {
            if (!request?.signal.aborted)
              response.cancel(request);
          }
        }, {
          once: true
        });
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x) => {
          const r2 = mapCompactResponse(x);
          if (r2 !== undefined)
            return r2;
          return new Response("");
        });
      case "Function":
        return mapCompactResponse(response());
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return new Response(response.body, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapEarlyResponse = (response, set2, request) => {
  if (response === undefined || response === null)
    return;
  if (response?.$passthrough)
    response = response?.[response.$passthrough];
  if (response?.[ELYSIA_RESPONSE]) {
    set2.status = response[ELYSIA_RESPONSE];
    response = response.response;
  }
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.redirect || set2.cookie) {
    if (typeof set2.status === "string")
      set2.status = StatusMap[set2.status];
    if (set2.redirect) {
      set2.headers.Location = set2.redirect;
      if (!set2.status || set2.status < 300 || set2.status >= 400)
        set2.status = 302;
    }
    if (set2.cookie && isNotEmpty(set2.cookie))
      set2.headers["Set-Cookie"] = serializeCookie(set2.cookie);
    if (set2.headers["Set-Cookie"] && Array.isArray(set2.headers["Set-Cookie"]))
      set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["Set-Cookie"]);
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return Response.json(response, set2);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        request?.signal.addEventListener("abort", {
          handleEvent() {
            if (!request?.signal.aborted)
              response.cancel(request);
          }
        }, {
          once: true
        });
        return new Response(response, set2);
      case undefined:
        if (!response)
          return;
        return Response.json(response, set2);
      case "Response":
        const inherits = Object.assign({}, set2.headers);
        if (hasHeaderShorthand)
          set2.headers = response.headers.toJSON();
        else
          for (const [key, value15] of response.headers.entries())
            if (!(key in set2.headers))
              set2.headers[key] = value15;
        for (const key in inherits)
          response.headers.append(key, inherits[key]);
        if (response.status !== set2.status)
          set2.status = response.status;
        return response;
      case "Promise":
        return response.then((x) => {
          const r2 = mapEarlyResponse(x, set2);
          if (r2 !== undefined)
            return r2;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapEarlyResponse(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response) {
          const inherits2 = { ...set2.headers };
          if (hasHeaderShorthand)
            set2.headers = response.headers.toJSON();
          else
            for (const [key, value15] of response.headers.entries())
              if (key in set2.headers)
                set2.headers[key] = value15;
          for (const key in inherits2)
            response.headers.append(key, inherits2[key]);
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "ReadableStream":
        request?.signal.addEventListener("abort", {
          handleEvent() {
            if (!request?.signal.aborted)
              response.cancel(request);
          }
        }, {
          once: true
        });
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Promise":
        return response.then((x) => {
          const r2 = mapEarlyResponse(x, set2);
          if (r2 !== undefined)
            return r2;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapCompactResponse(response());
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return new Response(response.body, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse = (response, request) => {
  if (response?.$passthrough)
    response = response?.[response.$passthrough];
  if (response?.[ELYSIA_RESPONSE])
    return mapResponse(response.response, {
      status: response[ELYSIA_RESPONSE],
      headers: {}
    });
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Blob":
      return handleFile(response);
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      });
    case "ReadableStream":
      request?.signal.addEventListener("abort", {
        handleEvent() {
          if (!request?.signal.aborted)
            response.cancel(request);
        }
      }, {
        once: true
      });
      return new Response(response, {
        headers: {
          "Content-Type": "text/event-stream; charset=utf-8"
        }
      });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      });
    case "Response":
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then(mapCompactResponse);
    case "Function":
      return mapCompactResponse(response());
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    default:
      if (response instanceof Response)
        return new Response(response.body, {
          headers: {
            "Content-Type": "application/json"
          }
        });
      if (response instanceof Promise)
        return response.then(mapCompactResponse);
      if (response instanceof Error)
        return errorToResponse(response);
      if ("charCodeAt" in response) {
        const code = response.charCodeAt(0);
        if (code === 123 || code === 91) {
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
        }
      }
      return new Response(response);
  }
};
var errorToResponse = (error22, set2) => new Response(JSON.stringify({
  name: error22?.name,
  message: error22?.message,
  cause: error22?.cause
}), {
  status: set2?.status !== 200 ? set2?.status ?? 500 : 500,
  headers: set2?.headers
});
var replaceUrlPath = (url, pathname) => {
  const urlObject = new URL(url);
  urlObject.pathname = pathname;
  return urlObject.toString();
};
var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString().startsWith("[object ") || isNotEmpty(Object.getPrototypeOf(v));
var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
var mergeDeep = (target, source, {
  skipKeys
} = {}) => {
  if (isObject(target) && isObject(source))
    for (const [key, value15] of Object.entries(source)) {
      if (skipKeys?.includes(key))
        continue;
      if (!isObject(value15) || !(key in target) || isClass(value15)) {
        target[key] = value15;
        continue;
      }
      target[key] = mergeDeep(target[key], value15);
    }
  return target;
};
var mergeCookie = (a2, b) => {
  const { properties: _, ...target } = a2 ?? {};
  const { properties: __, ...source } = b ?? {};
  return mergeDeep(target, source);
};
var mergeObjectArray = (a2 = [], b = []) => {
  if (!a2)
    return [];
  if (!b)
    return a2;
  const array5 = [];
  const checksums = [];
  if (!Array.isArray(a2))
    a2 = [a2];
  if (!Array.isArray(b))
    b = [b];
  for (const item of a2) {
    array5.push(item);
    if (item.checksum)
      checksums.push(item.checksum);
  }
  for (const item of b)
    if (!checksums.includes(item.checksum))
      array5.push(item);
  return array5;
};
var primitiveHooks = [
  "start",
  "request",
  "parse",
  "transform",
  "resolve",
  "beforeHandle",
  "afterHandle",
  "onResponse",
  "mapResponse",
  "trace",
  "error",
  "stop",
  "body",
  "headers",
  "params",
  "query",
  "response",
  "type",
  "detail"
];
var primitiveHookMap = primitiveHooks.reduce((acc, x) => (acc[x] = true, acc), {});
var mergeResponse = (a2, b) => {
  const isRecordNumber = (x) => typeof x === "object" && Object.keys(x).every(isNumericString);
  if (isRecordNumber(a2) && isRecordNumber(b))
    return { ...a2, ...b };
  return b ?? a2;
};
var mergeHook = (a2, b, { allowMacro = false } = {}) => {
  const rest4 = allowMacro ? {
    ...a2,
    ...b
  } : undefined;
  return {
    ...rest4,
    body: b?.body ?? a2?.body,
    headers: b?.headers ?? a2?.headers,
    params: b?.params ?? a2?.params,
    query: b?.query ?? a2?.query,
    response: mergeResponse(a2?.response, b?.response),
    type: a2?.type || b?.type,
    detail: mergeDeep(b?.detail ?? {}, a2?.detail ?? {}),
    parse: mergeObjectArray(a2?.parse, b?.parse),
    transform: mergeObjectArray(a2?.transform, b?.transform),
    beforeHandle: mergeObjectArray(a2?.beforeHandle, b?.beforeHandle),
    afterHandle: mergeObjectArray(a2?.afterHandle, b?.afterHandle),
    onResponse: mergeObjectArray(a2?.onResponse, b?.onResponse),
    mapResponse: mergeObjectArray(a2?.mapResponse, b?.mapResponse),
    trace: mergeObjectArray(a2?.trace, b?.trace),
    error: mergeObjectArray(a2?.error, b?.error)
  };
};
var getSchemaValidator = (s, {
  models = {},
  dynamic = false,
  normalize = false,
  additionalProperties = normalize
}) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  const schema3 = typeof s === "string" ? models[s] : s;
  if (schema3.type === "object" && "additionalProperties" in schema3 === false)
    schema3.additionalProperties = additionalProperties;
  const cleaner = (value15) => exports_value2.Clean(schema3, value15);
  if (dynamic) {
    const validator = {
      schema: schema3,
      references: "",
      checkFunc: () => {
      },
      code: "",
      Check: (value15) => exports_value2.Check(schema3, value15),
      Errors: (value15) => exports_value2.Errors(schema3, value15),
      Code: () => ""
    };
    if (normalize && schema3.additionalProperties === true)
      validator.Clean = cleaner;
    if (schema3.config) {
      validator.config = schema3.config;
      if (validator?.schema?.config)
        delete validator.schema.config;
    }
    return validator;
  }
  const compiled = TypeCompiler.Compile(schema3, Object.values(models));
  compiled.Clean = cleaner;
  if (schema3.config) {
    compiled.config = schema3.config;
    if (compiled?.schema?.config)
      delete compiled.schema.config;
  }
  return compiled;
};
var getResponseSchemaValidator = (s, {
  models = {},
  dynamic = false,
  normalize = false,
  additionalProperties = normalize
}) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  const maybeSchemaOrRecord = typeof s === "string" ? models[s] : s;
  const compile = (schema3, references) => {
    const cleaner = (value15) => exports_value2.Clean(schema3, value15);
    if (dynamic)
      return {
        schema: schema3,
        references: "",
        checkFunc: () => {
        },
        code: "",
        Check: (value15) => exports_value2.Check(schema3, value15),
        Errors: (value15) => exports_value2.Errors(schema3, value15),
        Code: () => ""
      };
    const compiledValidator = TypeCompiler.Compile(schema3, references);
    if (normalize && schema3.additionalProperties === true)
      compiledValidator.Clean = cleaner;
    return compiledValidator;
  };
  if (Kind in maybeSchemaOrRecord) {
    if ("additionalProperties" in maybeSchemaOrRecord === false)
      maybeSchemaOrRecord.additionalProperties = additionalProperties;
    return {
      200: compile(maybeSchemaOrRecord, Object.values(models))
    };
  }
  const record4 = {};
  Object.keys(maybeSchemaOrRecord).forEach((status) => {
    const maybeNameOrSchema = maybeSchemaOrRecord[+status];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        const schema3 = models[maybeNameOrSchema];
        schema3.type === "object" && "additionalProperties" in schema3;
        record4[+status] = Kind in schema3 ? compile(schema3, Object.values(models)) : schema3;
      }
      return;
    }
    if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
      maybeNameOrSchema.additionalProperties = additionalProperties;
    record4[+status] = Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, Object.values(models)) : maybeNameOrSchema;
  });
  return record4;
};
var isBun = typeof Bun !== "undefined";
var hasHash = isBun && typeof Bun.hash === "function";
var checksum = (s) => {
  if (hasHash)
    return Bun.hash(s);
  let h = 9;
  for (let i = 0;i < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);
  return h = h ^ h >>> 9;
};
var getCookieValidator = ({
  validator,
  defaultConfig = {},
  config: config2,
  dynamic,
  models
}) => {
  let cookieValidator = getSchemaValidator(validator, {
    dynamic,
    models,
    additionalProperties: true
  });
  if (isNotEmpty(defaultConfig)) {
    if (cookieValidator) {
      cookieValidator.config = mergeCookie(cookieValidator.config, config2);
    } else {
      cookieValidator = getSchemaValidator(t2.Cookie({}), {
        dynamic,
        models,
        additionalProperties: true
      });
      cookieValidator.config = defaultConfig;
    }
  }
  return cookieValidator;
};
var mergeLifeCycle = (a2, b, checksum2) => {
  const injectChecksum = (x) => {
    if (!x)
      return;
    if (!Array.isArray(x)) {
      const fn = x;
      if (checksum2 && !fn.checksum)
        fn.checksum = checksum2;
      if (fn.scope === "scoped")
        fn.scope = "local";
      return fn;
    }
    const fns = [...x];
    for (const fn of fns) {
      if (checksum2 && !fn.checksum)
        fn.checksum = checksum2;
      if (fn.scope === "scoped")
        fn.scope = "local";
    }
    return fns;
  };
  return {
    start: mergeObjectArray(a2.start, injectChecksum(b?.start)),
    request: mergeObjectArray(a2.request, injectChecksum(b?.request)),
    parse: mergeObjectArray(a2.parse, injectChecksum(b?.parse)),
    transform: mergeObjectArray(a2.transform, injectChecksum(b?.transform)),
    beforeHandle: mergeObjectArray(a2.beforeHandle, injectChecksum(b?.beforeHandle)),
    afterHandle: mergeObjectArray(a2.afterHandle, injectChecksum(b?.afterHandle)),
    mapResponse: mergeObjectArray(a2.mapResponse, injectChecksum(b?.mapResponse)),
    onResponse: mergeObjectArray(a2.onResponse, injectChecksum(b?.onResponse)),
    trace: a2.trace,
    error: mergeObjectArray(a2.error, injectChecksum(b?.error)),
    stop: mergeObjectArray(a2.stop, injectChecksum(b?.stop))
  };
};
var asHookType = (fn, inject, { skipIfHasType = false } = {}) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (skipIfHasType)
      fn.scope ??= inject;
    else
      fn.scope = inject;
    return fn;
  }
  for (const x of fn)
    if (skipIfHasType)
      x.scope ??= inject;
    else
      x.scope = inject;
  return fn;
};
var filterGlobal = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn))
    switch (fn.scope) {
      case "global":
      case "scoped":
        return { ...fn };
      default:
        return { fn };
    }
  const array5 = [];
  for (const x of fn)
    switch (x.scope) {
      case "global":
      case "scoped":
        array5.push({
          ...x
        });
        break;
    }
  return array5;
};
var filterGlobalHook = (hook) => {
  return {
    ...hook,
    type: hook?.type,
    detail: hook?.detail,
    parse: filterGlobal(hook?.parse),
    transform: filterGlobal(hook?.transform),
    beforeHandle: filterGlobal(hook?.beforeHandle),
    afterHandle: filterGlobal(hook?.afterHandle),
    onResponse: filterGlobal(hook?.onResponse),
    error: filterGlobal(hook?.error),
    mapResponse: filterGlobal(hook?.mapResponse)
  };
};
var StatusMap = {
  Continue: 100,
  "Switching Protocols": 101,
  Processing: 102,
  "Early Hints": 103,
  OK: 200,
  Created: 201,
  Accepted: 202,
  "Non-Authoritative Information": 203,
  "No Content": 204,
  "Reset Content": 205,
  "Partial Content": 206,
  "Multi-Status": 207,
  "Already Reported": 208,
  "Multiple Choices": 300,
  "Moved Permanently": 301,
  Found: 302,
  "See Other": 303,
  "Not Modified": 304,
  "Temporary Redirect": 307,
  "Permanent Redirect": 308,
  "Bad Request": 400,
  Unauthorized: 401,
  "Payment Required": 402,
  Forbidden: 403,
  "Not Found": 404,
  "Method Not Allowed": 405,
  "Not Acceptable": 406,
  "Proxy Authentication Required": 407,
  "Request Timeout": 408,
  Conflict: 409,
  Gone: 410,
  "Length Required": 411,
  "Precondition Failed": 412,
  "Payload Too Large": 413,
  "URI Too Long": 414,
  "Unsupported Media Type": 415,
  "Range Not Satisfiable": 416,
  "Expectation Failed": 417,
  "I'm a teapot": 418,
  "Misdirected Request": 421,
  "Unprocessable Content": 422,
  Locked: 423,
  "Failed Dependency": 424,
  "Too Early": 425,
  "Upgrade Required": 426,
  "Precondition Required": 428,
  "Too Many Requests": 429,
  "Request Header Fields Too Large": 431,
  "Unavailable For Legal Reasons": 451,
  "Internal Server Error": 500,
  "Not Implemented": 501,
  "Bad Gateway": 502,
  "Service Unavailable": 503,
  "Gateway Timeout": 504,
  "HTTP Version Not Supported": 505,
  "Variant Also Negotiates": 506,
  "Insufficient Storage": 507,
  "Loop Detected": 508,
  "Not Extended": 510,
  "Network Authentication Required": 511
};
var InvertedStatusMap = Object.fromEntries(Object.entries(StatusMap).map(([k, v]) => [v, k]));
var encoder = new TextEncoder;
var signCookie = async (val, secret) => {
  if (typeof val !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  const secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
  const hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
  return val + "." + removeTrailingEquals(Buffer.from(hmacBuffer).toString("base64"));
};
var unsignCookie = async (input, secret) => {
  if (typeof input !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  const tentativeValue = input.slice(0, input.lastIndexOf("."));
  const expectedInput = await signCookie(tentativeValue, secret);
  return expectedInput === input ? tentativeValue : false;
};
var traceBackMacro = (extension, property, hooks = property) => {
  if (!extension || typeof extension !== "object" || !property)
    return;
  for (const [key, value15] of Object.entries(property)) {
    if (key in primitiveHookMap || !(key in extension))
      continue;
    const v = extension[key];
    if (typeof v === "function") {
      v(value15);
    } else if (typeof v === "object")
      traceBackMacro(v, value15, hooks);
  }
};
var createMacroManager = ({
  globalHook,
  localHook
}) => (stackName) => (type74, fn) => {
  if (typeof type74 === "function")
    type74 = {
      fn: type74
    };
  if ("fn" in type74 || Array.isArray(type74)) {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (Array.isArray(type74))
      localHook[stackName] = localHook[stackName].concat(type74);
    else
      localHook[stackName].push(type74);
    return;
  }
  const { insert = "after", stack = "local" } = type74;
  if (typeof fn === "function")
    fn = { fn };
  if (stack === "global") {
    if (!Array.isArray(fn)) {
      if (insert === "before") {
        globalHook[stackName].unshift(fn);
      } else {
        globalHook[stackName].push(fn);
      }
    } else {
      if (insert === "before") {
        globalHook[stackName] = fn.concat(globalHook[stackName]);
      } else {
        globalHook[stackName] = globalHook[stackName].concat(fn);
      }
    }
  } else {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (!Array.isArray(fn)) {
      if (insert === "before") {
        localHook[stackName].unshift(fn);
      } else {
        localHook[stackName].push(fn);
      }
    } else {
      if (insert === "before") {
        localHook[stackName] = fn.concat(localHook[stackName]);
      } else {
        localHook[stackName] = localHook[stackName].concat(fn);
      }
    }
  }
};
var isNumericString = (message) => {
  if (message.length < 16)
    return message.trim().length !== 0 && !Number.isNaN(Number(message));
  if (message.length === 16) {
    const numVal = Number(message);
    if (numVal.toString() === message)
      return message.trim().length !== 0 && !Number.isNaN(numVal);
  }
  return false;
};
var PromiseGroup = class {
  constructor(onError = console.error) {
    this.onError = onError;
    this.root = null;
    this.promises = [];
  }
  get size() {
    return this.promises.length;
  }
  add(promise5) {
    this.promises.push(promise5);
    this.root ||= this.drain();
    return promise5;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch (error22) {
        this.onError(error22);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then(onfulfilled, onrejected) {
    return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
  }
};
var fnToContainer = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (typeof fn === "function")
      return { fn };
    else if ("fn" in fn)
      return fn;
  }
  const fns = [];
  for (const x of fn) {
    if (typeof x === "function")
      fns.push({ fn: x });
    else if ("fn" in x)
      fns.push(x);
  }
  return fns;
};
var localHookToLifeCycleStore = (a2) => {
  return {
    ...a2,
    start: fnToContainer(a2?.start),
    request: fnToContainer(a2?.request),
    parse: fnToContainer(a2?.parse),
    transform: fnToContainer(a2?.transform),
    beforeHandle: fnToContainer(a2?.beforeHandle),
    afterHandle: fnToContainer(a2?.afterHandle),
    onResponse: fnToContainer(a2?.onResponse),
    mapResponse: fnToContainer(a2?.mapResponse),
    trace: fnToContainer(a2?.trace),
    error: fnToContainer(a2?.error),
    stop: fnToContainer(a2?.stop)
  };
};
var lifeCycleToFn = (a2) => {
  return {
    ...a2,
    start: a2.start?.map((x) => x.fn),
    request: a2.request?.map((x) => x.fn),
    parse: a2.parse?.map((x) => x.fn),
    transform: a2.transform?.map((x) => x.fn),
    beforeHandle: a2.beforeHandle?.map((x) => x.fn),
    afterHandle: a2.afterHandle?.map((x) => x.fn),
    onResponse: a2.onResponse?.map((x) => x.fn),
    mapResponse: a2.mapResponse?.map((x) => x.fn),
    trace: a2.trace?.map((x) => x.fn),
    error: a2.error?.map((x) => x.fn),
    stop: a2.stop?.map((x) => x.fn)
  };
};
var cloneInference = (inference) => ({
  event: {
    body: inference.event.body,
    cookie: inference.event.cookie,
    headers: inference.event.headers,
    queries: [...inference.event.queries],
    query: inference.event.query,
    set: inference.event.set,
    unknownQueries: inference.event.unknownQueries
  },
  trace: {
    request: inference.trace.request,
    parse: inference.trace.parse,
    transform: inference.trace.transform,
    handle: inference.trace.handle,
    beforeHandle: inference.trace.beforeHandle,
    afterHandle: inference.trace.afterHandle,
    error: inference.trace.error,
    context: inference.trace.context,
    store: inference.trace.store,
    set: inference.trace.set
  }
});
var env = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var ELYSIA_RESPONSE = Symbol("ElysiaResponse");
var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";
var error22 = (code, response) => ({
  [ELYSIA_RESPONSE]: StatusMap[code] ?? code,
  response: response ?? (code in InvertedStatusMap ? InvertedStatusMap[code] : code),
  _type: undefined
});
var InternalServerError = class extends Error {
  constructor(message) {
    super(message ?? "INTERNAL_SERVER_ERROR");
    this.code = "INTERNAL_SERVER_ERROR";
    this.status = 500;
  }
};
var NotFoundError2 = class extends Error {
  constructor(message) {
    super(message ?? "NOT_FOUND");
    this.code = "NOT_FOUND";
    this.status = 404;
  }
};
var ParseError = class extends Error {
  constructor(message, body) {
    super(message ?? "PARSE");
    this.body = body;
    this.code = "PARSE";
    this.status = 400;
  }
};
var InvalidCookieSignature = class extends Error {
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
    this.code = "INVALID_COOKIE_SIGNATURE";
    this.status = 400;
  }
};
var ValidationError = class _ValidationError extends Error {
  constructor(type74, validator, value15) {
    if (typeof value15 === "object" && ELYSIA_RESPONSE in value15)
      value15 = value15.response;
    const error23 = isProduction ? undefined : ("Errors" in validator) ? validator.Errors(value15).First() : exports_value2.Errors(validator, value15).First();
    const customError = error23?.schema.error ? typeof error23.schema.error === "function" ? error23.schema.error(type74, validator, value15) : error23.schema.error : undefined;
    const accessor2 = error23?.path || "root";
    let message = "";
    if (customError) {
      message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
    } else if (isProduction) {
      message = JSON.stringify({
        type: "validation",
        on: type74,
        message: error23?.message,
        found: value15
      });
    } else {
      const schema3 = validator?.schema ?? validator;
      const errors5 = "Errors" in validator ? [...validator.Errors(value15)] : [...exports_value2.Errors(validator, value15)];
      let expected;
      try {
        expected = exports_value2.Create(schema3);
      } catch (error32) {
        expected = {
          type: "Could not create expected value",
          message: error32?.message,
          error: error32
        };
      }
      message = JSON.stringify({
        type: "validation",
        on: type74,
        property: accessor2,
        message: error23?.message,
        expected,
        found: value15,
        errors: errors5
      }, null, 2);
    }
    super(message);
    this.type = type74;
    this.validator = validator;
    this.value = value15;
    this.code = "VALIDATION";
    this.status = 422;
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  static simplifyModel(validator) {
    const model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    return _ValidationError.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, {
      status: 400,
      headers: {
        ...headers,
        "content-type": "application/json"
      }
    });
  }
};
var websocket = {
  open(ws) {
    ws.data.open?.(ws);
  },
  message(ws, message) {
    ws.data.message?.(ws, message);
  },
  drain(ws) {
    ws.data.drain?.(ws);
  },
  close(ws, code, reason) {
    ws.data.close?.(ws, code, reason);
  }
};
var ElysiaWS = class {
  constructor(raw2, data) {
    this.raw = raw2;
    this.data = data;
    this.validator = raw2.data.validator;
    if (raw2.data.id) {
      this.id = raw2.data.id;
    } else {
      const array5 = new Uint32Array(1);
      crypto.getRandomValues(array5);
      this.id = array5[0].toString();
    }
  }
  get id() {
    return this.raw.data.id;
  }
  set id(newID) {
    this.raw.data.id = newID;
  }
  get publish() {
    return (topic, data = undefined, compress) => {
      if (this.validator?.Check(data) === false)
        throw new ValidationError("message", this.validator, data);
      if (typeof data === "object")
        data = JSON.stringify(data);
      this.raw.publish(topic, data, compress);
      return this;
    };
  }
  get send() {
    return (data) => {
      if (this.validator?.Check(data) === false)
        throw new ValidationError("message", this.validator, data);
      if (Buffer.isBuffer(data)) {
        this.raw.send(data);
        return this;
      }
      if (typeof data === "object")
        data = JSON.stringify(data);
      this.raw.send(data);
      return this;
    };
  }
  get subscribe() {
    return (room) => {
      this.raw.subscribe(room);
      return this;
    };
  }
  get unsubscribe() {
    return (room) => {
      this.raw.unsubscribe(room);
      return this;
    };
  }
  get cork() {
    return (callback) => {
      this.raw.cork(callback);
      return this;
    };
  }
  get close() {
    return () => {
      this.raw.close();
      return this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
};
var headersHasToJSON = new Headers().toJSON;
var requestId = { value: 0 };
var createReport = ({
  hasTrace,
  hasTraceSet = false,
  addFn,
  condition = {}
}) => {
  if (hasTrace) {
    addFn(`
const reporter = getReporter()
`);
    return (event, {
      name,
      attribute = "",
      unit = 0
    } = {}) => {
      const dotIndex = event.indexOf(".");
      const isGroup = dotIndex === -1;
      if (event !== "request" && event !== "response" && !condition[isGroup ? event : event.slice(0, dotIndex)])
        return () => {
          if (hasTraceSet && event === "afterHandle")
            addFn(`
await traceDone
`);
        };
      if (isGroup)
        name ||= event;
      else
        name ||= "anonymous";
      addFn("\n" + `reporter.emit('event', {
					id,
					event: '${event}',
					type: 'begin',
					name: '${name}',
					time: performance.now(),
					${isGroup ? `unit: ${unit},` : ""}
					${attribute}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      return () => {
        addFn("\n" + `reporter.emit('event', {
							id,
							event: '${event}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n");
        if (hasTraceSet && event === "afterHandle")
          addFn(`
await traceDone
`);
      };
    };
  } else {
    return () => () => {
    };
  }
};
var hasReturn = (fnLiteral) => {
  const parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
    return true;
  }
  return fnLiteral.includes("return");
};
var composeValidationFactory = (hasErrorHandler, {
  injectResponse = "",
  normalize = false
} = {}) => ({
  composeValidation: (type74, value15 = `c.${type74}`) => hasErrorHandler ? `c.set.status = 422; throw new ValidationError('${type74}', ${type74}, ${value15})` : `c.set.status = 422; return new ValidationError('${type74}', ${type74}, ${value15}).toResponse(c.set.headers)`,
  composeResponseValidation: (name = "r") => {
    const returnError = hasErrorHandler ? `throw new ValidationError('response', response[c.set.status], ${name})` : `return new ValidationError('response', response[c.set.status], ${name}).toResponse(c.set.headers)`;
    let code = "\n" + injectResponse + "\n";
    code += `let er
		
		if(${name} && typeof ${name} === "object" && ELYSIA_RESPONSE in ${name})
			er = ${name}[ELYSIA_RESPONSE]
`;
    if (normalize)
      code += `
			if(!er && response[c.set.status]?.Clean)
				${name} = response[c.set.status]?.Clean(${name})
			else if(response[er]?.Clean)
				${name}.response = response[er]?.Clean(${name}.response)`;
    code += `
			if(er) {
				if(!(${name} instanceof Response) && response[er]?.Check(${name}.response) === false) {
					if(!(response instanceof Error)) {
						c.set.status = ${name}[ELYSIA_RESPONSE]

						${returnError}
					}
				}
			} else if(!(${name} instanceof Response) && response[c.set.status]?.Check(${name}) === false) {
				if(!(response instanceof Error))
					${returnError}
			}
`;
    return code;
  }
});
var KindSymbol = Symbol.for("TypeBox.Kind");
var hasType = (type74, schema3) => {
  if (!schema3)
    return;
  if (KindSymbol in schema3 && schema3[KindSymbol] === type74)
    return true;
  if (schema3.type === "object") {
    const properties = schema3.properties;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (property.type === "object") {
        if (hasType(type74, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasType(type74, property.anyOf[i]))
            return true;
      }
      if (KindSymbol in property && property[KindSymbol] === type74)
        return true;
    }
    return false;
  }
  return schema3.properties && KindSymbol in schema3.properties && schema3.properties[KindSymbol] === type74;
};
var hasProperty = (expectedProperty, schema3) => {
  if (!schema3)
    return;
  if (schema3.type === "object") {
    const properties = schema3.properties;
    if (!properties)
      return false;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++) {
          if (hasProperty(expectedProperty, property.anyOf[i]))
            return true;
        }
      }
    }
    return false;
  }
  return expectedProperty in schema3;
};
var TransformSymbol = Symbol.for("TypeBox.Transform");
var hasTransform = (schema3) => {
  if (!schema3)
    return;
  if (schema3.type === "object" && schema3.properties) {
    const properties = schema3.properties;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (property.type === "object") {
        if (hasTransform(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasTransform(property.anyOf[i]))
            return true;
      }
      const hasTransformSymbol = TransformSymbol in property;
      if (hasTransformSymbol)
        return true;
    }
    return false;
  }
  return TransformSymbol in schema3 || schema3.properties && TransformSymbol in schema3.properties;
};
var getUnionedType = (validator) => {
  if (!validator)
    return;
  const schema3 = validator?.schema;
  if (schema3 && "anyOf" in schema3) {
    let foundDifference = false;
    const type74 = schema3.anyOf[0].type;
    for (const validator2 of schema3.anyOf) {
      if (validator2.type !== type74) {
        foundDifference = true;
        break;
      }
    }
    if (!foundDifference)
      return type74;
  }
  return validator.schema?.type;
};
var matchFnReturn = /(?:return|=>) \S+\(/g;
var isAsync = (v) => {
  const fn = "fn" in v ? v.fn : v;
  if (fn.constructor.name === "AsyncFunction")
    return true;
  const literal14 = fn.toString();
  if (literal14.includes("=> response.clone("))
    return false;
  return !!literal14.match(matchFnReturn);
};
var composeHandler = ({
  app,
  path,
  method,
  localHook,
  hooks,
  validator,
  handler,
  allowMeta = false,
  appInference: { event: eventInference, trace: traceInference }
}) => {
  const isHandleFn = typeof handler === "function";
  if (!isHandleFn)
    handler = mapResponse(handler, {
      headers: app.setHeaders ?? {}
    });
  const hasErrorHandler = app.config.forceErrorEncapsulation && (isHandleFn || hooks.afterHandle.length > 0 || hooks.beforeHandle.length > 0 || hooks.transform.length > 0) || hooks.error.length > 0 || app.event.error.length > 0 || typeof Bun === "undefined" || hooks.onResponse.length > 0 || hooks.onResponse.length > 0 || !!hooks.trace.length;
  const handle = isHandleFn ? `handler(c)` : `handler`;
  const handleResponse = hooks.onResponse.length ? `
;(async () => {${hooks.onResponse.map((_, i) => `await res${i}(c)`).join(";")}})();
` : "";
  const traceConditions = traceInference;
  const hasTrace = hooks.trace.length > 0;
  let fnLiteral = "";
  const inference = sucrose(Object.assign(localHook, {
    handler
  }), eventInference);
  const hasQuery = inference.query || !!validator.query;
  const hasBody = method !== "$INTERNALWS" && method !== "GET" && method !== "HEAD" && hooks.type !== "none" && (inference.body || !!validator.body);
  const defaultHeaders = app.setHeaders;
  const hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length;
  const hasHeaders = inference.headers || validator.headers;
  const hasCookie = inference.cookie || !!validator.cookie;
  const cookieValidator = hasCookie ? getCookieValidator({
    validator: validator.cookie,
    defaultConfig: app.config.cookie,
    dynamic: !!app.config.aot,
    config: validator.cookie?.config ?? {},
    models: app.definitions.type
  }) : undefined;
  const cookieMeta = cookieValidator?.config;
  let encodeCookie = "";
  if (cookieMeta?.sign) {
    if (!cookieMeta.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
    const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
    encodeCookie += `const _setCookie = c.set.cookie
		if(_setCookie) {`;
    if (cookieMeta.sign === true) {
      encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${secret}')
			}`;
    } else
      for (const name of cookieMeta.sign) {
        encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }
`;
      }
    encodeCookie += "}\n";
  }
  const normalize = app.config.normalize;
  const { composeValidation, composeResponseValidation } = composeValidationFactory(hasErrorHandler, {
    normalize
  });
  if (hasHeaders) {
    fnLiteral += headersHasToJSON ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  }
  if (hasCookie) {
    const get = (name, defaultValue) => {
      const value15 = cookieMeta?.[name] ?? defaultValue;
      if (!value15)
        return typeof defaultValue === "string" ? `${name}: "${defaultValue}",` : `${name}: ${defaultValue},`;
      if (typeof value15 === "string")
        return `${name}: '${value15}',`;
      if (value15 instanceof Date)
        return `${name}: new Date(${value15.getTime()}),`;
      return `${name}: ${value15},`;
    };
    const options = cookieMeta ? `{
			secrets: ${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a2, b) => a2 + `'${b}',`, "") + "]" : "undefined"},
			sign: ${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a2, b) => a2 + `'${b}',`, "") + "]" : "undefined"},
			${get("domain")}
			${get("expires")}
			${get("httpOnly")}
			${get("maxAge")}
			${get("path", "/")}
			${get("priority")}
			${get("sameSite")}
			${get("secure")}
		}` : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie = await parseCookie(c.set, c.headers.cookie, ${options})
`;
    else
      fnLiteral += `
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})
`;
  }
  if (hasQuery) {
    let destructured = [];
    if (validator.query && validator.query.schema.type === "object") {
      destructured = Object.keys(validator.query.schema.properties);
    } else
      for (const query of inference.queries)
        if (destructured.indexOf(query) === -1)
          destructured.push(query);
    if (app.config.forceDynamicQuery === true || inference.unknownQueries === true || !destructured.length) {
      fnLiteral += `if(c.qi !== -1) {
				c.query = parseQuery(c.request.url.slice(c.qi + 1).replace(/\\+/g, ' '))

				for(const key of Object.keys(c.query))
					c.query[key] = decodeURIComponent(c.query[key])
			} else c.query = {}`;
    } else {
      fnLiteral += `if(c.qi !== -1) {
				let url = c.request.url.slice(c.qi).replace(/\\+/g, ' ')

				${destructured.map((name, index) => `
						${index === 0 ? "let" : ""} memory = url.indexOf('&${name}=')
						if(memory === -1) memory = url.indexOf('?${name}=')
						let a${index}

						if(memory !== -1) {
							const start = memory + ${name.length + 2}
							memory = url.indexOf('&', start)

							if(memory === -1) a${index} = decodeURIComponent(url.slice(start))
							else a${index} = decodeURIComponent(url.slice(start, memory))
						}`).join("\n")}

				c.query = {
					${destructured.map((name, index) => `'${name}': a${index}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
    }
  }
  const hasTraceSet = traceInference.set;
  const hasSet = inference.cookie || inference.set || hasTraceSet || hasHeaders || isHandleFn && hasDefaultHeaders;
  if (hasTrace)
    fnLiteral += "\nconst id = c.$$requestId\n";
  const report = createReport({
    hasTrace,
    hasTraceSet,
    condition: traceConditions,
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  fnLiteral += hasErrorHandler ? "\n try {\n" : "";
  if (hasTraceSet) {
    fnLiteral += `
const traceDone = Promise.all([`;
    for (let i = 0;i < hooks.trace.length; i++) {
      fnLiteral += `new Promise(r => { reporter.once(\`res\${id}.${i}\`, r) }),`;
    }
    fnLiteral += `])
`;
  }
  const isAsyncHandler = typeof handler === "function" && isAsync(handler);
  const maybeAsync = hasCookie || hasBody || hasTraceSet || isAsyncHandler || !!hooks.mapResponse.length || hooks.parse.length > 0 || hooks.afterHandle.some(isAsync) || hooks.beforeHandle.some(isAsync) || hooks.transform.some(isAsync);
  const endParse = report("parse", {
    unit: hooks.parse.length
  });
  if (hasBody) {
    const type74 = getUnionedType(validator?.body);
    if (hooks.type && !Array.isArray(hooks.type)) {
      if (hooks.type) {
        switch (hooks.type) {
          case "json":
          case "application/json":
            if (hasErrorHandler)
              fnLiteral += `const tempBody = await c.request.text()
							
							try {
								c.body = JSON.parse(tempBody)
							} catch {
								throw new ParseError('Failed to parse body as found: ' + (typeof body === "string" ? "'" + body + "'" : body), body)
							}`;
            else
              fnLiteral += `c.body = await c.request.json()`;
            break;
          case "text":
          case "text/plain":
            fnLiteral += `c.body = await c.request.text()
`;
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            fnLiteral += `c.body = parseQuery(await c.request.text())
`;
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            fnLiteral += `c.body = await c.request.arrayBuffer()
`;
            break;
          case "formdata":
          case "multipart/form-data":
            fnLiteral += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
`;
            break;
        }
      }
      if (hooks.parse.length)
        fnLiteral += "}}";
    } else {
      const getAotParser = () => {
        if (hooks.parse.length && type74 && !Array.isArray(hooks.type)) {
          const schema3 = validator?.body?.schema;
          if (typeof schema3 === "object" && (hasType("File", schema3) || hasType("Files", schema3)))
            return `c.body = {}

								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue

									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
        }
      };
      const aotParse = getAotParser();
      if (aotParse)
        fnLiteral += aotParse;
      else {
        fnLiteral += "\n";
        fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
        fnLiteral += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)
`;
        if (hooks.parse.length) {
          fnLiteral += `let used = false
`;
          const endReport = report("parse", {
            unit: hooks.parse.length
          });
          for (let i = 0;i < hooks.parse.length; i++) {
            const endUnit = report("parse.unit", {
              name: hooks.parse[i].fn.name
            });
            const name = `bo${i}`;
            if (i !== 0)
              fnLiteral += `if(!used) {
`;
            fnLiteral += `let ${name} = parse[${i}](c, contentType)
`;
            fnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}
`;
            fnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }
`;
            endUnit();
            if (i !== 0)
              fnLiteral += `}`;
          }
          endReport();
        }
        if (hooks.parse.length)
          fnLiteral += `if (!used)`;
        fnLiteral += `
				switch (contentType) {
					case 'application/json':
						${hasErrorHandler ? `
						const tempBody = await c.request.text()
						
						try {
							c.body = JSON.parse(tempBody)
						} catch {
							throw new ParseError('Failed to parse body as found: ' + (typeof body === "string" ? "'" + body + "'" : body), body)
						}
						` : `c.body = await c.request.json()
`}
						break

					case 'text/plain':
						c.body = await c.request.text()
						break

					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break

					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break

					case 'multipart/form-data':
						c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}

						break
					}
`;
        fnLiteral += "}\n";
      }
    }
    fnLiteral += "\n";
  }
  endParse();
  if (hooks?.transform) {
    const endTransform = report("transform", {
      unit: hooks.transform.length
    });
    if (hooks.transform.length)
      fnLiteral += "\nlet transformed\n";
    for (let i = 0;i < hooks.transform.length; i++) {
      const transform7 = hooks.transform[i];
      const endUnit = report("transform.unit", {
        name: transform7.fn.name
      });
      fnLiteral += isAsync(transform7) ? `transformed = await transform[${i}](c)
` : `transformed = transform[${i}](c)
`;
      fnLiteral += `if(transformed?.[ELYSIA_RESPONSE])
				throw transformed
			else
				Object.assign(c, transformed)
`;
      endUnit();
    }
    endTransform();
  }
  if (validator) {
    fnLiteral += "\n";
    if (validator.headers) {
      if (hasProperty("default", validator.headers.params))
        for (const [key, value15] of Object.entries(exports_value2.Default(validator.headers.schema, {}))) {
          const parsed = typeof value15 === "object" ? JSON.stringify(value15) : `'${value15}'`;
          if (parsed)
            fnLiteral += `c.headers['${key}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(headers.Check(c.headers) === false) {
				${composeValidation("headers")}
			}`;
      if (hasTransform(validator.headers.schema))
        fnLiteral += `
c.headers = headers.Decode(c.headers)
`;
    }
    if (validator.params) {
      if (hasProperty("default", validator.params.schema))
        for (const [key, value15] of Object.entries(exports_value2.Default(validator.params.schema, {}))) {
          const parsed = typeof value15 === "object" ? JSON.stringify(value15) : `'${value15}'`;
          if (parsed)
            fnLiteral += `c.params['${key}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(params.Check(c.params) === false) {
				${composeValidation("params")}
			}`;
      if (hasTransform(validator.params.schema))
        fnLiteral += `
c.params = params.Decode(c.params)
`;
    }
    if (validator.query) {
      if (normalize)
        fnLiteral += "c.query = query.Clean(c.query);\n";
      if (hasProperty("default", validator.query.schema))
        for (const [key, value15] of Object.entries(exports_value2.Default(validator.query.schema, {}))) {
          const parsed = typeof value15 === "object" ? JSON.stringify(value15) : `'${value15}'`;
          if (parsed)
            fnLiteral += `c.query['${key}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(query.Check(c.query) === false) {
				${composeValidation("query")}
			}`;
      if (hasTransform(validator.query.schema))
        fnLiteral += `
c.query = query.Decode(Object.assign({}, c.query))
`;
    }
    if (validator.body) {
      if (normalize)
        fnLiteral += "c.body = body.Clean(c.body);\n";
      if (hasProperty("default", validator.body.schema))
        fnLiteral += `if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(exports_value2.Default(validator.body.schema, null) ?? {})}, c.body)

    				if(body.Check(c.query) === false) {
        				${composeValidation("body")}
     			}
            }`;
      else
        fnLiteral += `if(body.Check(c.body) === false) {
			${composeValidation("body")}
		}`;
      if (hasTransform(validator.body.schema))
        fnLiteral += `
c.body = body.Decode(c.body)
`;
    }
    if (isNotEmpty(cookieValidator?.schema.properties ?? {})) {
      fnLiteral += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value
`;
      if (hasProperty("default", cookieValidator.schema))
        for (const [key, value15] of Object.entries(exports_value2.Default(cookieValidator.schema, {}))) {
          fnLiteral += `cookieValue['${key}'] = ${typeof value15 === "object" ? JSON.stringify(value15) : value15}
`;
        }
      fnLiteral += `if(cookie.Check(cookieValue) === false) {
				${composeValidation("cookie", "cookieValue")}
			}`;
    }
  }
  if (hooks?.beforeHandle) {
    const endBeforeHandle = report("beforeHandle", {
      unit: hooks.beforeHandle.length
    });
    let hasResolve = false;
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      const beforeHandle = hooks.beforeHandle[i];
      const endUnit = report("beforeHandle.unit", {
        name: beforeHandle.fn.name
      });
      const returning = hasReturn(beforeHandle.fn.toString());
      const isResolver = beforeHandle.subType === "resolve";
      if (isResolver) {
        if (!hasResolve) {
          hasResolve = true;
          fnLiteral += "\nlet resolved\n";
        }
        fnLiteral += isAsync(beforeHandle) ? `resolved = await beforeHandle[${i}](c);
` : `resolved = beforeHandle[${i}](c);
`;
        fnLiteral += `if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else
						Object.assign(c, resolved)
`;
      } else if (!returning) {
        fnLiteral += isAsync(beforeHandle) ? `await beforeHandle[${i}](c);
` : `beforeHandle[${i}](c);
`;
        endUnit();
      } else {
        fnLiteral += `Object.assign(c, be);`;
        fnLiteral += isAsync(beforeHandle) ? `be = await beforeHandle[${i}](c);
` : `be = beforeHandle[${i}](c);
`;
        endUnit();
        fnLiteral += `if(be !== undefined) {
`;
        endBeforeHandle();
        const endAfterHandle = report("afterHandle", {
          unit: hooks.transform.length
        });
        if (hooks.afterHandle) {
          report("handle", {
            name: isHandleFn ? handler.name : undefined
          })();
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            const hook = hooks.afterHandle[i2];
            const returning2 = hasReturn(hook.fn.toString());
            const endUnit2 = report("afterHandle.unit", {
              name: hook.fn.name
            });
            fnLiteral += `c.response = be
`;
            if (!returning2) {
              fnLiteral += isAsync(hook.fn) ? `await afterHandle[${i2}](c, be)
` : `afterHandle[${i2}](c, be)
`;
            } else {
              fnLiteral += isAsync(hook.fn) ? `af = await afterHandle[${i2}](c)
` : `af = afterHandle[${i2}](c)
`;
              fnLiteral += `if(af !== undefined) { c.response = be = af }
`;
            }
            endUnit2();
          }
        }
        endAfterHandle();
        if (validator.response)
          fnLiteral += composeResponseValidation("be");
        if (hooks.mapResponse.length) {
          fnLiteral += `c.response = be`;
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            fnLiteral += `
if(mr === undefined) {
							mr = onMapResponse[${i2}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}
`;
          }
        }
        fnLiteral += encodeCookie;
        fnLiteral += `return mapEarlyResponse(be, c.set, c.request)}
`;
      }
    }
    endBeforeHandle();
  }
  if (hooks?.afterHandle.length) {
    const endHandle = report("handle", {
      name: isHandleFn ? handler.name : undefined
    });
    if (hooks.afterHandle.length)
      fnLiteral += isAsyncHandler ? `let r = c.response = await ${handle};
` : `let r = c.response = ${handle};
`;
    else
      fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
    endHandle();
    const endAfterHandle = report("afterHandle", {
      unit: hooks.afterHandle.length
    });
    for (let i = 0;i < hooks.afterHandle.length; i++) {
      const hook = hooks.afterHandle[i];
      const returning = hasReturn(hook.fn.toString());
      const endUnit = report("afterHandle.unit", {
        name: hook.fn.name
      });
      if (!returning) {
        fnLiteral += isAsync(hook.fn) ? `await afterHandle[${i}](c)
` : `afterHandle[${i}](c)
`;
        endUnit();
      } else {
        fnLiteral += isAsync(hook.fn) ? `af = await afterHandle[${i}](c)
` : `af = afterHandle[${i}](c)
`;
        endUnit();
        if (validator.response) {
          fnLiteral += `if(af !== undefined) {`;
          endAfterHandle();
          fnLiteral += composeResponseValidation("af");
          fnLiteral += `c.response = af }`;
        } else {
          fnLiteral += `if(af !== undefined) {`;
          endAfterHandle();
          fnLiteral += `c.response = af}
`;
        }
      }
    }
    endAfterHandle();
    fnLiteral += `r = c.response
`;
    if (validator.response)
      fnLiteral += composeResponseValidation();
    fnLiteral += encodeCookie;
    if (hooks.mapResponse.length) {
      for (let i = 0;i < hooks.mapResponse.length; i++) {
        fnLiteral += `
mr = onMapResponse[${i}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr
`;
      }
    }
    if (hasSet)
      fnLiteral += `return mapResponse(r, c.set, c.request)
`;
    else
      fnLiteral += `return mapCompactResponse(r, c.request)
`;
  } else {
    const endHandle = report("handle", {
      name: isHandleFn ? handler.name : undefined
    });
    if (validator.response || hooks.mapResponse.length) {
      fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
      endHandle();
      if (validator.response)
        fnLiteral += composeResponseValidation();
      report("afterHandle")();
      if (hooks.mapResponse.length) {
        fnLiteral += "c.response = r";
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          fnLiteral += `
if(mr === undefined) { 
						mr = onMapResponse[${i}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}
`;
        }
      }
      fnLiteral += encodeCookie;
      if (handler instanceof Response) {
        fnLiteral += inference.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${handle}.clone(), c.set, c.request)
				else
					return ${handle}.clone()` : `return ${handle}.clone()`;
        fnLiteral += "\n";
      } else if (hasSet)
        fnLiteral += `return mapResponse(r, c.set, c.request)
`;
      else
        fnLiteral += `return mapCompactResponse(r, c.request)
`;
    } else if (traceConditions.handle || hasCookie) {
      fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
      endHandle();
      report("afterHandle")();
      if (hooks.mapResponse.length) {
        fnLiteral += "c.response = r";
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          fnLiteral += `
if(mr === undefined) {
							mr = onMapResponse[${i}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}
`;
        }
      }
      fnLiteral += encodeCookie;
      if (hasSet)
        fnLiteral += `return mapResponse(r, c.set, c.request)
`;
      else
        fnLiteral += `return mapCompactResponse(r, c.request)
`;
    } else {
      endHandle();
      const handled = isAsyncHandler ? `await ${handle}` : handle;
      report("afterHandle")();
      if (handler instanceof Response) {
        fnLiteral += inference.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${handle}.clone(), c.set, c.request)
				else
					return ${handle}.clone()` : `return ${handle}.clone()`;
        fnLiteral += "\n";
      } else if (hasSet)
        fnLiteral += `return mapResponse(${handled}, c.set, c.request)
`;
      else
        fnLiteral += `return mapCompactResponse(${handled}, c.request)
`;
    }
  }
  if (hasErrorHandler || handleResponse) {
    fnLiteral += `
} catch(error) {`;
    if (!maybeAsync)
      fnLiteral += `return (async () => {`;
    fnLiteral += `const set = c.set
if (!set.status || set.status < 300) set.status = error?.status || 500
`;
    const endError = report("error", {
      unit: hooks.error.length
    });
    if (hooks.error.length) {
      fnLiteral += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
      for (let i = 0;i < hooks.error.length; i++) {
        const name = `er${i}`;
        const endUnit = report("error.unit", {
          name: hooks.error[i].fn.name
        });
        fnLiteral += `
let ${name} = handleErrors[${i}](c)
`;
        if (isAsync(hooks.error[i]))
          fnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}
`;
        endUnit();
        fnLiteral += `${name} = mapEarlyResponse(${name}, set, c.request)
`;
        fnLiteral += `if (${name}) {`;
        fnLiteral += `return ${name} }
`;
      }
    }
    endError();
    fnLiteral += `return handleError(c, error, true)

`;
    if (!maybeAsync)
      fnLiteral += "})()";
    fnLiteral += "}";
    if (handleResponse || hasTrace) {
      fnLiteral += ` finally { `;
      const endResponse = report("response", {
        unit: hooks.onResponse.length
      });
      fnLiteral += handleResponse;
      endResponse();
      fnLiteral += `}`;
    }
  }
  fnLiteral = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery,
			isNotEmpty
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError,
			ParseError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent,
		ELYSIA_RESPONSE
	} = hooks

	${hooks.onResponse.length ? `const ${hooks.onResponse.map((x, i) => `res${i} = onResponse[${i}]`).join(",")}` : ""}

	return ${maybeAsync ? "async" : ""} function handle(c) {
		${hooks.beforeHandle.length ? "let be" : ""}
		${hooks.afterHandle.length ? "let af" : ""}
		${hooks.mapResponse.length ? "let mr" : ""}

		${allowMeta ? "c.schema = schema; c.defs = definitions" : ""}
		${fnLiteral}
	}`;
  const createHandler = Function("hooks", fnLiteral);
  return createHandler({
    handler,
    hooks: lifeCycleToFn(hooks),
    validator,
    handleError: app.handleError,
    utils: {
      mapResponse,
      mapCompactResponse,
      mapEarlyResponse,
      parseQuery: import_fast_querystring.parse,
      isNotEmpty
    },
    error: {
      NotFoundError: NotFoundError2,
      ValidationError,
      InternalServerError,
      ParseError
    },
    schema: app.router.history,
    definitions: app.definitions.type,
    ERROR_CODE,
    getReporter: () => app.reporter,
    requestId,
    parseCookie,
    signCookie,
    decodeURIComponent: import_fast_decode_uri_component2.default,
    ELYSIA_RESPONSE
  });
};
var composeGeneralHandler = (app) => {
  const inference = {
    event: {
      ...app.inference.event,
      queries: [...app.inference.event.queries]
    },
    trace: { ...app.inference.trace }
  };
  let decoratorsLiteral = "";
  let fnLiteral = "";
  const defaultHeaders = app.setHeaders;
  for (const key of Object.keys(app.singleton.decorator))
    decoratorsLiteral += `,${key}: app.singleton.decorator.${key}`;
  const router = app.router;
  const hasTrace = app.event.trace.length > 0;
  let findDynamicRoute = `
	const route = router.find(request.method, path) ${router.http.root.ALL ? '?? router.find("ALL", path)' : ""}

	if (route === null)
		return ${app.event.error.length ? `app.handleError(ctx, notFound)` : app.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : `error404.clone()`}

	ctx.params = route.params
`;
  const shouldPrecompile = app.config.precompile === true || typeof app.config.precompile === "object" && app.config.precompile.compose === true;
  if (!shouldPrecompile)
    findDynamicRoute += `
			if(route.store.composed)
				return route.store.composed(ctx)

			if(route.store.compose)
				return (route.store.compose())(ctx)`;
  else
    findDynamicRoute += `return route.store(ctx)`;
  findDynamicRoute += "\n";
  let switchMap = ``;
  for (const [path, { code, all }] of Object.entries(router.static.http.map))
    switchMap += `case '${path}':
switch(request.method) {
${code}
${all ?? `default: break map`}}

`;
  const maybeAsync = app.event.request.some(isAsync);
  const init = `

	const url = request.url
	const s = url.indexOf('/', 11)
	const qi = url.indexOf('?', s + 1)
	let path
	if(qi === -1)
		path = url.substring(s)
	else 
		path = url.substring(s, qi)
`;
  fnLiteral += `const {
		app,
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError,
		error
	} = data

	const store = app.singleton.store
	const staticRouter = app.router.static.http
	const wsRouter = app.router.ws
	const router = app.router.http

	const notFound = new NotFoundError()

	${app.event.request.length ? `const onRequest = app.event.request.map(x => x.fn)` : ""}
	${router.static.http.variables}
	${app.event.error.length ? "" : `
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${maybeAsync ? "async" : ""} function map(request) {
`;
  if (app.event.request.length)
    fnLiteral += `let re`;
  const report = createReport({
    hasTrace,
    hasTraceSet: inference.trace.set,
    condition: {
      request: inference.trace.request
    },
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  if (app.event.request.length) {
    fnLiteral += `
			${hasTrace ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					headers: ${Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
					status: 200
				},
				error
				${hasTrace ? ",$$requestId: +id" : ""}
				${decoratorsLiteral}
			}
		`;
    const endReport = report("request", {
      attribute: "ctx",
      unit: app.event.request.length
    });
    fnLiteral += `
 try {
`;
    for (let i = 0;i < app.event.request.length; i++) {
      const hook = app.event.request[i];
      const withReturn = hasReturn(hook.fn.toString());
      const maybeAsync2 = isAsync(hook);
      const endUnit = report("request.unit", {
        name: app.event.request[i].fn.name
      });
      if (withReturn) {
        fnLiteral += `re = mapEarlyResponse(
					${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx),
					ctx.set,
					request
				)
`;
        endUnit();
        fnLiteral += `if(re !== undefined) return re
`;
      } else {
        fnLiteral += `${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx)
`;
        endUnit();
      }
    }
    fnLiteral += `} catch (error) {
			return app.handleError(ctx, error)
		}`;
    endReport();
    fnLiteral += init;
    fnLiteral += `
ctx.qi = qi
 ctx.path = path
`;
  } else {
    fnLiteral += init;
    fnLiteral += `${hasTrace ? "const id = +requestId.value++" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: ${Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			},
			error
			${hasTrace ? ",$$requestId: id" : ""}
			${decoratorsLiteral}
		}`;
    report("request", {
      unit: app.event.request.length,
      attribute: inference.trace.context || inference.trace.store || inference.trace.set ? "ctx" : ""
    })();
  }
  const wsPaths = app.router.static.ws;
  const wsRouter = app.router.ws;
  if (Object.keys(wsPaths).length || wsRouter.history.length) {
    fnLiteral += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (const [path, index] of Object.entries(wsPaths)) {
      fnLiteral += `
					case '${path}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${index}(ctx)

						break`;
    }
    fnLiteral += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}
`;
  }
  fnLiteral += `
		map: switch(path) {
			${switchMap}

			default:
				break
		}

		${findDynamicRoute}
	}`;
  const handleError = composeErrorHandler(app);
  app.handleError = handleError;
  return Function("data", fnLiteral)({
    app,
    mapEarlyResponse,
    NotFoundError: NotFoundError2,
    getReporter: () => app.reporter,
    requestId,
    handleError,
    error: error22
  });
};
var composeErrorHandler = (app) => {
  let fnLiteral = `const {
		app: { event: { error: onErrorContainer, onResponse: resContainer } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	const onError = onErrorContainer.map(x => x.fn)
	const res = resContainer.map(x => x.fn)

	return ${app.event.error.find(isAsync) ? "async" : ""} function(context, error, skipGlobal) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(ELYSIA_RESPONSE in error) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
  for (let i = 0;i < app.event.error.length; i++) {
    const handler = app.event.error[i];
    const response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)`;
    fnLiteral += "\nif(skipGlobal !== true) {\n";
    if (hasReturn(handler.fn.toString()))
      fnLiteral += `r = ${response}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}
		
				if(set.status === 200) set.status = error.status
				return mapResponse(r, set, context.request)
			}
`;
    else
      fnLiteral += response + "\n";
    fnLiteral += "\n}\n";
  }
  fnLiteral += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 422
		return new Response(
			error.message,
			{ 
				headers: Object.assign(
					{ 'content-type': 'application/json'}, 
					set.headers
				), 
				status: set.status
			}
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set, context.request)
	}
}`;
  return Function("inject", fnLiteral)({
    app,
    mapResponse,
    ERROR_CODE,
    ELYSIA_RESPONSE
  });
};
var jitRoute = (index) => `if(stc${index}) return stc${index}(ctx)
if(st${index}.compose) return (stc${index} = st${index}.compose())(ctx)

return st${index}(ctx)`;
var createDynamicHandler = (app) => async (request) => {
  const url = request.url, s = url.indexOf("/", 11), qi = url.indexOf("?", s + 1), path = qi === -1 ? url.substring(s) : url.substring(s, qi);
  const set2 = {
    cookie: {},
    status: 200,
    headers: {}
  };
  const context = Object.assign({}, app.singleton.decorator, {
    set: set2,
    store: app.singleton.store,
    request,
    path,
    qi
  });
  try {
    for (let i = 0;i < app.event.request.length; i++) {
      const onRequest = app.event.request[i].fn;
      let response2 = onRequest(context);
      if (response2 instanceof Promise)
        response2 = await response2;
      response2 = mapEarlyResponse(response2, set2);
      if (response2)
        return response2;
    }
    const handler = app.router.dynamic.find(request.method, path) ?? app.router.dynamic.find("ALL", path);
    if (!handler)
      throw new NotFoundError2;
    const { handle, hooks, validator, content } = handler.store;
    let body;
    if (request.method !== "GET" && request.method !== "HEAD") {
      if (content) {
        switch (content) {
          case "application/json":
            body = await request.json();
            break;
          case "text/plain":
            body = await request.text();
            break;
          case "application/x-www-form-urlencoded":
            body = import_fast_querystring2.parse(await request.text());
            break;
          case "application/octet-stream":
            body = await request.arrayBuffer();
            break;
          case "multipart/form-data":
            body = {};
            const form = await request.formData();
            for (const key of form.keys()) {
              if (body[key])
                continue;
              const value15 = form.getAll(key);
              if (value15.length === 1)
                body[key] = value15[0];
              else
                body[key] = value15;
            }
            break;
        }
      } else {
        let contentType = request.headers.get("content-type");
        if (contentType) {
          const index = contentType.indexOf(";");
          if (index !== -1)
            contentType = contentType.slice(0, index);
          for (let i = 0;i < hooks.parse.length; i++) {
            const hook = hooks.parse[i].fn;
            let temp = hook(context, contentType);
            if (temp instanceof Promise)
              temp = await temp;
            if (temp) {
              body = temp;
              break;
            }
          }
          if (body === undefined) {
            switch (contentType) {
              case "application/json":
                body = await request.json();
                break;
              case "text/plain":
                body = await request.text();
                break;
              case "application/x-www-form-urlencoded":
                body = import_fast_querystring2.parse(await request.text());
                break;
              case "application/octet-stream":
                body = await request.arrayBuffer();
                break;
              case "multipart/form-data":
                body = {};
                const form = await request.formData();
                for (const key of form.keys()) {
                  if (body[key])
                    continue;
                  const value15 = form.getAll(key);
                  if (value15.length === 1)
                    body[key] = value15[0];
                  else
                    body[key] = value15;
                }
                break;
            }
          }
        }
      }
    }
    context.body = body;
    context.params = handler?.params || undefined;
    context.query = qi === -1 ? {} : import_fast_querystring2.parse(url.substring(qi + 1));
    context.headers = {};
    for (const [key, value15] of request.headers.entries())
      context.headers[key] = value15;
    const cookieMeta = Object.assign({}, app.config?.cookie, validator?.cookie?.config);
    const cookieHeaderValue = request.headers.get("cookie");
    context.cookie = await parseCookie(context.set, cookieHeaderValue, cookieMeta ? {
      secrets: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined,
      sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined
    } : undefined);
    for (let i = 0;i < hooks.transform.length; i++) {
      const hook = hooks.transform[i];
      const operation = hook.fn(context);
      if (hook.subType === "derive") {
        if (operation instanceof Promise)
          Object.assign(context, await operation);
        else
          Object.assign(context, operation);
      } else if (operation instanceof Promise)
        await operation;
    }
    if (validator) {
      if (validator.headers) {
        const _header = {};
        for (const key in request.headers)
          _header[key] = request.headers.get(key);
        if (validator.headers.Check(_header) === false)
          throw new ValidationError("header", validator.headers, _header);
      }
      if (validator.params?.Check(context.params) === false)
        throw new ValidationError("params", validator.params, context.params);
      if (validator.query?.Check(context.query) === false)
        throw new ValidationError("query", validator.query, context.query);
      if (validator.cookie) {
        const cookieValue = {};
        for (const [key, value15] of Object.entries(context.cookie))
          cookieValue[key] = value15.value;
        if (validator.cookie?.Check(cookieValue) === false)
          throw new ValidationError("cookie", validator.cookie, cookieValue);
      }
      if (validator.body?.Check(body) === false)
        throw new ValidationError("body", validator.body, body);
    }
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      let response2 = hooks.beforeHandle[i].fn(context);
      if (response2 instanceof Promise)
        response2 = await response2;
      if (response2 !== undefined) {
        context.response = response2;
        for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
          let newResponse = hooks.afterHandle[i2].fn(context);
          if (newResponse instanceof Promise)
            newResponse = await newResponse;
          if (newResponse)
            response2 = newResponse;
        }
        const result = mapEarlyResponse(response2, context.set);
        if (result)
          return result;
      }
    }
    let response = handle(context);
    if (response instanceof Promise)
      response = await response;
    if (!hooks.afterHandle.length) {
      const responseValidator = validator?.response?.[response.status];
      if (responseValidator?.Check(response) === false)
        throw new ValidationError("response", responseValidator, response);
    } else {
      context.response = response;
      for (let i = 0;i < hooks.afterHandle.length; i++) {
        let newResponse = hooks.afterHandle[i].fn(context);
        if (newResponse instanceof Promise)
          newResponse = await newResponse;
        const result = mapEarlyResponse(newResponse, context.set);
        if (result !== undefined) {
          const responseValidator = validator?.response?.[response.status];
          if (responseValidator?.Check(result) === false)
            throw new ValidationError("response", responseValidator, result);
          return result;
        }
      }
    }
    if (context.set.cookie && cookieMeta?.sign) {
      const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      if (cookieMeta.sign === true)
        for (const [key, cookie] of Object.entries(context.set.cookie))
          context.set.cookie[key].value = await signCookie(cookie.value, "${secret}");
      else {
        const properties = validator?.cookie?.schema?.properties;
        for (const name of cookieMeta.sign) {
          if (!(name in properties))
            continue;
          if (context.set.cookie[name]?.value) {
            context.set.cookie[name].value = await signCookie(context.set.cookie[name].value, secret);
          }
        }
      }
    }
    return mapResponse(response, context.set);
  } catch (error23) {
    if (error23.status)
      set2.status = error23.status;
    return app.handleError(context, error23);
  } finally {
    for (const onResponse of app.event.onResponse)
      await onResponse.fn(context);
  }
};
var createDynamicErrorHandler = (app) => async (context, error23) => {
  const errorContext = Object.assign(context, { error: error23, code: error23.code });
  errorContext.set = context.set;
  for (let i = 0;i < app.event.error.length; i++) {
    const hook = app.event.error[i];
    let response = hook.fn(errorContext);
    if (response instanceof Promise)
      response = await response;
    if (response !== undefined && response !== null)
      return mapResponse(response, context.set);
  }
  return new Response(typeof error23.cause === "string" ? error23.cause : error23.message, {
    headers: context.set.headers,
    status: error23.status ?? 500
  });
};
var fullFormats = {
  date: date5,
  time: getTime(true),
  "date-time": getDateTime(true),
  "iso-time": getTime(false),
  "iso-date-time": getDateTime(false),
  duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
  uri,
  "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
  "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
  url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
  ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
  regex,
  uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
  "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
  "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
  "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
  byte,
  int32: { type: "number", validate: validateInt32 },
  int64: { type: "number", validate: validateInt64 },
  float: { type: "number", validate: validateNumber },
  double: { type: "number", validate: validateNumber },
  password: true,
  binary: true
};
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
var DATE_TIME_SEPARATOR = /t|\s/i;
var NOT_URI_FRAGMENT = /\/|:/;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
var MIN_INT32 = -(2 ** 31);
var MAX_INT32 = 2 ** 31 - 1;
var Z_ANCHOR = /[^\\]\\Z/;
var isISO8601 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate = fullFormats.date;
var _validateDateTime = fullFormats["date-time"];
TypeSystem.Format("date", (value15) => {
  const temp = value15.replace(/"/g, "");
  if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDate(temp)) {
    const date22 = new Date(temp);
    if (!Number.isNaN(date22.getTime()))
      return true;
  }
  return false;
});
TypeSystem.Format("date-time", (value15) => {
  const temp = value15.replace(/"/g, "");
  if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDateTime(temp)) {
    const date22 = new Date(temp);
    if (!Number.isNaN(date22.getTime()))
      return true;
  }
  return false;
});
Object.entries(fullFormats).forEach((formatEntry) => {
  const [formatName, formatValue] = formatEntry;
  if (!exports_format.Has(formatName)) {
    if (formatValue instanceof RegExp)
      TypeSystem.Format(formatName, (value15) => formatValue.test(value15));
    else if (typeof formatValue === "function")
      TypeSystem.Format(formatName, formatValue);
  }
});
var t2 = Object.assign({}, Type);
var parseFileUnit = (size) => {
  if (typeof size === "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var validateFile = (options, value15) => {
  if (!(value15 instanceof Blob))
    return false;
  if (options.minSize && value15.size < parseFileUnit(options.minSize))
    return false;
  if (options.maxSize && value15.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension)
    if (typeof options.extension === "string") {
      if (!value15.type.startsWith(options.extension))
        return false;
    } else {
      for (let i = 0;i < options.extension.length; i++)
        if (value15.type.startsWith(options.extension[i]))
          return true;
      return false;
    }
  return true;
};
var File = exports_type.Get("Files") ?? TypeSystem.Type("File", validateFile);
var Files = exports_type.Get("Files") ?? TypeSystem.Type("Files", (options, value15) => {
  if (!Array.isArray(value15))
    return validateFile(options, value15);
  if (options.minItems && value15.length < options.minItems)
    return false;
  if (options.maxItems && value15.length > options.maxItems)
    return false;
  for (let i = 0;i < value15.length; i++)
    if (!validateFile(options, value15[i]))
      return false;
  return true;
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", (value15) => !!value15 && !isNaN(+value15));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", (value15) => value15 === "true" || value15 === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", (value15) => {
    let start = value15.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value15.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      JSON.parse(value15);
      return true;
    } catch {
      return false;
    }
  });
var ElysiaType = {
  Numeric: (property) => {
    const schema3 = Type.Number(property);
    return t2.Transform(t2.Union([
      t2.String({
        format: "numeric",
        default: 0
      }),
      t2.Number(property)
    ], property)).Decode((value15) => {
      const number7 = +value15;
      if (isNaN(number7))
        return value15;
      if (property && !exports_value2.Check(schema3, number7))
        throw new ValidationError("property", schema3, number7);
      return number7;
    }).Encode((value15) => value15);
  },
  Date: (property) => {
    const schema3 = Type.Date(property);
    return t2.Transform(t2.Union([
      Type.Date(property),
      t2.String({
        format: "date",
        default: (new Date()).toISOString()
      }),
      t2.String({
        format: "date-time",
        default: (new Date()).toISOString()
      })
    ], property)).Decode((value15) => {
      if (value15 instanceof Date)
        return value15;
      const date22 = new Date(value15);
      if (!exports_value2.Check(schema3, date22))
        throw new ValidationError("property", schema3, date22);
      return date22;
    }).Encode((value15) => {
      if (typeof value15 === "string")
        return new Date(value15);
      return value15;
    });
  },
  BooleanString: (property) => {
    const schema3 = Type.Boolean(property);
    return t2.Transform(t2.Union([
      t2.String({
        format: "boolean",
        default: false
      }),
      t2.Boolean(property)
    ], property)).Decode((value15) => {
      if (typeof value15 === "string")
        return value15 === "true";
      if (property && !exports_value2.Check(schema3, value15))
        throw new ValidationError("property", schema3, value15);
      return value15;
    }).Encode((value15) => value15);
  },
  ObjectString: (properties = {}, options) => {
    const schema3 = t2.Object(properties, options);
    const defaultValue = JSON.stringify(exports_value2.Create(schema3));
    return t2.Transform(t2.Union([
      t2.String({
        format: "ObjectString",
        default: defaultValue
      }),
      schema3
    ])).Decode((value15) => {
      if (typeof value15 === "string") {
        try {
          value15 = JSON.parse(value15);
        } catch {
          throw new ValidationError("property", schema3, value15);
        }
        if (!exports_value2.Check(schema3, value15))
          throw new ValidationError("property", schema3, value15);
        return value15;
      }
      return value15;
    }).Encode((value15) => {
      if (typeof value15 === "string")
        try {
          value15 = JSON.parse(value15);
        } catch {
          throw new ValidationError("property", schema3, value15);
        }
      if (!exports_value2.Check(schema3, value15))
        throw new ValidationError("property", schema3, value15);
      return JSON.stringify(value15);
    });
  },
  File,
  Files: (options = {}) => t2.Transform(Files(options)).Decode((value15) => {
    if (Array.isArray(value15))
      return value15;
    return [value15];
  }).Encode((value15) => value15),
  Nullable: (schema3) => t2.Union([t2.Null(), schema3]),
  MaybeEmpty: (schema3) => t2.Union([t2.Null(), t2.Undefined(), schema3]),
  Cookie: (properties, {
    domain,
    expires,
    httpOnly,
    maxAge,
    path,
    priority,
    sameSite,
    secure,
    secrets,
    sign,
    ...options
  } = {}) => {
    const v = t2.Object(properties, options);
    v.config = {
      domain,
      expires,
      httpOnly,
      maxAge,
      path,
      priority,
      sameSite,
      secure,
      secrets,
      sign
    };
    return v;
  }
};
t2.BooleanString = ElysiaType.BooleanString;
t2.ObjectString = ElysiaType.ObjectString;
t2.Numeric = ElysiaType.Numeric;
t2.File = (arg = {}) => ElysiaType.File({
  default: "File",
  ...arg,
  extension: arg?.type,
  type: "string",
  format: "binary"
});
t2.Files = (arg = {}) => ElysiaType.Files({
  ...arg,
  elysiaMeta: "Files",
  default: "Files",
  extension: arg?.type,
  type: "array",
  items: {
    ...arg,
    default: "Files",
    type: "string",
    format: "binary"
  }
});
t2.Nullable = (schema3) => ElysiaType.Nullable(schema3);
t2.MaybeEmpty = ElysiaType.MaybeEmpty;
t2.Cookie = ElysiaType.Cookie;
t2.Date = ElysiaType.Date;
var Elysia = class _Elysia {
  constructor(config2) {
    this.server = null;
    this.dependencies = {};
    this.reporter = new eventemitter3_default;
    this._routes = {};
    this._types = {
      Prefix: "",
      Scoped: false,
      Singleton: {},
      Definitions: {},
      Metadata: {}
    };
    this._ephemeral = {};
    this._volatile = {};
    this.singleton = {
      decorator: {},
      store: {},
      derive: {},
      resolve: {}
    };
    this.definitions = {
      type: {},
      error: {}
    };
    this.extender = {
      macros: []
    };
    this.validator = null;
    this.event = {
      start: [],
      request: [],
      parse: [],
      transform: [],
      beforeHandle: [],
      afterHandle: [],
      mapResponse: [],
      onResponse: [],
      trace: [],
      error: [],
      stop: []
    };
    this.telemetry = {
      stack: undefined
    };
    this.router = {
      http: new Memoirist,
      ws: new Memoirist,
      dynamic: new Memoirist,
      static: {
        http: {
          handlers: [],
          variables: "",
          map: {},
          all: ""
        },
        ws: {}
      },
      history: []
    };
    this.inference = {
      event: {
        body: false,
        cookie: false,
        headers: false,
        queries: [],
        query: false,
        set: false,
        unknownQueries: false
      },
      trace: {
        request: false,
        parse: false,
        transform: false,
        handle: false,
        beforeHandle: false,
        afterHandle: false,
        error: false,
        context: false,
        store: false,
        set: false
      }
    };
    this.promisedModules = new PromiseGroup;
    this.routeTree = new Map;
    this.handle = async (request) => this.fetch(request);
    this.fetch = (request) => {
      if (false)
        ;
      return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
    };
    this.handleError = async (context, error23) => (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error23);
    this.outerErrorHandler = (error23) => new Response(error23.message || error23.name || "Error", {
      status: error23?.status ?? 500
    });
    this.listen = (options, callback) => {
      if (typeof Bun === "undefined")
        throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
      this.compile();
      if (typeof options === "string") {
        if (!isNumericString(options))
          throw new Error("Port must be a numeric value");
        options = parseInt(options);
      }
      const fetch2 = this.fetch;
      const serve = typeof options === "object" ? {
        development: !isProduction,
        reusePort: true,
        ...this.config.serve || {},
        ...options || {},
        websocket: {
          ...this.config.websocket || {},
          ...websocket || {}
        },
        fetch: fetch2,
        error: this.outerErrorHandler
      } : {
        development: !isProduction,
        reusePort: true,
        ...this.config.serve || {},
        websocket: {
          ...this.config.websocket || {},
          ...websocket || {}
        },
        port: options,
        fetch: fetch2,
        error: this.outerErrorHandler
      };
      this.server = Bun?.serve(serve);
      for (let i = 0;i < this.event.start.length; i++)
        this.event.start[i].fn(this);
      if (callback)
        callback(this.server);
      process.on("beforeExit", () => {
        if (this.server) {
          this.server.stop();
          this.server = null;
          for (let i = 0;i < this.event.stop.length; i++)
            this.event.stop[i].fn(this);
        }
      });
      this.promisedModules.then(() => {
        Bun?.gc(false);
      });
      return this;
    };
    this.stop = async () => {
      if (!this.server)
        throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
      if (this.server) {
        this.server.stop();
        this.server = null;
        if (this.event.stop.length)
          for (let i = 0;i < this.event.stop.length; i++)
            this.event.stop[i].fn(this);
      }
    };
    if (config2?.tags) {
      if (!config2.detail)
        config2.detail = {
          tags: config2.tags
        };
      else
        config2.detail.tags = config2.tags;
    }
    this.config = {
      forceErrorEncapsulation: true,
      prefix: "",
      aot: true,
      strictPath: false,
      global: false,
      cookie: {},
      analytic: false,
      ...config2,
      experimental: config2?.experimental ?? {},
      seed: config2?.seed === undefined ? "" : config2?.seed
    };
    if (config2?.analytic && (config2?.name || config2?.seed !== undefined))
      this.telemetry.stack = new Error().stack;
  }
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  get _scoped() {
    return this.config.scoped;
  }
  getServer() {
    return this.server;
  }
  get routes() {
    return this.router.history;
  }
  applyMacro(localHook) {
    if (this.extender.macros.length) {
      const manage = createMacroManager({
        globalHook: this.event,
        localHook
      });
      const manager = {
        events: {
          global: this.event,
          local: localHook
        },
        onParse: manage("parse"),
        onTransform: manage("transform"),
        onBeforeHandle: manage("beforeHandle"),
        onAfterHandle: manage("afterHandle"),
        onResponse: manage("onResponse"),
        mapResponse: manage("mapResponse"),
        onError: manage("error")
      };
      for (const macro of this.extender.macros)
        traceBackMacro(macro.fn(manager), localHook);
    }
  }
  add(method, path, handle, localHook, { allowMeta = false, skipPrefix = false } = {
    allowMeta: false,
    skipPrefix: false
  }) {
    localHook = localHookToLifeCycleStore(localHook);
    if (path !== "" && path.charCodeAt(0) !== 47)
      path = "/" + path;
    if (this.config.prefix && !skipPrefix && !this.config.scoped)
      path = this.config.prefix + path;
    if (localHook?.type)
      switch (localHook.type) {
        case "text":
          localHook.type = "text/plain";
          break;
        case "json":
          localHook.type = "application/json";
          break;
        case "formdata":
          localHook.type = "multipart/form-data";
          break;
        case "urlencoded":
          localHook.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          localHook.type = "application/octet-stream";
          break;
        default:
          break;
      }
    const models = this.definitions.type;
    let _body, _headers, _params, _query, _cookie, _response;
    const dynamic = !this.config.aot;
    const cloned = {
      body: localHook?.body ?? this.validator?.body,
      headers: localHook?.headers ?? this.validator?.headers,
      params: localHook?.params ?? this.validator?.params,
      query: localHook?.query ?? this.validator?.query,
      cookie: localHook?.cookie ?? this.validator?.cookie,
      response: localHook?.response ?? this.validator?.response
    };
    const cookieValidator = () => cloned.cookie ? getCookieValidator({
      validator: cloned.cookie,
      defaultConfig: this.config.cookie,
      config: cloned.cookie?.config ?? {},
      dynamic,
      models
    }) : undefined;
    const normalize = this.config.normalize;
    const validator = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? {
      body: getSchemaValidator(cloned.body, {
        dynamic,
        models,
        normalize
      }),
      headers: getSchemaValidator(cloned.headers, {
        dynamic,
        models,
        additionalProperties: true
      }),
      params: getSchemaValidator(cloned.params, {
        dynamic,
        models
      }),
      query: getSchemaValidator(cloned.query, {
        dynamic,
        models,
        normalize
      }),
      cookie: cookieValidator(),
      response: getResponseSchemaValidator(cloned.response, {
        dynamic,
        models,
        normalize
      })
    } : {
      get body() {
        if (_body)
          return _body;
        return _body = getSchemaValidator(cloned.body, {
          dynamic,
          models,
          normalize
        });
      },
      get headers() {
        if (_headers)
          return _headers;
        return getSchemaValidator(cloned.headers, {
          dynamic,
          models,
          additionalProperties: true
        });
      },
      get params() {
        if (_params)
          return _params;
        return _params = getSchemaValidator(cloned.params, {
          dynamic,
          models
        });
      },
      get query() {
        if (_query)
          return _query;
        return _query = getSchemaValidator(cloned.query, {
          dynamic,
          models
        });
      },
      get cookie() {
        if (_cookie)
          return _cookie;
        return _cookie = cookieValidator();
      },
      get response() {
        if (_response)
          return _response;
        return _response = getResponseSchemaValidator(cloned.response, {
          dynamic,
          models,
          normalize
        });
      }
    };
    const loosePath = path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
    localHook = mergeHook(localHook, {}, { allowMacro: true });
    if (localHook.tags) {
      if (!localHook.detail)
        localHook.detail = {
          tags: localHook.tags
        };
      else
        localHook.detail.tags = localHook.tags;
    }
    if (isNotEmpty(this.config.detail))
      localHook.detail = mergeDeep(Object.assign({}, this.config.detail), localHook.detail);
    this.applyMacro(localHook);
    const hooks = mergeHook(this.event, localHook);
    if (this.config.aot === false) {
      this.router.dynamic.add(method, path, {
        validator,
        hooks,
        content: localHook?.type,
        handle
      });
      if (this.config.strictPath === false) {
        this.router.dynamic.add(method, loosePath, {
          validator,
          hooks,
          content: localHook?.type,
          handle
        });
      }
      this.router.history.push({
        method,
        path,
        composed: null,
        handler: handle,
        hooks
      });
      return;
    }
    let composed = undefined;
    const shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true;
    const appInference = cloneInference(this.inference);
    const mainHandler = shouldPrecompile ? composeHandler({
      app: this,
      path,
      method,
      localHook: mergeHook(localHook),
      hooks,
      validator,
      handler: handle,
      allowMeta,
      appInference
    }) : (context) => {
      if (composed)
        return composed(context);
      return (composed = composeHandler({
        app: this,
        path,
        method,
        localHook: mergeHook(localHook),
        hooks,
        validator,
        handler: handle,
        allowMeta,
        appInference
      }))(context);
    };
    if (!shouldPrecompile)
      mainHandler.compose = () => {
        return mainHandler.composed = composeHandler({
          app: this,
          path,
          method,
          localHook: mergeHook(localHook),
          hooks,
          validator,
          handler: handle,
          allowMeta,
          appInference
        });
      };
    let routeIndex = this.router.history.length;
    if (this.routeTree.has(method + path)) {
      routeIndex = this.router.history.findIndex((route) => route.path === path && route.method === method);
      if (routeIndex !== -1) {
        const removed = this.router.history.splice(routeIndex, 1)[0];
        if (removed && this.routeTree.has(removed?.method + removed?.path))
          this.routeTree.delete(removed.method + removed.path);
      }
    }
    this.routeTree.set(method + path, routeIndex);
    this.router.history.push({
      method,
      path,
      composed: mainHandler,
      handler: handle,
      hooks
    });
    const staticRouter = this.router.static.http;
    if (method === "$INTERNALWS") {
      const loose = this.config.strictPath ? undefined : path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
      if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
        const index = staticRouter.handlers.length;
        staticRouter.handlers.push(mainHandler);
        staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]
`;
        this.router.static.ws[path] = index;
        if (loose)
          this.router.static.ws[loose] = index;
      } else {
        this.router.ws.add("ws", path, mainHandler);
        if (loose)
          this.router.ws.add("ws", loose, mainHandler);
      }
      return;
    }
    if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
      const index = staticRouter.handlers.length;
      staticRouter.handlers.push(mainHandler);
      staticRouter.variables += shouldPrecompile ? `const st${index} = staticRouter.handlers[${index}]
` : `let st${index} = staticRouter.handlers[${index}]
let stc${index}
`;
      if (!staticRouter.map[path])
        staticRouter.map[path] = {
          code: ""
        };
      if (method === "ALL")
        staticRouter.map[path].all = shouldPrecompile ? `default: return st${index}(ctx)
` : `default: ${jitRoute(index)}
`;
      else
        staticRouter.map[path].code = shouldPrecompile ? `case '${method}': return st${index}(ctx)
${staticRouter.map[path].code}` : `case '${method}': ${jitRoute(index)}
${staticRouter.map[path].code}`;
      if (!this.config.strictPath) {
        if (!staticRouter.map[loosePath])
          staticRouter.map[loosePath] = {
            code: ""
          };
        if (method === "ALL")
          staticRouter.map[loosePath].all = shouldPrecompile ? `default: return st${index}(ctx)
` : `default: ${jitRoute(index)}
`;
        else
          staticRouter.map[loosePath].code = shouldPrecompile ? `case '${method}': return st${index}(ctx)
${staticRouter.map[loosePath].code}` : `case '${method}': ${jitRoute(index)}
${staticRouter.map[loosePath].code}`;
      }
    } else {
      this.router.http.add(method, path, mainHandler);
      if (!this.config.strictPath)
        this.router.http.add(method, path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/", mainHandler);
    }
  }
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    this.setHeaders = mergeDeep(this.setHeaders, header);
    return this;
  }
  onStart(handler) {
    this.on("start", handler);
    return this;
  }
  onRequest(handler) {
    this.on("request", handler);
    return this;
  }
  onParse(options, handler) {
    if (!handler)
      return this.on("parse", options);
    return this.on(options, "parse", handler);
  }
  onTransform(options, handler) {
    if (!handler)
      return this.on("transform", options);
    return this.on(options, "transform", handler);
  }
  resolve(optionsOrResolve, resolve) {
    if (!resolve) {
      resolve = optionsOrResolve;
      optionsOrResolve = { as: "local" };
    }
    const hook = {
      subType: "resolve",
      fn: resolve
    };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  mapResolve(optionsOrResolve, mapper) {
    if (!mapper) {
      mapper = optionsOrResolve;
      optionsOrResolve = { as: "local" };
    }
    const hook = {
      subType: "resolve",
      fn: mapper
    };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  onBeforeHandle(options, handler) {
    if (!handler)
      return this.on("beforeHandle", options);
    return this.on(options, "beforeHandle", handler);
  }
  onAfterHandle(options, handler) {
    if (!handler)
      return this.on("afterHandle", options);
    return this.on(options, "afterHandle", handler);
  }
  mapResponse(options, handler) {
    if (!handler)
      return this.on("mapResponse", options);
    return this.on(options, "mapResponse", handler);
  }
  onResponse(options, handler) {
    if (!handler)
      return this.on("response", options);
    return this.on(options, "response", handler);
  }
  trace(options, handler) {
    if (!handler) {
      handler = options;
      options = { as: "local" };
    }
    if (!Array.isArray(handler))
      handler = [handler];
    for (const fn of handler)
      this.reporter.on("event", createTraceListener(() => this.reporter, this.event.trace.length, fn));
    this.on(options, "trace", handler);
    return this;
  }
  error(name, error23) {
    switch (typeof name) {
      case "string":
        error23.prototype[ERROR_CODE] = name;
        this.definitions.error[name] = error23;
        return this;
      case "function":
        this.definitions.error = name(this.definitions.error);
        return this;
    }
    for (const [code, error32] of Object.entries(name)) {
      error32.prototype[ERROR_CODE] = code;
      this.definitions.error[code] = error32;
    }
    return this;
  }
  onError(options, handler) {
    if (!handler)
      return this.on("error", options);
    return this.on(options, "error", handler);
  }
  onStop(handler) {
    this.on("stop", handler);
    return this;
  }
  on(optionsOrType, typeOrHandlers, handlers) {
    let type74;
    switch (typeof optionsOrType) {
      case "string":
        type74 = optionsOrType;
        handlers = typeOrHandlers;
        break;
      case "object":
        type74 = typeOrHandlers;
        break;
    }
    if (type74 === "response")
      type74 = "onResponse";
    if (Array.isArray(handlers))
      handlers = fnToContainer(handlers);
    else {
      if (typeof handlers === "function")
        handlers = [
          {
            fn: handlers
          }
        ];
      else
        handlers = [handlers];
    }
    const handles = handlers;
    for (const handle of handles)
      handle.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local";
    if (type74 === "trace")
      sucroseTrace(handles.map((x) => x.fn), this.inference.trace);
    else
      sucrose({
        [type74]: handles.map((x) => x.fn)
      }, this.inference.event);
    for (const handle of handles) {
      const fn = asHookType(handle, "global", { skipIfHasType: true });
      switch (type74) {
        case "start":
          this.event.start.push(fn);
          break;
        case "request":
          this.event.request.push(fn);
          break;
        case "parse":
          this.event.parse.push(fn);
          break;
        case "transform":
          this.event.transform.push(fn);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(fn);
          break;
        case "afterHandle":
          this.event.afterHandle.push(fn);
          break;
        case "mapResponse":
          this.event.mapResponse.push(fn);
          break;
        case "onResponse":
          this.event.onResponse.push(fn);
          break;
        case "trace":
          this.event.trace.push(fn);
          break;
        case "error":
          this.event.error.push(fn);
          break;
        case "stop":
          this.event.stop.push(fn);
          break;
      }
    }
    return this;
  }
  propagate() {
    const promoteEvent = (events) => {
      for (const event of events) {
        if ("scope" in event && event.scope === "local")
          event.scope = "scoped";
      }
    };
    promoteEvent(this.event.parse);
    promoteEvent(this.event.transform);
    promoteEvent(this.event.beforeHandle);
    promoteEvent(this.event.afterHandle);
    promoteEvent(this.event.mapResponse);
    promoteEvent(this.event.onResponse);
    promoteEvent(this.event.trace);
    promoteEvent(this.event.error);
    return this;
  }
  group(prefix, schemaOrRun, run) {
    const instance = new _Elysia({
      ...this.config,
      prefix: ""
    });
    instance.singleton = { ...this.singleton };
    instance.definitions = { ...this.definitions };
    instance.getServer = () => this.server;
    instance.inference = cloneInference(this.inference);
    const isSchema = typeof schemaOrRun === "object";
    const sandbox = (isSchema ? run : schemaOrRun)(instance);
    this.singleton = mergeDeep(this.singleton, instance.singleton);
    this.definitions = mergeDeep(this.definitions, instance.definitions);
    if (sandbox.event.request.length)
      this.event.request = [
        ...this.event.request || [],
        ...sandbox.event.request || []
      ];
    if (sandbox.event.onResponse.length)
      this.event.onResponse = [
        ...this.event.onResponse || [],
        ...sandbox.event.onResponse || []
      ];
    this.model(sandbox.definitions.type);
    Object.values(instance.router.history).forEach(({ method, path, handler, hooks }) => {
      path = (isSchema ? "" : this.config.prefix) + prefix + path;
      if (isSchema) {
        const hook = schemaOrRun;
        const localHook = hooks;
        this.add(method, path, handler, mergeHook(hook, {
          ...localHook || {},
          error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
            ...localHook.error || {},
            ...sandbox.event.error || {}
          ] : [
            localHook.error,
            ...sandbox.event.error || {}
          ]
        }));
      } else {
        this.add(method, path, handler, mergeHook(hooks, {
          error: sandbox.event.error
        }), {
          skipPrefix: true
        });
      }
    });
    return this;
  }
  guard(hook, run) {
    if (!run) {
      if (typeof hook === "object") {
        this.applyMacro(hook);
        this.event = mergeLifeCycle(this.event, hook);
        this.validator = {
          body: hook.body ?? this.validator?.body,
          headers: hook.headers ?? this.validator?.headers,
          params: hook.params ?? this.validator?.params,
          query: hook.query ?? this.validator?.query,
          response: hook.response ?? this.validator?.response,
          cookie: hook.cookie ?? this.validator?.cookie
        };
        if (hook.detail) {
          if (this.config.detail)
            this.config.detail = mergeDeep(Object.assign({}, this.config.detail), hook.detail);
          else
            this.config.detail = hook.detail;
        }
        if (hook?.tags) {
          if (!this.config.detail)
            this.config.detail = {
              tags: hook.tags
            };
          else
            this.config.detail.tags = hook.tags;
        }
        return this;
      }
      return this.guard({}, hook);
    }
    const instance = new _Elysia({
      ...this.config,
      prefix: ""
    });
    instance.singleton = { ...this.singleton };
    instance.definitions = { ...this.definitions };
    instance.inference = cloneInference(this.inference);
    const sandbox = run(instance);
    this.singleton = mergeDeep(this.singleton, instance.singleton);
    this.definitions = mergeDeep(this.definitions, instance.definitions);
    sandbox.getServer = () => this.server;
    if (sandbox.event.request.length)
      this.event.request = [
        ...this.event.request || [],
        ...sandbox.event.request || []
      ];
    if (sandbox.event.onResponse.length)
      this.event.onResponse = [
        ...this.event.onResponse || [],
        ...sandbox.event.onResponse || []
      ];
    this.model(sandbox.definitions.type);
    Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
      this.add(method, path, handler, mergeHook(hook, {
        ...localHook || {},
        error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
          ...localHook.error || {},
          ...sandbox.event.error || []
        ] : [
          localHook.error,
          ...sandbox.event.error || []
        ]
      }, {
        allowMacro: true
      }));
    });
    return this;
  }
  use(plugin, options) {
    if (options?.scoped)
      return this.guard({}, (app) => app.use(plugin));
    if (Array.isArray(plugin)) {
      let current = this;
      for (const p of plugin)
        current = this.use(p);
      return current;
    }
    if (plugin instanceof Promise) {
      this.promisedModules.add(plugin.then((plugin2) => {
        if (typeof plugin2 === "function")
          return plugin2(this);
        if (plugin2 instanceof _Elysia)
          return this._use(plugin2);
        if (typeof plugin2.default === "function")
          return plugin2.default(this);
        if (plugin2.default instanceof _Elysia)
          return this._use(plugin2.default);
        throw new Error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.');
      }).then((x) => x.compile()));
      return this;
    }
    return this._use(plugin);
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      const instance = plugin(this);
      if (instance instanceof Promise) {
        this.promisedModules.add(instance.then((plugin2) => {
          if (plugin2 instanceof _Elysia) {
            this.compile();
            for (const {
              method,
              path,
              handler,
              hooks
            } of Object.values(plugin2.router.history)) {
              this.add(method, path, handler, mergeHook(hooks, {
                error: plugin2.event.error
              }));
            }
            return plugin2;
          }
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((x) => x.compile()));
        return this;
      }
      return instance;
    }
    if (plugin.promisedModules.size) {
      this.promisedModules.add(plugin.modules.then(() => this._use(plugin)).then((x) => x.compile()));
      return this;
    }
    const { name, seed } = plugin.config;
    plugin.getServer = () => this.getServer();
    plugin.model(this.definitions.type);
    plugin.error(this.definitions.error);
    const isScoped = plugin.config.scoped;
    if (isScoped) {
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          return this;
        this.dependencies[name].push(!this.config?.analytic ? {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies
        } : {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies,
          stack: plugin.telemetry.stack,
          routes: plugin.router.history,
          decorators: plugin.singleton.decorator,
          store: plugin.singleton.store,
          type: plugin.definitions.type,
          error: plugin.definitions.error,
          derive: plugin.event.transform.filter((x) => x.subType === "derive").map((x) => ({
            fn: x.fn.toString(),
            stack: new Error().stack ?? ""
          })),
          resolve: plugin.event.transform.filter((x) => x.subType === "derive").map((x) => ({
            fn: x.fn.toString(),
            stack: new Error().stack ?? ""
          }))
        });
      }
      plugin.extender.macros = this.extender.macros.concat(plugin.extender.macros);
      const macroHashes = [];
      for (let i = 0;i < plugin.extender.macros.length; i++) {
        const macro = this.extender.macros[i];
        if (macroHashes.includes(macro.checksum)) {
          plugin.extender.macros.splice(i, 1);
          i--;
        }
        macroHashes.push(macro.checksum);
      }
      plugin.onRequest((context) => {
        Object.assign(context, this.singleton.decorator);
        Object.assign(context.store, this.singleton.store);
      });
      if (plugin.event.trace.length)
        plugin.event.trace.push(...plugin.event.trace);
      if (!plugin.config.prefix)
        console.warn("It's recommended to use scoped instance with a prefix to prevent collision routing with other instance.");
      if (plugin.event.error.length)
        plugin.event.error.push(...this.event.error);
      if (plugin.config.aot)
        plugin.compile();
      if (isScoped === true && plugin.config.prefix) {
        this.mount(plugin.config.prefix + "/", plugin.fetch);
        for (const route of plugin.router.history) {
          this.routeTree.set(route.method + `${plugin.config.prefix}${route.path}`, this.router.history.length);
          this.router.history.push({
            ...route,
            path: `${plugin.config.prefix}${route.path}`,
            hooks: mergeHook(route.hooks, {
              error: this.event.error
            })
          });
        }
      } else {
        this.mount(plugin.fetch);
        for (const route of plugin.router.history) {
          this.routeTree.set(route.method + `${plugin.config.prefix}${route.path}`, this.router.history.length);
          this.router.history.push({
            ...route,
            path: `${plugin.config.prefix}${route.path}`,
            hooks: mergeHook(route.hooks, {
              error: this.event.error
            })
          });
        }
      }
      return this;
    } else {
      this.headers(plugin.setHeaders);
      plugin.reporter = this.reporter;
      for (const trace of plugin.event.trace)
        if (trace.scope && trace.scope !== "local")
          this.trace(trace);
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (!this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          this.extender.macros = this.extender.macros.concat(plugin.extender.macros);
      } else {
        this.extender.macros = this.extender.macros.concat(plugin.extender.macros);
      }
      const macroHashes = [];
      for (let i = 0;i < this.extender.macros.length; i++) {
        const macro = this.extender.macros[i];
        if (macro.checksum) {
          if (macroHashes.includes(macro.checksum)) {
            this.extender.macros.splice(i, 1);
            i--;
          }
          macroHashes.push(macro.checksum);
        }
      }
      this.inference = {
        event: {
          body: this.inference.event.body || plugin.inference.event.body,
          cookie: this.inference.event.cookie || plugin.inference.event.cookie,
          headers: this.inference.event.headers || plugin.inference.event.headers,
          queries: [
            ...this.inference.event.queries,
            ...plugin.inference.event.queries
          ],
          query: this.inference.event.query || plugin.inference.event.query,
          set: this.inference.event.set || plugin.inference.event.set,
          unknownQueries: this.inference.event.unknownQueries || plugin.inference.event.unknownQueries
        },
        trace: {
          request: this.inference.trace.request || plugin.inference.trace.request,
          parse: this.inference.trace.parse || plugin.inference.trace.parse,
          transform: this.inference.trace.transform || plugin.inference.trace.transform,
          handle: this.inference.trace.handle || plugin.inference.trace.handle,
          beforeHandle: this.inference.trace.beforeHandle || plugin.inference.trace.beforeHandle,
          afterHandle: this.inference.trace.afterHandle || plugin.inference.trace.afterHandle,
          error: this.inference.trace.error || plugin.inference.trace.error,
          context: this.inference.trace.context || plugin.inference.trace.context,
          store: this.inference.trace.store || plugin.inference.trace.store,
          set: this.inference.trace.set || plugin.inference.trace.set
        }
      };
    }
    this.decorate(plugin.singleton.decorator);
    this.state(plugin.singleton.store);
    this.model(plugin.definitions.type);
    this.error(plugin.definitions.error);
    for (const { method, path, handler, hooks } of Object.values(plugin.router.history)) {
      this.add(method, path, handler, mergeHook(hooks, {
        error: plugin.event.error
      }));
    }
    if (!isScoped)
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          return this;
        this.dependencies[name].push(!this.config?.analytic ? {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies
        } : {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies,
          stack: plugin.telemetry.stack,
          routes: plugin.router.history,
          decorators: plugin.singleton,
          store: plugin.singleton.store,
          type: plugin.definitions.type,
          error: plugin.definitions.error,
          derive: plugin.event.transform.filter((x) => x?.subType === "derive").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          })),
          resolve: plugin.event.transform.filter((x) => x?.subType === "resolve").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          }))
        });
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current);
      } else {
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
      }
    return this;
  }
  macro(macro) {
    const hook = {
      checksum: checksum(JSON.stringify({
        name: this.config.name,
        seed: this.config.seed,
        content: macro.toString()
      })),
      fn: macro
    };
    this.extender.macros.push(hook);
    return this;
  }
  mount(path, handle) {
    if (path instanceof _Elysia || typeof path === "function" || path.length === 0 || path === "/") {
      const run = typeof path === "function" ? path : path instanceof _Elysia ? path.compile().fetch : handle instanceof _Elysia ? handle.compile().fetch : handle;
      const handler2 = async ({ request, path: path2 }) => run(new Request(replaceUrlPath(request.url, path2 || "/"), request));
      this.all("/*", handler2, {
        type: "none"
      });
      return this;
    }
    const length = path.length;
    if (handle instanceof _Elysia)
      handle = handle.compile().fetch;
    const handler = async ({ request, path: path2 }) => handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), request));
    this.all(path, handler, {
      type: "none"
    });
    this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, {
      type: "none"
    });
    return this;
  }
  get(path, handler, hook) {
    this.add("GET", path, handler, hook);
    return this;
  }
  post(path, handler, hook) {
    this.add("POST", path, handler, hook);
    return this;
  }
  put(path, handler, hook) {
    this.add("PUT", path, handler, hook);
    return this;
  }
  patch(path, handler, hook) {
    this.add("PATCH", path, handler, hook);
    return this;
  }
  delete(path, handler, hook) {
    this.add("DELETE", path, handler, hook);
    return this;
  }
  options(path, handler, hook) {
    this.add("OPTIONS", path, handler, hook);
    return this;
  }
  all(path, handler, hook) {
    this.add("ALL", path, handler, hook);
    return this;
  }
  head(path, handler, hook) {
    this.add("HEAD", path, handler, hook);
    return this;
  }
  connect(path, handler, hook) {
    this.add("CONNECT", path, handler, hook);
    return this;
  }
  route(method, path, handler, hook) {
    this.add(method.toUpperCase(), path, handler, hook, hook?.config);
    return this;
  }
  ws(path, options) {
    const transform7 = options.transformMessage ? Array.isArray(options.transformMessage) ? options.transformMessage : [options.transformMessage] : undefined;
    let server = null;
    const validateMessage = getSchemaValidator(options?.body, {
      models: this.definitions.type,
      normalize: this.config.normalize
    });
    const validateResponse = getSchemaValidator(options?.response, {
      models: this.definitions.type,
      normalize: this.config.normalize
    });
    const parseMessage = (message) => {
      if (typeof message === "string") {
        const start = message?.charCodeAt(0);
        if (start === 47 || start === 123)
          try {
            message = JSON.parse(message);
          } catch {
          }
        else if (isNumericString(message))
          message = +message;
      }
      if (transform7?.length)
        for (let i = 0;i < transform7.length; i++) {
          const temp = transform7[i](message);
          if (temp !== undefined)
            message = temp;
        }
      return message;
    };
    this.route("$INTERNALWS", path, (context) => {
      const { set: set2, path: path2, qi, headers, query, params } = context;
      if (server === null)
        server = this.getServer();
      if (server?.upgrade(context.request, {
        headers: typeof options.upgrade === "function" ? options.upgrade(context) : options.upgrade,
        data: {
          validator: validateResponse,
          open(ws) {
            options.open?.(new ElysiaWS(ws, context));
          },
          message: (ws, msg) => {
            const message = parseMessage(msg);
            if (validateMessage?.Check(message) === false)
              return void ws.send(new ValidationError("message", validateMessage, message).message);
            options.message?.(new ElysiaWS(ws, context), message);
          },
          drain(ws) {
            options.drain?.(new ElysiaWS(ws, context));
          },
          close(ws, code, reason) {
            options.close?.(new ElysiaWS(ws, context), code, reason);
          }
        }
      }))
        return;
      set2.status = 400;
      return "Expected a websocket connection";
    }, {
      beforeHandle: options.beforeHandle,
      transform: options.transform,
      headers: options.headers,
      params: options.params,
      query: options.query
    });
    return this;
  }
  state(name, value15) {
    switch (typeof name) {
      case "object":
        this.singleton.store = mergeDeep(this.singleton.store, name);
        return this;
      case "function":
        this.singleton.store = name(this.singleton.store);
        return this;
    }
    if (!(name in this.singleton.store)) {
      this.singleton.store[name] = value15;
    }
    return this;
  }
  decorate(name, value15) {
    switch (typeof name) {
      case "object":
        this.singleton.decorator = mergeDeep(this.singleton.decorator, name);
        return this;
      case "function":
        this.singleton.decorator = name(this.singleton.decorator);
        return this;
    }
    if (!(name in this.singleton.decorator))
      this.singleton.decorator[name] = value15;
    return this;
  }
  derive(optionsOrTransform, transform7) {
    if (!transform7) {
      transform7 = optionsOrTransform;
      optionsOrTransform = { as: "local" };
    }
    const hook = {
      subType: "derive",
      fn: transform7
    };
    return this.onTransform(optionsOrTransform, hook);
  }
  model(name, model) {
    switch (typeof name) {
      case "object":
        Object.entries(name).forEach(([key, value15]) => {
          if (!(key in this.definitions.type))
            this.definitions.type[key] = value15;
        });
        return this;
      case "function":
        this.definitions.type = name(this.definitions.type);
        return this;
    }
    this.definitions.type[name] = model;
    return this;
  }
  mapDerive(optionsOrDerive, mapper) {
    if (!mapper) {
      mapper = optionsOrDerive;
      optionsOrDerive = { as: "local" };
    }
    const hook = {
      subType: "derive",
      fn: mapper
    };
    return this.onTransform(optionsOrDerive, hook);
  }
  affix(base, type74, word) {
    if (word === "")
      return this;
    const delimieter = ["_", "-", " "];
    const capitalize2 = (word2) => word2[0].toUpperCase() + word2.slice(1);
    const joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize2(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize2(suffix);
    const remap = (type210) => {
      const store = {};
      switch (type210) {
        case "decorator":
          for (const key in this.singleton.decorator) {
            store[joinKey(word, key)] = this.singleton.decorator[key];
          }
          this.singleton.decorator = store;
          break;
        case "state":
          for (const key in this.singleton.store)
            store[joinKey(word, key)] = this.singleton.store[key];
          this.singleton.store = store;
          break;
        case "model":
          for (const key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (const key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    };
    const types = Array.isArray(type74) ? type74 : [type74];
    for (const type210 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type210);
    return this;
  }
  prefix(type74, word) {
    return this.affix("prefix", type74, word);
  }
  suffix(type74, word) {
    return this.affix("suffix", type74, word);
  }
  compile() {
    this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this);
    if (typeof this.server?.reload === "function")
      this.server.reload({
        ...this.server || {},
        fetch: this.fetch
      });
    return this;
  }
  get modules() {
    return Promise.all(this.promisedModules.promises);
  }
};

// node_modules/zod/lib/index.mjs
var setErrorMap = function(map3) {
  overrideErrorMap = map3;
};
var getErrorMap = function() {
  return overrideErrorMap;
};
var addIssueToContext = function(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
};
var processCreateParams = function(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== undefined ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== undefined ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
};
var isValidIP = function(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
};
var floatSafeRemainder = function(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
};
var deepPartialify = function(schema3) {
  if (schema3 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema3.shape) {
      const fieldSchema = schema3.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema3._def,
      shape: () => newShape
    });
  } else if (schema3 instanceof ZodArray) {
    return new ZodArray({
      ...schema3._def,
      type: deepPartialify(schema3.element)
    });
  } else if (schema3 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodTuple) {
    return ZodTuple.create(schema3.items.map((item) => deepPartialify(item)));
  } else {
    return schema3;
  }
};
var mergeValues = function(a2, b) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b);
  if (a2 === b) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
};
var createZodEnum = function(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object13) => {
    const keys = [];
    for (const key in object13) {
      if (Object.prototype.hasOwnProperty.call(object13, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array5, separator = " | ") {
    return array5.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value15) => {
    if (typeof value15 === "bigint") {
      return value15.toString();
    }
    return value15;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t3 = typeof data;
  switch (t3) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error23) => {
      for (const issue of error23.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error23 = new ZodError(issues);
  return error23;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map3 of maps) {
    errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value15 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value15.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value15.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value15.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value15.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value15) => ({ status: "dirty", value: value15 });
var OK = (value15) => ({ status: "valid", value: value15 });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync2 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
  constructor(parent, value15, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value15;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error23 = new ZodError(ctx.common.issues);
        this._error = error23;
        return this._error;
      }
    };
  }
};

class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync2(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync2(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check11, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check11(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check11, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check11(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform7) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform7 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+\$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z\$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z\$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z\$`);
    }
  }
};

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check11 of this._def.checks) {
      if (check11.kind === "min") {
        if (input.data.length < check11.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check11.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "max") {
        if (input.data.length > check11.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check11.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "length") {
        const tooBig = input.data.length > check11.value;
        const tooSmall = input.data.length < check11.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check11.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check11.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check11.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check11.message
            });
          }
          status.dirty();
        }
      } else if (check11.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "regex") {
        check11.regex.lastIndex = 0;
        const testResult = check11.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "trim") {
        input.data = input.data.trim();
      } else if (check11.kind === "includes") {
        if (!input.data.includes(check11.value, check11.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check11.value, position: check11.position },
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check11.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check11.kind === "startsWith") {
        if (!input.data.startsWith(check11.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check11.value },
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "endsWith") {
        if (!input.data.endsWith(check11.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check11.value },
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "datetime") {
        const regex2 = datetimeRegex(check11);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "ip") {
        if (!isValidIP(input.data, check11.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check11);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data) => regex2.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check11) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check11]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value15, options) {
    return this._addCheck({
      kind: "includes",
      value: value15,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value15, message) {
    return this._addCheck({
      kind: "startsWith",
      value: value15,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value15, message) {
    return this._addCheck({
      kind: "endsWith",
      value: value15,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check11 of this._def.checks) {
      if (check11.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "min") {
        const tooSmall = check11.inclusive ? input.data < check11.value : input.data <= check11.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check11.value,
            type: "number",
            inclusive: check11.inclusive,
            exact: false,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "max") {
        const tooBig = check11.inclusive ? input.data > check11.value : input.data >= check11.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check11.value,
            type: "number",
            inclusive: check11.inclusive,
            exact: false,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check11.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check11.value,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check11.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check11);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value15, message) {
    return this.setLimit("min", value15, true, errorUtil.toString(message));
  }
  gt(value15, message) {
    return this.setLimit("min", value15, false, errorUtil.toString(message));
  }
  lte(value15, message) {
    return this.setLimit("max", value15, true, errorUtil.toString(message));
  }
  lt(value15, message) {
    return this.setLimit("max", value15, false, errorUtil.toString(message));
  }
  setLimit(kind, value15, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value15,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check11) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check11]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value15, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value15,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check11 of this._def.checks) {
      if (check11.kind === "min") {
        const tooSmall = check11.inclusive ? input.data < check11.value : input.data <= check11.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check11.value,
            inclusive: check11.inclusive,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "max") {
        const tooBig = check11.inclusive ? input.data > check11.value : input.data >= check11.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check11.value,
            inclusive: check11.inclusive,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "multipleOf") {
        if (input.data % check11.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check11.value,
            message: check11.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check11);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value15, message) {
    return this.setLimit("min", value15, true, errorUtil.toString(message));
  }
  gt(value15, message) {
    return this.setLimit("min", value15, false, errorUtil.toString(message));
  }
  lte(value15, message) {
    return this.setLimit("max", value15, true, errorUtil.toString(message));
  }
  lt(value15, message) {
    return this.setLimit("max", value15, false, errorUtil.toString(message));
  }
  setLimit(kind, value15, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value15,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check11) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check11]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value15, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value15,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check11 of this._def.checks) {
      if (check11.kind === "min") {
        if (input.data.getTime() < check11.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check11.message,
            inclusive: true,
            exact: false,
            minimum: check11.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check11.kind === "max") {
        if (input.data.getTime() > check11.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check11.message,
            inclusive: true,
            exact: false,
            maximum: check11.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check11);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check11) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check11]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema3, params) => {
  return new ZodArray({
    type: schema3,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value15 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value15, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value15 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value15, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema3) {
    return this.augment({ [key]: schema3 });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type74) => {
  if (type74 instanceof ZodLazy) {
    return getDiscriminator(type74.schema);
  } else if (type74 instanceof ZodEffects) {
    return getDiscriminator(type74.innerType());
  } else if (type74 instanceof ZodLiteral) {
    return [type74.value];
  } else if (type74 instanceof ZodEnum) {
    return type74.options;
  } else if (type74 instanceof ZodNativeEnum) {
    return Object.keys(type74.enum);
  } else if (type74 instanceof ZodDefault) {
    return getDiscriminator(type74._def.innerType);
  } else if (type74 instanceof ZodUndefined) {
    return [undefined];
  } else if (type74 instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type74 of options) {
      const discriminatorValues = getDiscriminator(type74.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value15 of discriminatorValues) {
        if (optionsMap.has(value15)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value15)}`);
        }
        optionsMap.set(value15, type74);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest4 = this._def.rest;
    if (!rest4 && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema3 = this._def.items[itemIndex] || this._def.rest;
      if (!schema3)
        return null;
      return schema3._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest4) {
    return new ZodTuple({
      ...this._def,
      rest: rest4
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value15], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value15, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value15 = await pair.value;
          if (key.status === "aborted" || value15.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value15.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value15.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value15 = pair.value;
        if (key.status === "aborted" || value15.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value15.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value15.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error23) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error23
        }
      });
    }
    function makeReturnsIssue(returns, error23) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error23
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error23 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e2) => {
          error23.addIssue(makeArgsIssue(args, e2));
          throw error23;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error23.addIssue(makeReturnsIssue(result, e2));
          throw error23;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value15, params) => {
  return new ZodLiteral({
    value: value15,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema3, params) => {
  return new ZodPromise({
    type: schema3,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema3, effect, params) => {
  return new ZodEffects({
    schema: schema3,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema3, params) => {
  return new ZodEffects({
    schema: schema3,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type74, params) => {
  return new ZodOptional({
    innerType: type74,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type74, params) => {
  return new ZodNullable({
    innerType: type74,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type74, params) => {
  return new ZodDefault({
    innerType: type74,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync2(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type74, params) => {
  return new ZodCatch({
    innerType: type74,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b) {
    return new ZodPipeline({
      in: a2,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type74, params) => {
  return new ZodReadonly({
    innerType: type74,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check11, params = {}, fatal) => {
  if (check11)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check11(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync: isAsync2,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/schemas/Temp_Schema.ts
var Temp_Schema = z.object({
  name: z.string().min(5),
  email: z.string().email("Email doesn't look like an email."),
  url: z.string().url("Url doesn't look like a url.")
});

// src/utils/generateTempObject.ts
var generateTempObject = () => {
  const x = {
    name: "Young J",
    email: "jrlbidamin@gmail.com",
    url: "https://lundlabs.xyz"
  };
  return Temp_Schema.parse(x);
};

// src/utils/returnSchema.ts
var returnSchema = () => {
  const obj = {
    name: "Young J",
    email: "jrlbidamin@gmail.com",
    url: "https://lundlabs.xyz"
  };
  return { data: obj, schema: Temp_Schema };
};

// node_modules/@elysiajs/swagger/dist/swagger/index.js
var SwaggerUIRender = (info, version, theme, stringifiedSwaggerOptions, autoDarkMode) => `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    ${autoDarkMode && typeof theme === "string" ? `
    <style>
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #222;
                color: #faf9a;
            }
            .swagger-ui {
                filter: invert(92%) hue-rotate(180deg);
            }

            .swagger-ui .microlight {
                filter: invert(100%) hue-rotate(180deg);
            }
        }
    </style>` : ""}
    ${typeof theme === "string" ? `<link rel="stylesheet" href="${theme}" />` : `<link rel="stylesheet" media="(prefers-color-scheme: light)" href="${theme.light}" />
<link rel="stylesheet" media="(prefers-color-scheme: dark)" href="${theme.dark}" />`}
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@${version}/swagger-ui-bundle.js" crossorigin></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle(${stringifiedSwaggerOptions});
        };
    </script>
</body>
</html>`;

// node_modules/@elysiajs/swagger/dist/scalar/theme.js
var theme_default = `
/* basic theme */
.light-mode {
  --theme-color-1: #2a2f45;
  --theme-color-2: #757575;
  --theme-color-3: #8e8e8e;
  --theme-color-accent: #f06292;

  --theme-background-1: #fff;
  --theme-background-2: #f6f6f6;
  --theme-background-3: #e7e7e7;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --theme-color-1: rgba(255, 255, 255, 0.9);
  --theme-color-2: rgba(156, 163, 175, 1);
  --theme-color-3: rgba(255, 255, 255, 0.44);
  --theme-color-accent: #f06292;

  --theme-background-1: #111728;
  --theme-background-2: #1e293b;
  --theme-background-3: #334155;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(255, 255, 255, 0.1);
}
/* Document Sidebar */
.light-mode .sidebar,
.dark-mode .sidebar {
  --sidebar-background-1: var(--theme-background-1);
  --sidebar-item-hover-color: currentColor;
  --sidebar-item-hover-background: var(--theme-background-2);
  --sidebar-item-active-background: var(--theme-background-accent);
  --sidebar-border-color: transparent;
  --sidebar-color-1: var(--theme-color-1);
  --sidebar-color-2: var(--theme-color-2);
  --sidebar-color-active: var(--theme-color-accent);
  --sidebar-search-background: transparent;
  --sidebar-search-border-color: var(--theme-border-color);
  --sidebar-search--color: var(--theme-color-3);
}
/* Document header only shows on mobile*/
.dark-mode .t-doc__header,
.light-mode .t-doc__header {
  --header-background-1: rgba(255, 255, 255, 0.85);
  --header-border-color: transparent;
  --header-color-1: var(--theme-color-1);
  --header-color-2: var(--theme-color-2);
  --header-background-toggle: var(--theme-color-3);
  --header-call-to-action-color: var(--theme-color-accent);
}

.dark-mode .t-doc__header {
  --header-background-1: rgba(17, 23, 40, 0.75);
}

/* advanced */
.light-mode {
  --theme-button-1: rgb(49 53 56);
  --theme-button-1-color: #fff;
  --theme-button-1-hover: rgb(28 31 33);

  --theme-color-green: #069061;
  --theme-color-red: #ef0006;
  --theme-color-yellow: #edbe20;
  --theme-color-blue: #0082d0;
  --theme-color-orange: #fb892c;
  --theme-color-purple: #5203d1;

  --theme-scrollbar-color: rgba(0, 0, 0, 0.18);
  --theme-scrollbar-color-active: rgba(0, 0, 0, 0.36);
}
.dark-mode {
  --theme-button-1: #f6f6f6;
  --theme-button-1-color: #000;
  --theme-button-1-hover: #e7e7e7;

  --theme-color-green: #a3ffa9;
  --theme-color-red: #ffa3a3;
  --theme-color-yellow: #fffca3;
  --theme-color-blue: #a5d6ff;
  --theme-color-orange: #e2ae83;
  --theme-color-purple: #d2a8ff;

  --theme-scrollbar-color: rgba(255, 255, 255, 0.24);
  --theme-scrollbar-color-active: rgba(255, 255, 255, 0.48);
}
/* Elysia Specific */
.scalar-api-client__send-request-button,
.show-api-client-button {
  background: #3c82f6 !important;
}
.show-api-client-button:before {
  display: none;
}

.sidebar-search:hover {
  transition: all 0.15s ease-in-out;
  --sidebar-search-border-color: var(--theme-color-accent) !important;
  color: var(--sidebar-color-1) !important;
}
.scalar-api-client__container .sidebar {
  --sidebar-border-color: var(--theme-border-color);
}
@media (min-width: 1150px) {
  .section-container:has( ~ .footer):before,
  .tag-section-container:before {
    content: "";
    position: absolute;
    top: -5px;
    left: 0;
    width: 100%;
    height: 10px;
    background: linear-gradient(90deg, var(--theme-background-1) 3%,transparent 10%);
  }
}
.section-flare {
  position: absolute;
  width: 100vw;
  height: 300px;
  --stripes: repeating-linear-gradient(
    100deg,
    #fff 0%,
    #fff 7%,
    transparent 10%,
    transparent 12%,
    #fff 16%
  );
  --stripesDark: repeating-linear-gradient(
    100deg,
    #000 0%,
    #000 7%,
    transparent 10%,
    transparent 12%,
    #000 16%
  );
  --rainbow: repeating-linear-gradient(
    100deg,
    #60a5fa 10%,
    #e879f9 16%,
    #5eead4 22%,
    #60a5fa 30%
  );
  background-image: var(--stripes), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: invert(100%);
  -webkit-mask-image: radial-gradient(
    ellipse at 100% 0%,
    black 40%,
    transparent 70%
  );
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
  opacity: 0.15;
}
.dark-mode .section-flare {
  background-image: var(--stripesDark), var(--rainbow);
  filter: opacity(50%) saturate(200%);
  opacity: 0.25;
}
.section-flare:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripes), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
}
.dark-mode .section-flare:after {
  background-image: var(--stripesDark), var(--rainbow);
}
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.light-mode .t-doc__header,
.dark-mode .t-doc__header {
  animation: headerbackground forwards;
  animation-timeline: scroll();
  animation-range: 0px 200px;
  --header-border-color: transparent;
}
`;

// node_modules/@elysiajs/swagger/dist/scalar/index.js
var ScalarRender = (version, config2, cdn) => `<!doctype html>
<html>
  <head>
    <title>API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
      }
    </style>
    <style>
      ${config2.customCss ?? theme_default}
    </style>
  </head>
  <body>
    <script
      id="api-reference"
      data-url="${config2.spec?.url}"
      data-configuration='${JSON.stringify(config2)}'
    >
    </script>
    <script src="${cdn ? cdn : `https://cdn.jsdelivr.net/npm/@scalar/api-reference@${version}/dist/browser/standalone.min.js`}"></script>
  </body>
</html>`;

// node_modules/@elysiajs/swagger/dist/utils.js
var import_lodash = __toESM(require_lodash(), 1);
var toOpenAPIPath = (path) => path.split("/").map((x) => x.startsWith(":") ? `{${x.slice(1, x.length)}}` : x).join("/");
var mapProperties = (name, schema3, models) => {
  if (schema3 === undefined)
    return [];
  if (typeof schema3 === "string")
    if (schema3 in models)
      schema3 = models[schema3];
    else
      throw new Error(`Can't find model ${schema3}`);
  return Object.entries(schema3?.properties ?? []).map(([key, value15]) => {
    const { type: valueType = undefined, ...rest4 } = value15;
    return {
      ...rest4,
      schema: { type: valueType },
      in: name,
      name: key,
      required: schema3.required?.includes(key) ?? false
    };
  });
};
var mapTypesResponse = (types, schema3) => {
  if (typeof schema3 === "object" && ["void", "undefined", "null"].includes(schema3.type))
    return;
  const responses = {};
  for (const type74 of types)
    responses[type74] = {
      schema: typeof schema3 === "string" ? {
        $ref: `#/components/schemas/${schema3}`
      } : { ...schema3 }
    };
  return responses;
};
var capitalize2 = (word) => word.charAt(0).toUpperCase() + word.slice(1);
var generateOperationId = (method, paths) => {
  let operationId = method.toLowerCase();
  if (paths === "/")
    return operationId + "Index";
  for (const path of paths.split("/")) {
    if (path.charCodeAt(0) === 123) {
      operationId += "By" + capitalize2(path.slice(1, -1));
    } else {
      operationId += capitalize2(path);
    }
  }
  return operationId;
};
var registerSchemaPath = ({ schema: schema3, path, method, hook, models }) => {
  if (hook)
    hook = import_lodash.default(hook);
  const contentType = hook?.type ?? [
    "application/json",
    "multipart/form-data",
    "text/plain"
  ];
  path = toOpenAPIPath(path);
  const contentTypes = typeof contentType === "string" ? [contentType] : contentType ?? ["application/json"];
  const bodySchema = hook?.body;
  const paramsSchema = hook?.params;
  const headerSchema = hook?.headers;
  const querySchema = hook?.query;
  let responseSchema = hook?.response;
  if (typeof responseSchema === "object") {
    if (Kind in responseSchema) {
      const { type: type74, properties, required: required5, additionalProperties, patternProperties, ...rest4 } = responseSchema;
      responseSchema = {
        "200": {
          ...rest4,
          description: rest4.description,
          content: mapTypesResponse(contentTypes, type74 === "object" || type74 === "array" ? {
            type: type74,
            properties,
            patternProperties,
            items: responseSchema.items,
            required: required5
          } : responseSchema)
        }
      };
    } else {
      Object.entries(responseSchema).forEach(([key, value15]) => {
        if (typeof value15 === "string") {
          if (!models[value15])
            return;
          const { type: type74, properties, required: required5, additionalProperties: _1, patternProperties: _2, ...rest4 } = models[value15];
          responseSchema[key] = {
            ...rest4,
            description: rest4.description,
            content: mapTypesResponse(contentTypes, value15)
          };
        } else {
          const { type: type74, properties, required: required5, additionalProperties, patternProperties, ...rest4 } = value15;
          responseSchema[key] = {
            ...rest4,
            description: rest4.description,
            content: mapTypesResponse(contentTypes, type74 === "object" || type74 === "array" ? {
              type: type74,
              properties,
              patternProperties,
              items: value15.items,
              required: required5
            } : value15)
          };
        }
      });
    }
  } else if (typeof responseSchema === "string") {
    if (!(responseSchema in models))
      return;
    const { type: type74, properties, required: required5, additionalProperties: _1, patternProperties: _2, ...rest4 } = models[responseSchema];
    responseSchema = {
      "200": {
        ...rest4,
        content: mapTypesResponse(contentTypes, responseSchema)
      }
    };
  }
  const parameters4 = [
    ...mapProperties("header", headerSchema, models),
    ...mapProperties("path", paramsSchema, models),
    ...mapProperties("query", querySchema, models)
  ];
  schema3[path] = {
    ...schema3[path] ? schema3[path] : {},
    [method.toLowerCase()]: {
      ...headerSchema || paramsSchema || querySchema || bodySchema ? { parameters: parameters4 } : {},
      ...responseSchema ? {
        responses: responseSchema
      } : {},
      operationId: hook?.detail?.operationId ?? generateOperationId(method, path),
      ...hook?.detail,
      ...bodySchema ? {
        requestBody: {
          content: mapTypesResponse(contentTypes, typeof bodySchema === "string" ? {
            $ref: `#/components/schemas/${bodySchema}`
          } : bodySchema)
        }
      } : null
    }
  };
};
var filterPaths = (paths, { excludeStaticFile = true, exclude: exclude6 = [] }) => {
  const newPaths = {};
  for (const [key, value15] of Object.entries(paths))
    if (!exclude6.some((x) => {
      if (typeof x === "string")
        return key === x;
      return x.test(key);
    }) && !key.includes("/swagger") && !key.includes("*") && (excludeStaticFile ? !key.includes(".") : true)) {
      Object.keys(value15).forEach((method) => {
        const schema3 = value15[method];
        if (key.includes("{")) {
          if (!schema3.parameters)
            schema3.parameters = [];
          schema3.parameters = [
            ...key.split("/").filter((x) => x.startsWith("{") && !schema3.parameters.find((params) => params.in === "path" && params.name === x.slice(1, x.length - 1))).map((x) => ({
              schema: { type: "string" },
              in: "path",
              name: x.slice(1, x.length - 1),
              required: true
            })),
            ...schema3.parameters
          ];
        }
        if (!schema3.responses)
          schema3.responses = {
            200: {}
          };
      });
      newPaths[key] = value15;
    }
  return newPaths;
};

// node_modules/@elysiajs/swagger/dist/index.js
var swagger2 = ({ provider = "scalar", scalarVersion = "latest", scalarCDN = "", scalarConfig = {}, documentation = {}, version = "5.9.0", excludeStaticFile = true, path = "/swagger", exclude: exclude6 = [], swaggerOptions = {}, theme: theme2 = `https://unpkg.com/swagger-ui-dist@${version}/swagger-ui.css`, autoDarkMode = true, excludeMethods = ["OPTIONS"] } = {
  provider: "scalar",
  scalarVersion: "latest",
  scalarCDN: "",
  scalarConfig: {},
  documentation: {},
  version: "5.9.0",
  excludeStaticFile: true,
  path: "/swagger",
  exclude: [],
  swaggerOptions: {},
  autoDarkMode: true,
  excludeMethods: ["OPTIONS"]
}) => (app) => {
  const schema3 = {};
  let totalRoutes = 0;
  if (!version)
    version = `https://unpkg.com/swagger-ui-dist@${version}/swagger-ui.css`;
  const info = {
    title: "Elysia Documentation",
    description: "Development documentation",
    version: "0.0.0",
    ...documentation.info
  };
  const relativePath = path.startsWith("/") ? path.slice(1) : path;
  app.get(path, () => {
    const combinedSwaggerOptions = {
      url: `${relativePath}/json`,
      dom_id: "#swagger-ui",
      ...swaggerOptions
    };
    const stringifiedSwaggerOptions = JSON.stringify(combinedSwaggerOptions, (key, value15) => {
      if (typeof value15 == "function")
        return;
      return value15;
    });
    const scalarConfiguration = {
      spec: {
        ...scalarConfig.spec,
        url: `${relativePath}/json`
      },
      ...scalarConfig
    };
    return new Response(provider === "swagger-ui" ? SwaggerUIRender(info, version, theme2, stringifiedSwaggerOptions, autoDarkMode) : ScalarRender(scalarVersion, scalarConfiguration, scalarCDN), {
      headers: {
        "content-type": "text/html; charset=utf8"
      }
    });
  }).get(`${path}/json`, () => {
    const routes = app.routes;
    if (routes.length !== totalRoutes) {
      totalRoutes = routes.length;
      routes.forEach((route) => {
        if (excludeMethods.includes(route.method))
          return;
        registerSchemaPath({
          schema: schema3,
          hook: route.hooks,
          method: route.method,
          path: route.path,
          models: app.definitions?.type,
          contentType: route.hooks.type
        });
      });
    }
    return {
      openapi: "3.0.3",
      ...{
        ...documentation,
        info: {
          title: "Elysia Documentation",
          description: "Development documentation",
          version: "0.0.0",
          ...documentation.info
        }
      },
      paths: filterPaths(schema3, {
        excludeStaticFile,
        exclude: Array.isArray(exclude6) ? exclude6 : [exclude6]
      }),
      components: {
        ...documentation.components,
        schemas: {
          ...app.definitions?.type,
          ...documentation.components?.schemas
        }
      }
    };
  });
  return app;
};

// node_modules/@elysiajs/cors/dist/index.js
var processOrigin = (origin, request, from) => {
  if (Array.isArray(origin))
    return origin.some((o) => processOrigin(o, request, from));
  switch (typeof origin) {
    case "string":
      const protocolStart = from.indexOf("://");
      if (protocolStart !== -1)
        from = from.slice(protocolStart + 3);
      const trailingSlash = from.indexOf("/", 0);
      if (trailingSlash !== -1)
        from = from.slice(trailingSlash);
      return origin === from;
    case "function":
      return origin(request) === true;
    case "object":
      if (origin instanceof RegExp)
        return origin.test(from);
  }
  return false;
};
var cors = (config2) => {
  let { aot = true, origin = "*", methods = "*", allowedHeaders = "*", exposedHeaders = "*", credentials = true, maxAge = 5, preflight = true } = config2 ?? {};
  if (Array.isArray(allowedHeaders))
    allowedHeaders = allowedHeaders.join(", ");
  if (Array.isArray(exposedHeaders))
    exposedHeaders = exposedHeaders.join(", ");
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const app = new Elysia({
    name: "@elysiajs/cors",
    seed: config2,
    aot
  });
  const anyOrigin = origins?.some((o) => o === "*");
  const handleOrigin = (set2, request) => {
    if (origin === true) {
      set2.headers["Vary"] = "*";
      set2.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (anyOrigin) {
      set2.headers["Vary"] = "*";
      set2.headers["Access-Control-Allow-Origin"] = "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i = 0;i < origins.length; i++) {
        const value15 = processOrigin(origins[i], request, from);
        if (value15 === true) {
          set2.headers["Vary"] = origin ? "Origin" : "*";
          set2.headers["Access-Control-Allow-Origin"] = from || "*";
          return;
        }
        if (value15)
          headers.push(value15);
      }
    }
    set2.headers["Vary"] = "Origin";
    set2.headers["Access-Control-Allow-Origin"] = headers.join(", ");
  };
  const handleMethod = (set2, method) => {
    if (methods === true)
      return set2.headers["Access-Control-Allow-Methods"] = method ?? "*";
    if (methods === false || !methods?.length)
      return;
    if (methods === "*")
      return set2.headers["Access-Control-Allow-Methods"] = "*";
    if (!Array.isArray(methods))
      return set2.headers["Access-Control-Allow-Methods"] = methods;
    set2.headers["Access-Control-Allow-Methods"] = methods.join(", ");
  };
  if (preflight)
    app.options("/", ({ set: set2, request }) => {
      handleOrigin(set2, request);
      handleMethod(set2, request.method);
      if (allowedHeaders.length)
        set2.headers["Access-Control-Allow-Headers"] = allowedHeaders;
      if (exposedHeaders.length)
        set2.headers["Access-Control-Expose-Headers"] = exposedHeaders;
      if (maxAge)
        set2.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response(null, {
        status: 204
      });
    }).options("/*", ({ set: set2, request }) => {
      handleOrigin(set2, request);
      handleMethod(set2, request.method);
      if (allowedHeaders.length)
        set2.headers["Access-Control-Allow-Headers"] = allowedHeaders;
      if (exposedHeaders.length)
        set2.headers["Access-Control-Expose-Headers"] = exposedHeaders;
      if (maxAge)
        set2.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response(null, {
        status: 204
      });
    });
  const defaultHeaders = {
    "Access-Control-Allow-Headers": allowedHeaders,
    "Access-Control-Exposed-Headers": exposedHeaders
  };
  if (credentials === true)
    defaultHeaders["Access-Control-Allow-Credentials"] = "true";
  return app.headers(defaultHeaders).onRequest(({ set: set2, request }) => {
    handleOrigin(set2, request);
    handleMethod(set2, request.method);
    if (allowedHeaders.length)
      set2.headers["Access-Control-Allow-Headers"] = allowedHeaders;
    if (exposedHeaders.length)
      set2.headers["Access-Control-Expose-Headers"] = exposedHeaders;
  });
};

// node_modules/elysia-compression/dist/index.js
var import_compressible = __toESM(require_compressible(), 1);
var {gzipSync, deflateSync } = globalThis.Bun;

// node_modules/elysia-compression/dist/stream.js
import zlib from "zlib";

class CompressionStream {
  readable;
  writable;
  constructor(format) {
    const handle = format === "deflate" ? zlib.createDeflate() : format === "gzip" ? zlib.createGzip() : zlib.createDeflateRaw();
    this.readable = new ReadableStream({
      start(controller) {
        handle.on("data", (chunk) => controller.enqueue(chunk));
        handle.once("end", () => controller.close());
      }
    });
    this.writable = new WritableStream({
      write: (chunk) => handle.write(chunk),
      close: () => handle.end()
    });
  }
}

// node_modules/elysia-compression/dist/utils.js
var isReadableStream = (value15) => value15 instanceof ReadableStream;

// node_modules/elysia-compression/dist/index.js
var shouldCompress = (res) => {
  const type74 = res.headers.get("Content-Type");
  if (!type74) {
    return false;
  }
  return import_compressible.default(type74) ?? false;
};
var toBuffer = (data, encoding) => Buffer.from(typeof data === "object" ? JSON.stringify(data) : data?.toString() ?? new String(data), encoding);
var compression = ({ type: type74 = "gzip", options = {}, encoding = "utf-8" } = {
  type: "gzip",
  encoding: "utf-8"
}) => {
  const app = new Elysia({
    name: "elysia-compression"
  });
  if (!["gzip", "deflate"].includes(type74)) {
    throw new Error("Invalid compression type. Use gzip or deflate.");
  }
  return app.onAfterHandle((ctx) => {
    ctx.set.headers["Content-Encoding"] = type74;
    const res = mapResponse(ctx.response, {
      status: 200,
      headers: {}
    });
    if (!res.headers.get("Content-Type")) {
      res.headers.set("Content-Type", "text/plain");
    }
    if (!shouldCompress(res)) {
      delete ctx.set.headers["Content-Encoding"];
      return ctx.response;
    }
    const stream2 = ctx.response?.stream;
    const compressedBody = isReadableStream(stream2) ? stream2.pipeThrough(new CompressionStream(type74)) : type74 === "gzip" ? gzipSync(toBuffer(ctx.response, encoding), options) : deflateSync(toBuffer(ctx.response, encoding), options);
    ctx.response = new Response(compressedBody, {
      headers: res.headers
    });
  });
};

// node_modules/@elysiajs/bearer/dist/index.js
var bearer = ({ extract: { body = "access_token", query: queryName = "access_token", header = "Bearer" } = {
  body: "access_token",
  query: "access_token",
  header: "Bearer"
} } = {
  extract: {
    body: "access_token",
    query: "access_token",
    header: "Bearer"
  }
}) => new Elysia({
  name: "@elysiajs/bearer",
  seed: {
    body,
    query: queryName,
    header
  }
}).derive({ as: "global" }, ({ query, headers: { authorization } }) => ({
  get bearer() {
    if (authorization?.startsWith(header))
      return authorization.slice(header.length + 1);
    const q = query[queryName];
    if (q)
      return q;
  }
}));
var dist_default = bearer;

// src/services/orm/init.ts
var client = __toESM(require_default2(), 1);
var ormOptions = {};
var prisma = new client.PrismaClient(ormOptions);

// src/services/orm/findFirst.ts
var findFirst = async (key, params) => {
  return await prisma[key].findFirst(params);
};

// src/services/orm/findMany.ts
var findMany = async (key, params) => {
  return await prisma[key].findMany(params);
};

// src/services/orm/create.ts
var create5 = async (key, params) => {
  return await prisma[key].create({ data: params });
};

// src/services/orm/update.ts
var update = async (key, params) => {
  return await prisma[key].update({ data: params });
};

// src/services/orm/delete.ts
var deleteOne = async (key, params) => {
  return await prisma[key].delete({ data: params });
};

// src/routes/schema.ts
var app = new Elysia({ prefix: "/schema" });
app.get("/:collection/:id", async ({ params: { collection, id }, query }) => {
  const k = collection;
  const result = await findFirst(k, { where: { ...query, id } });
  return result;
});
app.get("/:collection", async ({ params: { collection }, query }) => {
  const k = collection;
  const result = await findMany(k, query);
  return result;
});
app.post("/:collection", async ({ body, params: { collection } }) => {
  const k = collection;
  const result = await create5(k, body);
  return result;
});
app.patch("/:collection/:id", async ({ params: { collection, id }, query }) => {
  const k = collection;
  const result = await update(k, query);
  return result;
});
app.delete("/:collection/:id", async ({ params: { collection, id } }) => {
  console.log("James First hit");
  const k = collection;
  const result = await deleteOne(k, { id });
  return result;
});
app.delete("/:collection", async ({ params: { collection }, query }) => {
  console.log("James Query:", query);
  return query;
});
var schema_default = app;

// bin/introspection.ts
var Bun2 = globalThis.Bun;

// src/services/logger/log.ts
var log = (type74, msg) => {
  switch (type74) {
    case "error":
      console.error(msg);
    case "log":
      console.log(msg);
    case "table":
      console.log(msg);
    case "warn":
      console.log(msg);
  }
};

// bin/introspection.ts
var introspection = () => {
  const result = Bun2.spawnSync({ cmd: ["bun", "run", "prisma", "db", "pull"] });
  const buf = result.stdout;
  const str = buf.toString();
  const consoleMsg = result.success ? "Success" : "Error";
  log("log", `${consoleMsg} - ${str}`);
  return;
};

// src/routes/orm.ts
var app2 = new Elysia({ prefix: "/orm" });
app2.post("/introspect", async () => {
  introspection();
});
var orm_default = app2;

// src/utils/constants.ts
var ORM_DEFAULT_DB = "public";

// src/services/orm/getCollections.ts
var getCollections = async () => {
  const dbTables = await prisma.$queryRaw`
  select table_name
  from information_schema.tables
  where table_type='BASE TABLE'
    and table_schema = ${ORM_DEFAULT_DB}
    and table_name NOT in ('_prisma_migrations', 'undefined', 'null')
`;
  return dbTables.map((el) => el.table_name);
};

// src/routes/fn.ts
var app3 = new Elysia({ prefix: "/fn" });
app3.post("/", (res) => log("log", `${JSON.stringify(res)}`));
app3.get("/collections", getCollections);
app3.post("/validation/email", (res) => z.string().email().parse(res.body));
var fn_default = app3;

// src/routes/health.ts
var app4 = new Elysia({ prefix: "/health" });
app4.get("/", () => {
  return "healthy as a goat \uD83D\uDC10";
});
var health_default = app4;

// node_modules/@elysiajs/html/dist/index.js
var exports_dist = {};
__export(exports_dist, {
  isTagHtml: () => {
    {
      return isTagHtml;
    }
  },
  isHtml: () => {
    {
      return isHtml;
    }
  },
  html: () => {
    {
      return html2;
    }
  },
  createElement: () => {
    {
      return createElement;
    }
  },
  Suspense: () => {
    {
      return $Suspense;
    }
  },
  Html: () => {
    {
      return import_html.Html;
    }
  },
  ErrorBoundary: () => {
    {
      return $ErrorBoundary;
    }
  }
});

// node_modules/@elysiajs/html/dist/h.js
var exports_h = {};
__export(exports_h, {
  createElement: () => {
    {
      return createElement;
    }
  }
});
var html = __toESM(require_html(), 1);
var createElement = (name, attrs, ...children) => {
  const { $elysia, ...attr } = attrs ?? {};
  const a2 = html.createElement(name, attr, ...children);
  return a2;
};

// node_modules/@elysiajs/html/dist/html.js
var exports_html = {};
__export(exports_html, {
  html: () => {
    {
      return html2;
    }
  }
});
import {Readable as Readable2} from "stream";

// node_modules/@kitajs/html/suspense.js
var Suspense = function(props) {
  if (!SUSPENSE_ROOT.enabled) {
    throw new Error("Cannot use Suspense outside of a `renderToStream` call.");
  }
  if (!props.rid) {
    throw new Error("Suspense requires a `rid` to be specified.");
  }
  const fallback = contentsToString([props.fallback]);
  if (!props.children) {
    return "";
  }
  const children = contentsToString([props.children]);
  if (typeof children === "string") {
    return children;
  }
  let data = SUSPENSE_ROOT.requests.get(props.rid);
  if (!data) {
    throw new Error("Request data was deleted before all suspense components were resolved.");
  }
  const run = ++data.running;
  children.then(writeStreamTemplate).catch(function errorRecover(error23) {
    if (!props.catch) {
      throw error23;
    }
    let html2;
    if (typeof props.catch === "function") {
      html2 = props.catch(error23);
    } else {
      html2 = props.catch;
    }
    if (typeof html2 === "string") {
      return writeStreamTemplate(html2);
    }
    return html2.then(writeStreamTemplate);
  }).catch(function writeFatalError(error23) {
    if (data) {
      const stream2 = data.stream.deref();
      if (stream2 && stream2.emit("error", error23)) {
        return;
      }
    }
    console.error(error23);
  }).finally(function clearRequestData() {
    data = SUSPENSE_ROOT.requests.get(props.rid);
    if (!data) {
      return;
    }
    if (data.running > 1) {
      data.running -= 1;
    } else {
      const stream2 = data.stream.deref();
      if (stream2 && !stream2.closed) {
        stream2.end();
      }
      SUSPENSE_ROOT.requests.delete(props.rid);
    }
  });
  if (typeof fallback === "string") {
    return '<div id="B:' + run + '" data-sf>' + fallback + "</div>";
  }
  return fallback.then(function resolveCallback(resolved) {
    return '<div id="B:' + run + '" data-sf>' + resolved + "</div>";
  });
  function writeStreamTemplate(result) {
    data = SUSPENSE_ROOT.requests.get(props.rid);
    if (!data) {
      return;
    }
    const stream2 = data.stream.deref();
    if (!stream2 || stream2.closed) {
      return;
    }
    if (SUSPENSE_ROOT.autoScript && data.sent === false) {
      stream2.write(SuspenseScript);
      data.sent = true;
    }
    stream2.write('<template id="N:' + run + '" data-sr>' + result + '</template><script id="S:' + run + '" data-ss>$KITA_RC(' + run + ")</script>");
  }
};
var pipeHtml = function(html2, stream2, rid) {
  if (typeof html2 === "string") {
    stream2.write(html2);
    const requestData = SUSPENSE_ROOT.requests.get(rid);
    if (!requestData || requestData.running === 0) {
      stream2.end();
      SUSPENSE_ROOT.requests.delete(rid);
    }
    return;
  }
  html2.then(function writeStreamHtml(html3) {
    stream2.write(html3);
  }).catch(function catchError(error23) {
    if (stream2.emit("error", error23) === false) {
      console.error(error23);
    }
  }).finally(function endStream() {
    const requestData = SUSPENSE_ROOT.requests.get(rid);
    if (!requestData || requestData.running === 0) {
      stream2.end();
      SUSPENSE_ROOT.requests.delete(rid);
    }
  });
};
var renderToStream = function(factory, rid) {
  if (SUSPENSE_ROOT.enabled === false) {
    SUSPENSE_ROOT.enabled = true;
  }
  if (!rid) {
    rid = SUSPENSE_ROOT.requestCounter++;
  } else if (SUSPENSE_ROOT.requests.has(rid)) {
    throw new Error(`The provided Request Id is already in use: ${rid}.`);
  }
  const stream2 = new PassThrough;
  SUSPENSE_ROOT.requests.set(rid, {
    stream: new WeakRef(stream2),
    running: 0,
    sent: false
  });
  try {
    const html2 = factory(rid);
    pipeHtml(html2, stream2, rid);
    return stream2;
  } catch (renderError) {
    stream2.end();
    SUSPENSE_ROOT.requests.delete(rid);
    throw renderError;
  }
};
var { contentsToString } = require_html();
var { PassThrough, Writable } = import.meta.require("stream");
if (!globalThis.SUSPENSE_ROOT) {
  globalThis.SUSPENSE_ROOT = {
    requests: new Map,
    requestCounter: 1,
    enabled: false,
    autoScript: true
  };
}
var SuspenseScript = `
      <script id="kita-html-suspense">
        /*! Apache-2.0 https://kita.js.org */
        function \$KITA_RC(i){
          // simple aliases
          var d=document,q=d.querySelector.bind(d),
            // div sent as the fallback wrapper
            v=q('div[id="B:'+i+'"][data-sf]'),
            // template and script sent after promise finishes
            t=q('template[id="N:'+i+'"][data-sr]'),s=q('script[id="S:'+i+'"][data-ss]'),
            // fragment created to avoid inserting element one by one
            f=d.createDocumentFragment(),
            // used by iterators
            c,j,
            // all pending hydrations
            r;

          // if div or template is not found, let this hydration as pending
          if(t&&v&&s){
            // appends into the fragment
            while(c=t.content.firstChild)
              f.appendChild(c);

            // replaces the div and removes the script and template
            v.parentNode.replaceChild(f,v);
            t.remove();
            s.remove();

            // looks for pending templates
            r=d.querySelectorAll('template[id][data-sr]');

            do{
              // resets j from previous loop
              j=0;

              // loops over every found pending template and 
              for(c=0;c<r.length;c++)
                if(r[c]!=t)
                  // let j as true while at least on \$KITA_RC call returns true
                  j=\$KITA_RC(r[c].id.slice(2))?!0:j;
            }while(j)

            // we know at least the original template was substituted
            return!0;
          }
        }
      </script>
    `.replace(/^\s*\/\/.*/gm, "").replace(/\n\s*/g, "");
var $Suspense = Suspense;
var $renderToStream = renderToStream;

// node_modules/@elysiajs/html/dist/handler.js
import {Readable} from "stream";

// node_modules/@elysiajs/html/dist/utils.js
var exports_utils = {};
__export(exports_utils, {
  isTagHtml: () => {
    {
      return isTagHtml;
    }
  },
  isHtml: () => {
    {
      return isHtml;
    }
  }
});
function isHtml(value15) {
  if (typeof value15 !== "string")
    return false;
  value15 = value15.trim();
  const length = value15.length;
  return length >= 7 && value15[0] === "<" && value15[length - 1] === ">";
}
function isTagHtml(value15) {
  return value15.trimStart().slice(0, 5).startsWith("<html");
}

// node_modules/@elysiajs/html/dist/handler.js
function handleHtml(value15, options, hasContentType) {
  if (value15 instanceof Promise) {
    return value15.then((v) => handleHtml(v, options, hasContentType));
  }
  if (typeof value15 === "string") {
    if (options.autoDoctype && isHtml(value15) && isTagHtml(value15))
      value15 = "<!doctype html>" + value15;
    return new Response(value15, hasContentType ? undefined : { headers: { "content-type": options.contentType } });
  }
  let stream2 = Readable.toWeb(value15);
  if (options.autoDoctype) {
    let first = true;
    stream2 = stream2.pipeThrough(new TransformStream({
      transform(chunk, controller) {
        let str = chunk.toString();
        if (first && isTagHtml(str) && isTagHtml(str)) {
          first = false;
          str = "<!doctype html>" + str;
        }
        controller.enqueue(str);
      }
    }));
  }
  return new Response(stream2, hasContentType ? undefined : { headers: { "content-type": options.contentType } });
}

// node_modules/@elysiajs/html/dist/html.js
function html2(options = {}) {
  options.contentType ??= "text/html; charset=utf8";
  options.autoDetect ??= true;
  options.isHtml ??= isHtml;
  options.autoDoctype ??= true;
  const instance = new Elysia({
    name: "@elysiajs/html",
    seed: options
  }).derive({ as: "global" }, ({ set: set2 }) => {
    return {
      html(value15) {
        return handleHtml(value15, options, "content-type" in set2.headers);
      },
      stream(value15, args) {
        return handleHtml($renderToStream((id) => value15({ ...args, id })), options, "content-type" in set2.headers);
      }
    };
  });
  if (options.autoDetect)
    return instance.mapResponse({ as: "global" }, async function handlerPossibleHtml({ response: value15, set: set2 }) {
      if (isHtml(value15) || value15 instanceof Readable2 && "rid" in value15) {
        const response = await handleHtml(value15, options, "content-type" in set2.headers);
        if (response instanceof Response)
          return response;
        set2.headers["content-type"] = options.contentType;
        return new Response(response);
      }
      return;
    });
  return instance;
}
// node_modules/@elysiajs/html/dist/options.js
var exports_options = {};

// node_modules/@elysiajs/html/dist/index.js
__reExport(exports_dist, __toESM(require_register(), 1));

// node_modules/@kitajs/html/error-boundary.js
var ErrorBoundary = function(props) {
  let children = contentsToString2([props.children]);
  if (typeof children === "string") {
    return children;
  }
  if (props.timeout) {
    children = Promise.race([
      children,
      setTimeout2(props.timeout).then(function reject() {
        const error23 = new Error("Children timed out.");
        error23[TIMEOUT_SYMBOL] = true;
        throw error23;
      })
    ]);
  }
  return children.catch(function errorBoundary(error23) {
    if (typeof props.catch === "function") {
      return props.catch(error23);
    }
    return props.catch;
  });
};
var { contentsToString: contentsToString2 } = require_html();
var { setTimeout: setTimeout2 } = import.meta.require("timers/promises");
var TIMEOUT_SYMBOL = Symbol.for("kHtmlTimeout");
var $ErrorBoundary = ErrorBoundary;

// node_modules/@elysiajs/html/dist/index.js
var import_html = __toESM(require_html(), 1);
Html.createElement = createElement;

// src/ui/layouts/Main.tsx
var Body = ({ children }) => Html.createElement("html", {
  lang: "en"
}, Html.createElement("head", null, Html.createElement("meta", {
  charset: "UTF-8"
}), Html.createElement("meta", {
  name: "viewport",
  content: "width=device-width, initial-scale=1.0"
}), Html.createElement("title", null, "Great Asset"), Html.createElement("link", {
  rel: "stylesheet",
  href: "https://unpkg.com/98.css"
}), Html.createElement("script", {
  src: "https://unpkg.com/htmx.org@1.9.10"
})), Html.createElement("body", {
  style: "background-color: #c0c0c0"
}, children));

// src/ui/pages/Home.tsx
var Home = () => Html.createElement(Body, null, Html.createElement("main", null, Html.createElement("h1", null, "Home"), Html.createElement("a", {
  href: "/ui/models"
}, "models")));
var Home_default = Home;

// src/ui/forms/CreateModel.tsx
var CreateModel = () => Html.createElement(Html.Fragment, null, Html.createElement("h3", null, "Create new Model"), Html.createElement("form", {
  "hx-post": "/fn"
}, Html.createElement("label", {
  for: "name"
}, "Name:"), Html.createElement("input", {
  id: "name",
  placeholder: "name",
  title: "name",
  type: "text"
}), Html.createElement("button", {
  type: "button"
}, "Submit")));

// src/ui/pages/Models.tsx
var Models = () => Html.createElement(Body, null, Html.createElement("main", null, Html.createElement("h1", null, "Models"), Html.createElement("a", {
  href: "/ui"
}, "home"), Html.createElement("button", {
  "hx-get": "/fn",
  "hx-swap": "outerHTML"
}, "Click Me!"), Html.createElement("div", null, Html.createElement(CreateModel, null))));
var Models_default = Models;

// src/routes/ui.ts
var app5 = new Elysia({ prefix: "/ui" });
app5.use(html2({ autoDetect: false }));
app5.get("/", (e2) => {
  e2.set.headers["Content-Type"] = "text/html; charset=utf8";
  return Home_default();
});
app5.get("/models", (e2) => {
  e2.set.headers["Content-Type"] = "text/html; charset=utf8";
  return Models_default();
});
var ui_default = app5;

// src/schemas/forms/Alter_Table_Column.ts
var Alter_Table_Column_Schema = z.object({
  columnName: z.string(),
  newColumnName: z.string(),
  validationMessage: z.optional(z.string().describe("Validation message to throw if there's an error"))
});

// src/schemas/forms/Alter_Table.ts
var Alter_Table_Schema = z.object({
  name: z.string(),
  columns: z.array(Alter_Table_Column_Schema)
});

// src/schemas/Column_Relationship.ts
var RelationshipType;
(function(RelationshipType2) {
  RelationshipType2["m2m"] = "m2m";
  RelationshipType2["o2m"] = "o2m";
  RelationshipType2["o2o"] = "o2o";
})(RelationshipType || (RelationshipType = {}));
var Column_Relationship_Schema = z.object({
  foreignKey: z.string(),
  primaryKey: z.string(),
  referencedColumn: z.string(),
  referencedTable: z.string(),
  relatedTo: z.string(),
  relationshipType: z.nativeEnum(RelationshipType)
});

// src/schemas/forms/Table_Column.ts
var Table_Column_Schema = z.object({
  name: z.string(),
  relationship: z.optional(Column_Relationship_Schema),
  type: z.union([z.literal("SERIAL"), z.literal("TEXT"), z.literal("VARCHAR"), z.literal("TIMESTAMP")]),
  length: z.optional(z.number()),
  nullable: z.optional(z.boolean()),
  unique: z.optional(z.boolean()),
  required: z.optional(z.boolean()),
  readonly: z.optional(z.boolean()),
  hidden: z.optional(z.boolean()),
  note: z.optional(z.string()),
  validationMessage: z.optional(z.string().describe("Validation message to throw if there's an error"))
});

// src/schemas/forms/Table.ts
var Table_Schema = z.object({
  name: z.string(),
  columns: z.array(Table_Column_Schema)
});

// src/services/database/columns.ts
var client2 = __toESM(require_default2(), 1);
var alterColumn = async (tableData) => {
  const { name, columns } = tableData;
  const { name: columnName, type: type74 } = columns[0];
  const query = `
    ALTER TABLE ${name}
    MODIFY COLUMN ${columnName} ${type74};
  `;
  log("log", `EXECUTING QUERY: ${query}`);
  const result = await prisma.$queryRaw`${client2.Prisma.raw(query)}`;
  return !!result;
};
var alterBulkColumn = async (tableData) => {
  const { name, columns } = tableData;
  let queryString = "";
  columns.forEach((el, index) => {
    const { name: columnName, type: type74 } = el;
    const isLast = index === columns.length - 1;
    const end = isLast ? ";" : ",";
    const str = `MODIFY COLUMN ${columnName} ${type74}${end}`;
    queryString = queryString.concat(str);
  });
  const query = `
    ALTER TABLE ${name}
    ${queryString}
  `;
  log("log", `EXECUTING QUERY: ${query}`);
  const result = await prisma.$queryRaw`${client2.Prisma.raw(query)}`;
  return !!result;
};
var createColumn = async (tableData) => {
  const { name, columns } = tableData;
  const { name: columnName, type: type74 } = columns[0];
  const query = `
    ALTER TABLE ${name}
    ADD ${columnName} ${type74}
  `;
  log("log", `EXECUTING QUERY: ${query}`);
  const result = await prisma.$queryRaw`${client2.Prisma.raw(query)}`;
  return !!result;
};
var createBulkColumns = async (tableData) => {
  const { name, columns } = tableData;
  let queryString = "";
  columns.forEach((el, index) => {
    const { name: columnName, type: type74 } = el;
    const isLast = index === columns.length - 1;
    const end = isLast ? ";" : ",";
    const str = `ADD ${columnName} ${type74}${end}`;
    queryString = queryString.concat(str);
  });
  const query = `
    ALTER TABLE ${name}
    ${queryString}
  `;
  log("log", `EXECUTING QUERY: ${query}`);
  const result = await prisma.$queryRaw`${client2.Prisma.raw(query)}`;
  return !!result;
};
var deleteColumn = async (tableData) => {
  const { name, columns } = tableData;
  const { name: columnName } = columns[0];
  const query = `
    ALTER TABLE ${name}
    DROP COLUMN ${columnName}
    `;
  log("log", `EXECUTING QUERY: ${query}`);
  const result = await prisma.$queryRaw`${client2.Prisma.raw(query)}`;
  return !!result;
};
var deleteBulkColumns = async (tableData) => {
  const { name, columns } = tableData;
  let queryString = "";
  columns.forEach((el, index) => {
    const { name: columnName } = el;
    const isLast = index === columns.length - 1;
    const end = isLast ? ";" : ",";
    const str = `DROP COLUMN ${columnName}${end}`;
    queryString = queryString.concat(str);
  });
  const query = `
    ALTER TABLE ${name}
    ${queryString}
    `;
  log("log", `EXECUTING QUERY: ${query}`);
  const result = await prisma.$queryRaw`${client2.Prisma.raw(query)}`;
  return !!result;
};
var renameColumn = async (tableData) => {
  const { name, columns } = tableData;
  const { columnName, newColumnName } = columns[0];
  const query = `
    ALTER TABLE ${name}
    RENAME COLUMN ${columnName} to ${newColumnName};
  `;
  log("log", `EXECUTING QUERY: ${query}`);
  const result = await prisma.$queryRaw`${client2.Prisma.raw(query)}`;
  return !!result;
};
var renameBulkColumns = async (tableData) => {
  const { name, columns } = tableData;
  let queryString = "";
  columns.forEach((el, index) => {
    const { columnName, newColumnName } = el;
    const isLast = index === columns.length - 1;
    const end = isLast ? ";" : ",";
    const str = `RENAME COLUMN ${columnName} to ${newColumnName}${end}`;
    queryString = queryString.concat(str);
  });
  const query = `
    ALTER TABLE ${name}
    ${queryString}
    `;
  log("log", `EXECUTING QUERY: ${query}`);
  const result = await prisma.$queryRaw`${client2.Prisma.raw(query)}`;
  return !!result;
};

// src/services/database/json.ts
var client3 = __toESM(require_default2(), 1);
var getJSONSchema = async (collection) => {
  if (!collection)
    return client3.Prisma.dmmf.datamodel;
  const collections = await getCollections();
  const isValid2 = collections.find((el) => el === collection);
  if (!isValid2)
    return {};
  return client3.Prisma.dmmf.datamodel.models.find((el) => el.name === collection);
};

// src/services/database/tables.ts
var client4 = __toESM(require_default2(), 1);
var buildQuery = (columns) => {
  const s = [];
  columns.forEach((el, index) => {
    const { length, name, nullable, relationship, type: type74, unique } = el;
    const isPrimary = !!relationship?.primaryKey;
    const isForeign = !!relationship?.foreignKey;
    const shouldHaveKeyStr = isPrimary || isForeign;
    const referencedColumn = relationship?.referencedColumn || "";
    const referencedTable = relationship?.referencedTable || "";
    const constraintName = `fk_${referencedTable}`;
    const fkName = relationship?.foreignKey || "";
    const keyStr = shouldHaveKeyStr ? `${isPrimary ? "SERIAL PRIMARY KEY" : `CONSTRAINT ${constraintName} FOREIGN KEY(${fkName}) REFERENCES ${referencedTable}(${referencedColumn}) `}` : "";
    const uniqueStr = unique ? "UNIQUE" : "";
    const nullStr = nullable ? "" : "NOT NULL";
    const isLast = index === columns?.length - 1;
    const endStr = isLast ? "" : "";
    const hasStringLimit = Boolean(length) ?? false;
    const limit = hasStringLimit ? `(${length})` : "";
    const stmt = `${type74} ${limit} ${uniqueStr} ${nullStr}`;
    const str = `${name} ${keyStr} ${stmt} ${endStr}`;
    s.push(str);
  });
  return s.toString();
};
var createTable = async (tableData) => {
  const { name, columns = [] } = tableData;
  const queryString = buildQuery(columns);
  const query = `
  CREATE TABLE IF NOT EXISTS ${name} (
    ${queryString}
    )
  `;
  log("log", `EXECUTING QUERY: ${query}`);
  const result = await prisma.$queryRaw`${client4.Prisma.raw(query)}`;
  return !!result;
};
var deleteTable = async (tableData) => {
  const { name } = tableData;
  const query = `DROP TABLE IF EXISTS ${name}`;
  log("log", `EXECUTING QUERY: ${query}`);
  const result = await prisma.$queryRaw`${client4.Prisma.raw(query)}`;
  return !!result;
};

// src/routes/database.ts
var app6 = new Elysia({ prefix: "/database" });
app6.get("/json/schema/", getJSONSchema);
app6.get("/json/schema/:collection", ({ params: { collection } }) => getJSONSchema(collection));
app6.post("/create/table", async ({ body }) => {
  const verified = Table_Schema.safeParse(body);
  if (!verified.success)
    return { status: 400, data: verified.error };
  const data = await createTable(verified.data);
  return { status: 200, data };
});
app6.post("/delete/table", async ({ body }) => {
  const verified = Table_Schema.safeParse(body);
  if (!verified.success)
    return { status: 400, data: verified.error };
  const data = await deleteTable(verified.data);
  return { status: 200, data };
});
app6.post("/alter/column", async ({ body }) => {
  const verified = Table_Schema.safeParse(body);
  if (!verified.success)
    return { status: 400, data: verified.error };
  const data = await alterColumn(verified.data);
  return { status: 200, data };
});
app6.post("/alter/bulk/column", async ({ body }) => {
  const verified = Table_Schema.safeParse(body);
  if (!verified.success)
    return { status: 400, data: verified.error };
  const data = await alterBulkColumn(verified.data);
  return { status: 200, data };
});
app6.post("/create/column", async ({ body }) => {
  const verified = Table_Schema.safeParse(body);
  if (!verified.success)
    return { status: 400, data: verified.error };
  const data = await createColumn(verified.data);
  return { status: 200, data };
});
app6.post("/create/bulk/column", async ({ body }) => {
  const verified = Table_Schema.safeParse(body);
  if (!verified.success)
    return { status: 400, data: verified.error };
  const data = await createBulkColumns(verified.data);
  return { status: 200, data };
});
app6.post("/delete/column", async ({ body }) => {
  const verified = Table_Schema.safeParse(body);
  if (!verified.success)
    return { status: 400, data: verified.error };
  const data = await deleteColumn(verified.data);
  return { status: 200, data };
});
app6.post("/delete/bulk/column", async ({ body }) => {
  const verified = Table_Schema.safeParse(body);
  if (!verified.success)
    return { status: 400, data: verified.error };
  const data = await deleteBulkColumns(verified.data);
  return { status: 200, data };
});
app6.post("/rename/column", async ({ body }) => {
  const verified = Alter_Table_Schema.safeParse(body);
  if (!verified.success)
    return { status: 400, data: verified.error };
  const data = await renameColumn(verified.data);
  return { status: 200, data };
});
app6.post("/rename/bulk/column", async ({ body }) => {
  const verified = Alter_Table_Schema.safeParse(body);
  if (!verified.success)
    return { status: 400, data: verified.error };
  const data = await renameBulkColumns(verified.data);
  return { status: 200, data };
});
var database_default = app6;

// src/routes/search.ts
var app7 = new Elysia({ prefix: "/search" });
var search = async (query, filters, pagination) => {
  const collections = await getCollections();
  const q = collections.map((el, index) => `select coalesce(id, null), coalesce(name, '') from ${el} ${index === collections.length - 1 ? "" : "union"} `).join("");
  return { collections, q, query, filters, pagination };
};
app7.get("/:query", ({ params: { query } }) => search(query));
app7.get("/:query/:filters", ({ params: { query, filters } }) => search(query, filters));
app7.get("/:query/:filters/:pagination", ({ params: { query, filters, pagination } }) => search(query, filters, pagination));
var search_default = app7;

// node_modules/@adonisjs/env/build/chunk-H6UKLEIO.js
import {fileURLToPath} from "url";
import {readFile} from "fs/promises";
import {isAbsolute, join as join2} from "path";
import {debuglog} from "util";
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var debug_default = debuglog("adonisjs:env");
var EnvLoader = class {
  #appRoot;
  #loadExampleFile;
  constructor(appRoot, loadExampleFile = false) {
    this.#appRoot = typeof appRoot === "string" ? appRoot : fileURLToPath(appRoot);
    this.#loadExampleFile = loadExampleFile;
  }
  async#loadFile(filePath) {
    try {
      const contents = await readFile(filePath, "utf-8");
      return { contents, fileExists: true };
    } catch (error23) {
      if (error23.code !== "ENOENT") {
        throw error23;
      }
      return { contents: "", fileExists: false };
    }
  }
  async load() {
    const ENV_PATH = process.env.ENV_PATH;
    const NODE_ENV = "development";
    const envFiles = [];
    if (debug_default.enabled) {
      debug_default("ENV_PATH variable is %s", ENV_PATH ? "set" : "not set");
      debug_default("NODE_ENV variable is %s", NODE_ENV ? "set" : "not set");
    }
    const baseEnvPath = ENV_PATH ? isAbsolute(ENV_PATH) ? ENV_PATH : join2(this.#appRoot, ENV_PATH) : this.#appRoot;
    if (debug_default.enabled) {
      debug_default('dot-env files base path "%s"', baseEnvPath);
    }
    if (NODE_ENV) {
      const nodeEnvLocalFile = join2(baseEnvPath, `.env.${NODE_ENV}.local`);
      envFiles.push({
        path: nodeEnvLocalFile,
        ...await this.#loadFile(nodeEnvLocalFile)
      });
    }
    if (!NODE_ENV || !["test", "testing"].includes(NODE_ENV)) {
      const envLocalFile = join2(baseEnvPath, ".env.local");
      envFiles.push({
        path: envLocalFile,
        ...await this.#loadFile(envLocalFile)
      });
    }
    if (NODE_ENV) {
      const nodeEnvFile = join2(baseEnvPath, `.env.${NODE_ENV}`);
      envFiles.push({
        path: nodeEnvFile,
        ...await this.#loadFile(nodeEnvFile)
      });
    }
    const envFile = join2(baseEnvPath, ".env");
    envFiles.push({
      path: envFile,
      ...await this.#loadFile(envFile)
    });
    if (this.#loadExampleFile) {
      const envExampleFile = join2(baseEnvPath, ".env.example");
      envFiles.push({
        path: envExampleFile,
        ...await this.#loadFile(envExampleFile)
      });
    }
    return envFiles;
  }
};

// node_modules/@adonisjs/env/build/index.js
var validator_lite = __toESM(require_build(), 1);

// node_modules/@lukeed/ms/dist/index.mjs
function parse5(val) {
  var num, arr = val.toLowerCase().match(RGX);
  if (arr != null && (num = parseFloat(arr[1]))) {
    if (arr[3] != null)
      return num * SEC;
    if (arr[4] != null)
      return num * MIN;
    if (arr[5] != null)
      return num * HOUR;
    if (arr[6] != null)
      return num * DAY;
    if (arr[7] != null)
      return num * DAY * 7;
    if (arr[8] != null)
      return num * YEAR;
    return num;
  }
}
var fmt = function(val, pfx, str, long) {
  var num = (val | 0) === val ? val : ~~(val + 0.5);
  return pfx + num + (long ? " " + str + (num != 1 ? "s" : "") : str[0]);
};
function format(num, long) {
  var pfx = num < 0 ? "-" : "", abs = num < 0 ? -num : num;
  if (abs < SEC)
    return num + (long ? " ms" : "ms");
  if (abs < MIN)
    return fmt(abs / SEC, pfx, "second", long);
  if (abs < HOUR)
    return fmt(abs / MIN, pfx, "minute", long);
  if (abs < DAY)
    return fmt(abs / HOUR, pfx, "hour", long);
  if (abs < YEAR)
    return fmt(abs / DAY, pfx, "day", long);
  return fmt(abs / YEAR, pfx, "year", long);
}
var RGX = /^(-?(?:\d+)?\.?\d+) *(m(?:illiseconds?|s(?:ecs?)?))?(s(?:ec(?:onds?|s)?)?)?(m(?:in(?:utes?|s)?)?)?(h(?:ours?|rs?)?)?(d(?:ays?)?)?(w(?:eeks?|ks?)?)?(y(?:ears?|rs?)?)?$/;
var SEC = 1000;
var MIN = SEC * 60;
var HOUR = MIN * 60;
var DAY = HOUR * 24;
var YEAR = DAY * 365.25;

// node_modules/@poppinss/utils/build/chunk-NKGAOHNN.js
var Base64 = class {
  encode(data, encoding) {
    if (typeof data === "string") {
      return Buffer.from(data, encoding).toString("base64");
    }
    return Buffer.from(data).toString("base64");
  }
  decode(encoded, encoding = "utf-8", strict4 = false) {
    if (Buffer.isBuffer(encoded)) {
      return encoded.toString(encoding);
    }
    const decoded = Buffer.from(encoded, "base64").toString(encoding);
    const isInvalid = this.encode(decoded, encoding) !== encoded;
    if (strict4 && isInvalid) {
      throw new Error("Cannot decode malformed value");
    }
    return isInvalid ? null : decoded;
  }
  urlEncode(data, encoding) {
    const encoded = typeof data === "string" ? this.encode(data, encoding) : this.encode(data);
    return encoded.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  }
  urlDecode(encoded, encoding = "utf-8", strict4 = false) {
    if (Buffer.isBuffer(encoded)) {
      return encoded.toString(encoding);
    }
    const decoded = Buffer.from(encoded, "base64").toString(encoding);
    const isInvalid = this.urlEncode(decoded, encoding) !== encoded;
    if (strict4 && isInvalid) {
      throw new Error("Cannot urlDecode malformed value");
    }
    return isInvalid ? null : decoded;
  }
};
var base64 = new Base64;
var milliseconds_default = {
  format(milliseconds, long) {
    return format(milliseconds, long);
  },
  parse(duration) {
    if (typeof duration === "number") {
      return duration;
    }
    const milliseconds = parse5(duration);
    if (milliseconds === undefined) {
      throw new Error(`Invalid duration expression "${duration}"`);
    }
    return milliseconds;
  }
};

// node_modules/@poppinss/utils/build/chunk-IOBSMUFC.js
var import_secure_json_parse = __toESM(require_secure_json_parse(), 1);
var safeParse = function(jsonString, reviver) {
  return import_secure_json_parse.parse(jsonString, reviver, {
    protoAction: "remove",
    constructorAction: "remove"
  });
};

// node_modules/safe-stable-stringify/esm/wrapper.js
var import__ = __toESM(require_safe_stable_stringify(), 1);
var configure = import__.default.configure;

// node_modules/@poppinss/utils/build/chunk-IOBSMUFC.js
var jsonStringifyReplacer = function(replacer) {
  return function(key, value15) {
    const val = replacer ? replacer.call(this, key, value15) : value15;
    if (typeof val === "bigint") {
      return val.toString();
    }
    return val;
  };
};
var safeStringify = function(value15, replacer, space) {
  return stringify(value15, jsonStringifyReplacer(replacer), space);
};
var stringify = configure({
  bigint: false,
  circularValue: undefined,
  deterministic: false
});
var json3 = {
  safeParse,
  safeStringify
};
var main_default = json3;

// node_modules/@poppinss/utils/build/index.js
var lodash = __toESM(require_main(), 1);
var lodash3 = __toESM(require_main(), 1);
var REDACTED = "[redacted]";
var Secret = class _Secret {
  #value;
  #keyword;
  constructor(value15, redactedKeyword) {
    this.#value = value15;
    this.#keyword = redactedKeyword || REDACTED;
  }
  toJSON() {
    return this.#keyword;
  }
  valueOf() {
    return this.#keyword;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.#keyword;
  }
  toLocaleString() {
    return this.#keyword;
  }
  toString() {
    return this.#keyword;
  }
  release() {
    return this.#value;
  }
  map(transformFunc) {
    return new _Secret(transformFunc(this.#value));
  }
};
var Exception = class extends Error {
  name;
  status;
  constructor(message, options2) {
    super(message, options2);
    const ErrorConstructor = this.constructor;
    this.name = ErrorConstructor.name;
    this.message = message || ErrorConstructor.message || "";
    this.status = options2?.status || ErrorConstructor.status || 500;
    const code = options2?.code || ErrorConstructor.code;
    if (code !== undefined) {
      this.code = code;
    }
    const help = ErrorConstructor.help;
    if (help !== undefined) {
      this.help = help;
    }
    Error.captureStackTrace(this, ErrorConstructor);
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    if (this.code) {
      return `${this.name} [${this.code}]: ${this.message}`;
    }
    return `${this.name}: ${this.message}`;
  }
};
var MessageBuilder = class {
  #getExpiryDate(expiresIn) {
    if (!expiresIn) {
      return;
    }
    const expiryMs = milliseconds_default.parse(expiresIn);
    return new Date(Date.now() + expiryMs);
  }
  #isExpired(message) {
    if (!message.expiryDate) {
      return false;
    }
    const expiryDate = new Date(message.expiryDate);
    return Number.isNaN(expiryDate.getTime()) || expiryDate < new Date;
  }
  build(message, expiresIn, purpose) {
    const expiryDate = this.#getExpiryDate(expiresIn);
    return main_default.safeStringify({ message, purpose, expiryDate });
  }
  verify(message, purpose) {
    const parsed = main_default.safeParse(message);
    if (typeof parsed !== "object" || !parsed) {
      return null;
    }
    if (!parsed.message) {
      return null;
    }
    if (parsed.purpose !== purpose) {
      return null;
    }
    if (this.#isExpired(parsed)) {
      return null;
    }
    return parsed.message;
  }
};
var ObjectBuilder = class {
  #ignoreNull;
  values;
  constructor(initialValue, ignoreNull) {
    this.values = initialValue;
    this.#ignoreNull = ignoreNull === true ? true : false;
  }
  add(key, value15) {
    if (value15 === undefined) {
      return this;
    }
    if (this.#ignoreNull === true && value15 === null) {
      return this;
    }
    this.values[key] = value15;
    return this;
  }
  remove(key) {
    delete this.values[key];
    return this;
  }
  has(key) {
    return this.get(key) !== undefined;
  }
  get(key) {
    return this.values[key];
  }
  toObject() {
    return this.values;
  }
};

// node_modules/@adonisjs/env/build/index.js
var import_dotenv = __toESM(require_main2(), 1);
var errors_exports = {};
__export2(errors_exports, {
  E_INVALID_ENV_VARIABLES: () => E_INVALID_ENV_VARIABLES
});
var E_INVALID_ENV_VARIABLES = class EnvValidationException extends Exception {
  static message = "Validation failed for one or more environment variables";
  static code = "E_INVALID_ENV_VARIABLES";
  help = "";
};
var EnvValidator = class {
  #schema;
  #error;
  constructor(schema3) {
    this.#schema = schema3;
    this.#error = new E_INVALID_ENV_VARIABLES;
  }
  validate(values) {
    const help = [];
    const validated = Object.keys(this.#schema).reduce((result, key) => {
      const value15 = process.env[key] || values[key];
      try {
        result[key] = this.#schema[key](key, value15);
      } catch (error23) {
        help.push(`- ${error23.message}`);
      }
      return result;
    }, { ...values });
    if (help.length) {
      this.#error.help = help.join("\n");
      throw this.#error;
    }
    return validated;
  }
};
var EnvParser = class {
  #envContents;
  #preferProcessEnv = true;
  constructor(envContents, options2) {
    if (options2?.ignoreProcessEnv) {
      this.#preferProcessEnv = false;
    }
    this.#envContents = envContents;
  }
  #getValue(key, parsed) {
    if (this.#preferProcessEnv && process.env[key]) {
      return process.env[key];
    }
    if (parsed[key]) {
      return this.#interpolate(parsed[key], parsed);
    }
    return process.env[key] || "";
  }
  #interpolateMustache(token, parsed) {
    const closingBrace = token.indexOf("}");
    if (closingBrace === -1) {
      return token;
    }
    const varReference = token.slice(1, closingBrace).trim();
    return `${this.#getValue(varReference, parsed)}${token.slice(closingBrace + 1)}`;
  }
  #interpolateVariable(token, parsed) {
    return token.replace(/[a-zA-Z0-9_]+/, (key) => {
      return this.#getValue(key, parsed);
    });
  }
  #interpolate(value15, parsed) {
    const tokens = value15.split("$");
    let newValue = "";
    let skipNextToken = true;
    tokens.forEach((token) => {
      if (token === "\\") {
        newValue += "$";
        skipNextToken = true;
        return;
      }
      if (skipNextToken) {
        newValue += token.replace(/\\$/, "$");
        if (token.endsWith("\\")) {
          return;
        }
      } else {
        if (token.startsWith("{")) {
          newValue += this.#interpolateMustache(token, parsed);
          return;
        }
        newValue += this.#interpolateVariable(token, parsed);
      }
      skipNextToken = false;
    });
    return newValue;
  }
  parse() {
    const envCollection = import_dotenv.default.parse(this.#envContents.trim());
    return Object.keys(envCollection).reduce((result, key) => {
      result[key] = this.#getValue(key, envCollection);
      return result;
    }, {});
  }
};
var EnvProcessor = class {
  #appRoot;
  constructor(appRoot) {
    this.#appRoot = appRoot;
  }
  #processContents(envContents, store) {
    if (!envContents.trim()) {
      return store;
    }
    const values = new EnvParser(envContents).parse();
    Object.keys(values).forEach((key) => {
      let value15 = process.env[key];
      if (!value15) {
        value15 = values[key];
        process.env[key] = values[key];
      }
      if (!store[key]) {
        store[key] = value15;
      }
    });
    return store;
  }
  async#loadAndProcessDotFiles() {
    const loader = new EnvLoader(this.#appRoot);
    const envFiles = await loader.load();
    if (debug_default.enabled) {
      debug_default("processing .env files (priority from top to bottom) %O", envFiles.map((file) => file.path));
    }
    const envValues = {};
    envFiles.forEach(({ contents }) => this.#processContents(contents, envValues));
    return envValues;
  }
  async process() {
    return this.#loadAndProcessDotFiles();
  }
};
var Env = class _Env {
  #values;
  constructor(values) {
    this.#values = values;
  }
  static async create(appRoot, schema3) {
    const values = await new EnvProcessor(appRoot).process();
    const validator = this.rules(schema3);
    return new _Env(validator.validate(values));
  }
  static schema = validator_lite.schema;
  static rules(schema3) {
    const validator = new EnvValidator(schema3);
    return validator;
  }
  get(key, defaultValue) {
    if (this.#values[key] !== undefined) {
      return this.#values[key];
    }
    const envValue = process.env[key];
    if (envValue) {
      return envValue;
    }
    return defaultValue;
  }
  set(key, value15) {
    this.#values[key] = value15;
    process.env[key] = value15;
  }
};

// env.ts
function env3() {
  return validator.validate(process.env);
}
var validator = Env.rules({
  PORT: Env.schema.number(),
  DATABASE_URL: Env.schema.string()
});

// src/index.ts
var app8 = new Elysia;
app8.use(swagger2());
app8.use(cors());
app8.use(compression());
app8.get("/", generateTempObject);
app8.get("/schema", returnSchema);
app8.use(dist_default()).get("/auth", ({ bearer: bearer3 }) => bearer3, {
  beforeHandle({ bearer: bearer3, set: set2 }) {
    if (!bearer3) {
      set2.status = 400;
      set2.headers["WWW-Authenticate"] = `Bearer realm='sign', error="invalid_request"`;
      return "Unauthorized";
    }
  }
});
app8.get("/cookie", ({ cookie: { name } }) => {
  name.value;
  name.value = "New Value";
  name.value = {
    hello: "world"
  };
});
app8.use(database_default);
app8.use(fn_default);
app8.use(health_default);
app8.use(orm_default);
app8.use(schema_default);
app8.use(search_default);
app8.use(ui_default);
app8.listen(env3().PORT);
log("log", `\uD83E\uDD8A Elysia is running at ${app8.server?.hostname}:${app8.server?.port}`);
